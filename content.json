{"pages":[{"title":"About","text":"안녕하세요 미슈카 입니다.미슈카는 러시아어 이름 미하일(Михаи́л)의 애칭이며 '곰돌이'라는 뜻을 가지고 있습니다. 특이하게 저의 전공은 무대미술입니다. 우연한 계기로 웹쪽 일을 접하게 되어웹 퍼블리셔로 시작하여 현재는 프론트엔드 개발자로 전향해 열심히 개발을 하고 있습니다. 개발을 공부하면서 알게 되는 것들과 남겨야 할것 들을 정리하기 위해 블로그를 운영하고 있습니다. 잘못된 부분이 있거나 논의가 필요한 부분은 댓글이나 메일로 남겨주시면 감사하겠습니다.모든 댓글에 답글을 달고 있습니다. 댓글은 소통이라고 생각하며 모든 댓글에 답글을 달아드립니다. Career밀랑 주식회사 - Front end Developer (2019.09 ~ 현재) vue framework를 이용한 어플리케이션 개발 (주)라이프스타일프로젝트 - Web Publisher (2018.02 ~ 2019.08) 카페24 솔루션 이용한 쇼핑몰 개발 쇼핑몰 월별 프로모션 HTML/CSS/Jquery/PHP 를 이용한 브랜드 사이트 개발 허브디앤씨 - Web Publisher (2017.03 ~ 2017~11) HTML/CSS/Jquery 를 이용한 다양한 반응형 사이트 개발","link":"/about/index.html"}],"posts":[{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 10. 맵과 셋","text":"ES6에서 도입 맵은 키와 값을 연결한다는 점에서 객체와 비슷셋은 중복을 허용하지 않는다는 점만 제외하면 배열과 비슷 맵키와값을 연결할때 객체를 사용하면 발생하는 단점 프로토타입 체인 때문에 의도하지 않은 연결이 생길 수 있다.객체 안에 연결된 키와 값이 몇 개나 되는지 쉽게 알아낼 수 있는 방법이 없다.키는 반드시 문자열이나 심볼이어야 하므로 객체를 키로 써서 값과 연결 할수 없다.객체는 프로퍼티 순서를 전혀 보장하지 않는다.Map 객체는 이들 결함을 모두 해결, 키와 값을 연결할 목적이라면 객체보다 나은 선택이다. set()메서드를 써서 사용자 역할을 할당역할을 알아볼때는 get()메서드맵에 존재하지 않는 키에 get을 호출하면 undefined를 반환한다.맵에 키가 존재하는지 확인하는 has()메서드맵에 이미 존재하는 키에 set()을 호출하면 값이 교체size프로퍼티는 맵의 요소 숫자를 반환keys()메서드는 맵의 키를 반환values()메서드는 값을 반환entries()메서드는 첫 번째 요소가 키이고 두 번째 요소가 값인 배열을 각각 반환 이터러블 객체보다 배열이 필요하다면 확산연산자(…)를 사용맵의 요소를 지울때는 delete()메서드맵의 요소를 모두 지울때는 clear()메서드 위크맵다음 차이점을 제외하면 Map과 완전히 같다.키는 반드시 객체여야 한다.WeekMap의키는 가비지 콜렉션에 포함될 수 있다.WeekMap은 이터러블이 아니며 clear() 메서드도 없다. 셋셋은 중복을 허용하지 않는 데이터 집합이다. 사용자역할을 추가할 때는 add()메서드 - 추가하려는 것이 이미 있다면 아무일도 일어나지 않는다. size프로퍼티는 셋의 요소 숫자를 반환역할을 제거할 때는 delete()메서드 - 제거에 성공하면 true를 반환, 그렇지 않다면 false를 반환 위크셋위크셋은 객체만 포함 할 수 있다. 가비지 콜렉션의 대상이된다.이터러블이 아니다. 위크셋의 실제 용도는 주어진 객체가 셋안에 존재하는지 아닌지를 알아보는 것 뿐이라고 해도 과언이 아니다.","link":"/2019/08/02/Learning-JavaScript-chapter10/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 1. 첫 번째 애플리케이션","text":"이 포스팅은 시리즈는 러닝 자바스크립트 스터디를 하면서 개인적으로 정리의 필요성을 느끼고 정리를 위해 나만의 방법으로 정리해 놓은 포스팅입니다.저작권 문제가 발생시에 수정 될 수 있으며 해당 책없이는 의미가 없는 포스트 입니다. 책은 꼭 구매해서 봅시다. ^^ 자바스크립트의 간단한 역사 자바스크립트는 1995년 넷스케이프 커뮤니케이션즈의 개발자였던 브랜더 에이히가 개발했습니다. 자바스크립트의 원래 이름은 모카(mocha)였다. 1995년 출시된 넷스케이프 내비게이터에서 자바스크립트라는 이름을 공식적으로 사용하기 전까지 잠시 라이브 스크립트라는 이름으로 불렸다. 자바와 이름이 비슷한 이유는 마케팅 시도였다고 한다. 1996년 11월 넷스케이프는 ECMA에 자바스크립트를 제출, ECMAScript와 자바스크립트는 같은 것이라 생각해도 무방하다. ES6 : ECMAScript 6 즉 ES6는 2015년 6월에 발행 - ‘ES6 하모니’, ‘하모니’, ‘ES6’, ‘ES2015’, ‘ECMAScript 2015’는 모두 같은 말이다. 편집기를 사용해야 하는 이유 문법하이라이트 괄호 맞춤기능 코드 접기 자동완성 주석주석에는 한줄 주석와 여러 줄 주석이 있다. javascript12// //한줄주석/*내용*/ //여러줄주석:css와 동일한 형태를 하고 있다. 자바스크립트의 위치를 헤드에 넣을 수도 있지만, 그렇게 하면 성능이 다소 떨어지고 헤드가 지나치게 복잡해지므로 바디 마지막에 놓습니다. 웹브라우저가 HTML 문서를 해석 할때 태그를 만나면 그 안에 있는 JavaScript의 처리가 다 끝날때까지 다른 HTML의 해석을 멈추기 때문에 사용자 입장에서 HTML페이지가 화면에 다 그려지기까지 더 오래걸리게 됩니다.그래서 바디 마지막에 두는것을 권하고 있다.*참고링크 : 브라우저는 어떻게 동작하는가? 비동기적 이벤트사용자 입력은 비동기적이다. 비동기적 이벤트란 이벤트가 언제 일어날지 프로그래머가 전혀 알 수 없는 이벤트를 말한다.쉽게말해 사용자가 무엇을 입력할지 예측할 수 없다는 말이다. Hello, World!Hello, World! 애플리케이션은 1978년 브라이언 커니핸과 데니스 리치가 쓴책 “The C Programming Language”에서 시작되어 프로그래밍 언어 입문서에서는 “Hello World”를 출력하는 프로그램을 보여주는 것이 전통처럼 굳어졌다. 위에서 언급하지 않는 내용들은 중요도가 낮거나 다른 챕터에서 심화있게 다루는 내용들이어서 건너 뛰었다.","link":"/2019/06/19/Learning-JavaScript-chapter1/"},{"title":"Hexo 검색엔진 최적화(SEO) 시켜보기","text":"Hexo 블로그를 만들고 나서 이번에 적용해 보려고 하는 것은 검색엔진 최적화(SEO)였다.다행히 Hexo에는 SEO관련 플러그인들이 많이 있었다.그 중에 많이 쓰이고 해당 블로그에 적용한 플러드인들을 소개합니다. SEO SEO란?영어로 Search Engine Optimization 의 약자이며, 검색엔진 최적화 라는 의미를 가지고 있습니다.검색엔진에 맞게 사이트를 제작 및 운영하는 과정 전부를 뜻합니다. 플러그인 설치 및 설정 - hexo-auto-canonical메타 태그 중 canonical 속성을 대표 URL을 뜻합니다.각 포스트마다 자동으로 표준 링크를 만들어 줍니다. 설치 1npm install --save hexo-auto-canonical 설정HEAD에 위치 하도록 아래 내용을 추가해줍니다. ejs 의 경우 1 jade 의 경우 1| !{ autoCanonical(config, page) } - hexo-autonofollow해당 포스트에서 참고하고 있는 외부링크에 nofollw 속성을 자동으로 추가해줍니다. 설치 1npm install hexo-autonofollow --save 설정_config.yml 파일에 아래 내용을 추가합니다. 12345nofollow: enable: true exclude: - exclude_1.com - exclude_2.com - hexo-generator-seo-friendly-sitemap사이트 맵을 제출하면 크롤러가 효율적으로 크롤링을 할 수 있습니다.자동으로 sitemap.xml을 생성해 줍니다. 설치 1npm install hexo-generator-seo-friendly-sitemap --save 설정_config.yml 파일에 아래 내용을 추가합니다. 1234sitemap: path: sitemap.xml tag: false category: false path값을 지정한 root폴더에 sitemap.xml이 생성됩니다./sitemap.xml 경로에서 확인 할 수 있습니다. tag : sitemap에 tag 포함 여부를 결정합니다. category : sitemap에 category 포함 여부를 결정합니다. - hexo-generator-feed자동으로 Atom 1.0또는 RSS2.0 피드를 생성해 줍니다. 설치 1npm install hexo-generator-feed --save 설정_config.yml 파일에 아래 내용을 추가합니다. 1234feed: type: rss2 path: rss2.xml limit: 20 네이버에서 Atom을 지원하지 않기 때문에 RSS2로 설정해 줍니다. type : 피드의 종류 (atom/rss2) path : 피드가 생성될 경로 (Default: atom.xml/rss2.xml) limit : 최신 포스트의 개수 설정 (0 또는 false 입력 시 모든 포스트) - hexo-generator-robotstxt자동으로 robots.txt 파일을 생성해 줍니다. 설치 1npm install hexo-generator-robotstxt --save 설정_config.yml 파일에 아래 내용을 추가합니다. 12345robotstxt: useragent: \"*\" allow: - / sitemap: https://.github.io/sitemap.xml Deploy를 해주신 후에각 검색엔진에서 SEO설정을 해줍니다.","link":"/2019/06/11/Hexo-seo/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 11. 예외와 에러 처리","text":"견고하고 품질 좋은 소프트웨어를 만드는 첫 번째 단계는 에러가 일어날 수 있다는 사실을 받아들이는 것이다.두 번째 단계는 에러를 예상하고 타당한 방법으로 처리하는 것이다. 예외처리는 에러를 컨트롤 하는 매커니즘이다.에러처리라고 하지 않고 예외처리라고 하는 이유는 예상치 못한 상황에 대처하는 방식이기 때문이다. Error 객체자바스크립트에는 내장된 Error 객체가 있고 이 객체는 에러 처리에 간편하게 사용할 수 있다.Error 인스턴스를 만들면서 에러 메세지를 지정할 수 있다. 1const err = new Error(‘invalid email’); try/catch와 예외처리에러를 캐치하면 프로그램은 멈추지 않는다. 에러를 기록하고 계속 진행 할 수 있다.문제가 해결된것은 아니다. 최소한 앞뒤 사정을 모르고 그냥 멈추는 일은 막을 수 있다. 실행 흐름은 에러가 일어나는 즉시 catch 블록으로 이동try블록안에 쓸수 있는 문의 숫자에 제한은 없다.에러가 일어나지 않으면 catch블록은 실행 되지 않는다. 예외처리와 호출스택완료되지 않은 함수가 쌓이는 것을 호출스택이라고 부른다.에러는 캐치될때까지 호출스택을 따라 올라간다.에러는 호출스택 어디에서든 캐치 할수 있다. try … catch … finallyfinally블록은 에러가 일어나든 일어나지 않든 반드시 호출된다. 예외 처리하는 데에도 비용이 발생한다.프로그램을 일부러 멈추려 하는게 아니라며 예외를 일으켰으면 반드시 캐치해야 한다.예외처리는 예상 할수 없는 상화에 대비한 마지노선이다.예상 할수 있는 에러는 조건문으로 처리하는 것이 최선이다.","link":"/2019/08/03/Learning-JavaScript-chapter11/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 12. 이터레이터와 제너레이터","text":"이터레이터이터레이터는 ‘지금 어디있는지’ 파악할 수 있도록 돕는다는 면에서 일종의 책갈피와 비슷한 개념이다. 배열은 이터러블 객체의 좋은 예이다. 책에 여러 페이지가 있는 것처럼 배열에는 여러 요소가 들어 있으므로 책에 책갈피를 끼울수 있듯 배열에는 이터레이터를 사용 할 수 있다. next메서드는 더이상 진행 할것이 없으면 undefined가 되지만 next는 계속 호출 할 수 있습니다.물론 그렇다고 결과가 바뀌는건 아니다. 이터레이터는 모두 독립적입니다. 즉 새 이터레이터를 만들 때마다 처음에서 시작합니다.그리고 각각 다른 요소를 가리키는 이터레이터 여러 개를 동시에 사용할 수도 있습니다. 이터레이션 프로토콜이터레이터는 그 자체로 크게 쓸모가 있다기보다는 더 쓸모 있는 동작이 가능해지도록 한다는데 의미가 있다.이터레이터 프로토콜은 모든 객체를 이터러블 객체로 바꿀 수 있습니다. 1234567891011class Log { constructor(){ this.messages = []; } add(message){ this.messages.push({ message, timestamp: Date.now() }); } [Symbol.iterator](){ return.this.messages.valus(); }} 이터레이션 프로토콜은 클래스에 심볼 메서드 Symbol.iterator가 있고 이 메서드가 이터레이터처럼 동작하는 객체, 즉 value와 done프로퍼티가 있는 개체를 반환하는 next메서드를 가진 객체를 반환한다면 그 클래스의 인스턴스는 이터러블 객체라는 뜻입니다. 제너레이터제너레이터란 이터레이터를 사용해 자신의 실행을 제어하는 함수입니다. 일반적인 함수는 매개변수를 받고 값을 반환하지만 호출자는 매개변수 외에는 함수의 실행을 제어할 방법이 전혀 없습니다.함수를 호출하면 그 함수가 종료될 때까지 제어권을 완전히 넘기는 겁니다. 하지만 제너레이터에서는 그렇지 않다. 제너레이터의 도입된 새로운 개념 제너레이터는 언제든 호출자에게 제어권을 넘길 수 있습니다.제너레이터는 호출한 즉시 실행되지는 않습니다. 대신 이터레이터를 반환하고, 이터레이터의 next 메서드를 호출함에 따라 실행됩니다. 이 두가지 예외를 제외하면 일반적인 함수와 같습니다. 제너레이터를 만들때는 function키워드 뒤에 애스터리스크(*)를 붙입니다.제너레이터에서는 return 외에 yield 키워드를 쓸 수 있습니다. yield 표현식과 양방향통신통신은 yield 표현식을 통해 이뤄진다.표현식은 값으로 평가되고 yield는 표현식이므로 반드시 어떤 값으로 평가 됩니다.yield표현식의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수 입니다. 제너레이터를 시행했을 때 일어나는 일을 묘사한것 책 참고 제너레이터와 returnyield문은 설령 제너레이터의 마지만 문이더라도 제너레이터를 끝내지 않습니다.제너레이터에서 return문은 사용하면 그 위치와 관계없이 done은 true가 되고, value 프로퍼티는 return이 반환하는 값이 됩니다. 제너레이터에서 중요한 값을 return으로 반환하려 하지 마십시오.제너레이터가 반환하는 값을 사용하려 할 때는 yield를 써야 하고 return은 제너레이터를 중간에 종료하는 목적으로만 사용해야 합니다. 요약이터레이터는 배열이나 객체처럼 여러 가지 값을 제공할 수 잇는 컬렉션의 동작 방식을 표준화했습니다.이터레이터로 할 수 있는 일은 ES6 이전에도 모두 할 수 있었으므로 어떤 기능이 추가된 것은 아니다.중요하면서도 자주 사용하는 패턴을 표준화했다는데 의미가 있다. 제너레이터를 사용하면 함수를 훨씬 더 유연하고 효율적으로 사용 할 수 있다.제너레이터는 모든 연산을 지연시켰다가 필요할 때만 수행하게 만들 수 있다.","link":"/2019/08/03/Learning-JavaScript-chapter12/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 13. 함수와 추상적 사고","text":"서브루틴으로서의 함수서브루틴은 아주 오랜 된 개념이며 복잡한 코드를 간단하게 만드는 기초적인 수단입니다.서브루틴은 프로시저, 루틴, 서브프로그램, 매크로 등 다양한 이름으로 불립니다. 이들은 모두 매우 단순하고 범용적인 호출 할수 있는 한 단위를 일컫는 말이다. 함수로서의 함수순수함수 - 순수함수에서는 입력이 같으면 결과도 반드시 같다.순수함수에는 부수효과가 없어야 한다.함수도 객체다. 자바스크립트 함수는 Function 객체의 인스턴스이다. 변수로서의 함수 함수를 가리키는 변수를 만들어 별명을 정할 수 있다,배열에 함수를 넣을 수 있습니다. 물론 다른 타입의 데이터와 섞일 수 있습니다.함수를 객체의 프로퍼티로 사용할 수 있습니다.함수를 함수에 전달 할 수 잇습니다.함수가 함수를 반환 할 수 있습니다.함수를 매개변수로 받는 함수를 반환하는 것도 물론 가능합니다. 배열 안의 함수배열을 사용하면 작업 단계를 언제든 쉽게 바꿀 수 있다는 장점이 있다.어떤 작업을 빼야 한다면 배열에서 제거하기만 하면되고, 추가할 작업이 있다면 배열에 추가하기만 하면 된다. 함수의 함수 전달함수에 함수를 전달하는 다른 용도는 비동기적 프로그래밍입니다. 이런 용도로 전달하는 함수를 보통 콜백이라 부르며 약자로 cb를 쓸때가 많습니다. 콜백 함수는 자신을 감싼 함수가 실행을 마쳤을때 호출됩니다.함수에 함수를 전달하는 대표적인 사례가 콜백이긴 하지만 그게 전부는 아니다.함수는 동작이고, 함수를 받은 함수는 그 동작을 활용할 수 있다. 함수를 반환하는 함수매개변수 여러개를 받는 함수를 매개변수 하나만 받는 함수로 바꾸는 것을 커링 이라고 부른다.커링이라는 이름은 이 패턴을 만든 미국의 수학자 하스켈 커리의 이름을 딴것이다. 재귀재귀 역시 널리 쓰이며 함수를 활용하는 중요한 패턴입니다, 재귀란 자기 자신을 호출하는 함수 입니다.같은 일을 반복하면서 그 대상이 점차 줄어드는 상황에서 재귀를 유용하게 활용 할 수 있습니다.재귀 함수에는 종료조건이 있어야 합니다. 종료 조건이 없다면 자바스크립트 인터프리터에서 스택이 너무 깊다고 판단할 때까지 재귀 호출을 계속하다가 프로그램이 멈춥니다. 함수형프로그래밍어떤 방법이 ‘더 좋은’ 방법인가? 이 질문에 정확한 답은 없다. 여러가지 상황에 맞추어 사용하면된다.","link":"/2019/08/03/Learning-JavaScript-chapter13/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 16. Math","text":"Math 객체는 애플리케이션을 개발하면서 자주 사용하게 될 수학 함수를 담고 있습니다.(전문적인 숫자 분석이 필요하다면 별도의 라이브러리를 찾아야 한다.)자바스크립트의 숫자는 모두 IEEE 755 64비트 부동소수점 숫자이다. 숫자 형식자바스크립트는 다양한 숫자 형식을 지원하지는 못한다. 10진수 형식, 고정 소수점 형식, 지수 형식이 몇가지 있는 정도이다.숫자를 2진수, 8진수, 16진수로 나타낼 수도 있다. 자바스크립트의 숫자 형식 메서드는 모두 숫자가 아니라 문자열을 반환한다. 해당 형식에 필요한 각종 기호를 온전히 표현하려면 반드시 문자열이어야 하기 때문이다. 고정 소수점소수점 뒤 자리수를 지정하는 형식을 원한다면 toFixed()를 사용 1234const x = 19.51;x.toFixed(3) // \"19.510\"x.toFixed(2) // \"19.51\"x.toFixed(0) // \"20\" 숫자는 버림이 아니라 반올림으로 나타난다. 지수 표기법지수 표기법이 필요할 때는 toExponential()을 사용toFixed()와 마찬가지로 반올림한 결과가 출력. 매개변수로 넘긴 정밀도에 따라 소수점 쥐의 숫자가 몇 개 나타날지 정해진다. 고정 전체 자리수소수점이 어디 나타나는 관계없이 숫자 몇 개로 표현하느냐가 중요하다면 toPrecision()을 사용출력 결과는 반올림된 숫자이며 전체 자리수는 매개변수로 넘긴 자릿수와 일치 다른 진수2진수나 8진수, 16 진수 표현을 원한다면 toString()에 기수를 매개변수로 쓰면 된다. 고급 숫자 형식다양한 형식으로 숫자를 표시해야 한다면 한계에 부딪힌다. 수천자리의 아주 큰 숫자괄호를 쓰는 등, 음수 표현을 다르게 해야하는 경우공학 표기법milli-, micro-, kilo-, mega- 등의 SI 접두사가 필요한 경우 위와같은 경우 Numeral.js를 사용하는 것을 권한다. 상수Math 객체에는 몇 가지 중요한 상수가 프로퍼티로 내장돼 있다. 123456Math.E //자연로그의 밑수Math.PI //원주율Math.SQRT1_2 //1/2의 제곱근etc 대수 함수거듭제곱제곱 관련 기본 함수는 Math.pow이며 제곱근, 세제곱근,e의 거듭제곱 등 자주 쓰이는 연산에는 간편 함수가 있습니다. 로그 함수자연로그 함수는 Math.log 기타 함수의사 난수 생성자바스크립트에서 의사 난수를 생성할 때는 Math.random()을 사용합니다. 이 함수는 0이상 1 미만의 숫자를 반환합니다. 삼각함수, 쌍곡선함수","link":"/2019/08/17/Learning-JavaScript-chapter16/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 15. 날짜와 시간","text":"자바스크립트의 Date객체는 원래 넷스케이프 프로그래머 캔스미스가 만들었는데, 사실 자바의 java.util.Date을 가져온 것이다. 세계는 타임존으로 나뉘어 있습니다. 타임존은 모두 UTC(Coordinated Universal Time)를 기준으로 한 시차로 나뉩니다.UTC는 때때로 그리니치 표준시, 즉 GMT(Greenwich Mean Time)라고 불리기도 합니다. 자바스크립트에서 Date 인스턴스는 모두 유닉스 시간 원점으로 부터 몇 밀리초가 지났는지 나타내는 숫자입니다.자바스크립트는 보통 이 숫자를 사람이 읽기 편한 그리고리력 날짜로 변환합니다. 숫자형 표현이 필요하면 valueOf() 메서드를 쓰면됩니다. 123const d = new Date();console.lod(d); //타임존이 들어간 그레고리력 날짜console.log(d.valueOf()); //유닉스 타임스탬프 Date 객체 만들기Date 객체는 네 가지 방법으로 만들 수 있습니다. 매개변수 없이 호출하면 현재 날짜에 해당하는 Date 객체를 반환문자열을 제공하면 자바스크립트는 그 문자열을 해석해서 그에 맞는 날짜를 반환숫자를 넣으면 유닉스 타임스탬프로 해석타임스탬프로 입력하는 방법 Moment.jsMoment.js에는 타임존을 지원하는 버전과 지원하지 않는 버전 두 가지가 있습니다. CDN을 통한 사용 1 노드를 사용할 때는 npm install –save moment-timezone 명령으로 Moment.js를 설치하고 require 명령으로 스크립트를 불러올 수 있다. 1const moment = reqire('moment-timezone'); 날짜 형식Moment.js 의 format 메서드를 써서 날짜를 원하는 형식으로 만들 수 있습니다.자세한 사항은 Moment.js 온라인 문서를 참고 합시다. 날짜 구성 요소Date 인스턴스의 각 구성 요소에 접근 할 때는 다음 메서드를 사용합니다. 12345678910const d = new Date(Date.UTC(1815, 9 ,10));d.getFullYear()d.getMonth()d.getDate()d.getDay()d.getHours()d.getMinutes()d.getSeconds()d.getMilliseconds() 날짜 비교날짜 A와 날짜 B 중 너느쪽이 더 앞인가 하는 단순 날짜 비교는 자바스크립트에 내장된 비교 연산자를 통해 할 수 있다.Date 인스턴스는 날짜를 숫자로 저장 하므로, 숫자에 쓸 수 있는 비교 연산자를 그대로 쓰면 된다. 1234const d1 = new Date(1996, 2, 1);const d2 = new Date(2009, 4, 27);d1 > d2 // falsed1 < d2 // true 날짜 연산날짜는 숫자이므로 날짜에서 날짜를 빼면 몇 밀리초가 지났는지 알 수 있다. 1const msDiff = d2 -d1; 요약 자바스크립트의 날자는 1970년 1월 1일 UTC로부터 몇 밀리초가 지났는지 나타내는 숫자입니다.날짜를 생성할 때는 타임존이 유의 하여야 한다.날짜 형식을 자유롭게 바꿀 수 있어야 한다면 Moment.js를 사용하면 된다.","link":"/2019/08/16/Learning-JavaScript-chapter15/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 3. 리터널과 변수, 상수, 데이터 타입","text":"CHAPTER3 은 데이터에 관한 내용들이었는데, 많은 부분들이 개념정도만을 이야기하고 나머지는 뒤에서 자세하게 설명한다고 생략되어있는 부분들이 많았다.이번 포스팅에서도 간단하게 개념들만 정리하고 추후에 다시 언급하는 방법을 취하겠다. 변수와 상수 변수 : 언제든지 변할 수 있는 값 상수 : 한번 할당한 값을 바꿀 수는 없다. 변수 선언시 초기값을 할당하지 않으면 암묵적으로 undefined를 할당한다.let, const 키워드는 ES6에서 새로 생겼다.상수 이름에는 보통 대문자와 밑줄만을 사용하는데 절대적이지는 않다. 식별자 이름 반드시 글자나 달러기호, 밑줄로 시작해야 한다. (밑줄 한개 또는 두개로 시작하는 식별자는 특별한 상황또는 ‘내부’변수에서만 사용) 식별자에는 글자와 숫자, 달러기호, 밑줄만 쓸 수 있다. 유니코드 문자도 쓸 수 있다. 예약어는 사용 할 수 없다. 여러가지 식별자 표기법 카멜 표기법 (camelCase) : 각 단어의 첫문자를 대문자로 표기하고 붙여쓰되, 맨처음 문자는 소문자로 표기함 파스칼 표기법 (PascalCase) : 첫단어를 대문자로 시작하는 표기법 스네이크 표기법 (snake_case) : 단어를 밑줄문자로 구분하는 표기법 케밥 표기법 (kebab-case) : 하이픈으로 단어를 연결하는 표기법 헝가리안 표기법 (Hungrian Notation) : 변수 및 함수의 인자 이름 앞에 데이터 타입을 명시하는 코딩규칙 - 나무위키 리터널 값을 프로그램 안에서 직접 지정한다는 의미, 값을 만드는 방법 원시타입과 객체 숫자, 문자열, 불리언, null, undefined, 심볼(symbol) 원시타입은 불변 - 불변성이라는 말이 변수의 값이 바뀔 수 없다는 뜻은 아니다. 객체 - 여러가지 형태와 값을 가질 수 있다. 숫자 IEEE-764 배정도부동소수점 숫자 형식을 사용(더블) 자바스크립트에는 숫자형 데이터 타입이 하나이다. 문자열 유니코드 텍스트 - 이모티콘 까지 포함(유니코드를 사용하는 소프트웨어가 모든 코드포인트를 정확히 렌더링 한다고 보장하지는 않는다. ) 문자열 리터널에는 작은따옴표, 큰따옴표, 백틱을 사용한다. ``(백틱)은 ES6에서 도입 이스케이프 역슬래시(\\)를 사용 - 자기자신도 이스케이프 할 수 있다. 문자열 템플릿(문자열 채우기)값을 문자열 안에 써야 할때 사용 - ES5에서는 문자열병합을 통해 변수나 상수 를 문자열 안에 사용 백틱을 사용하여 변수나 상수를 문자열 안에 쓰는 방법, 문자열의 정해진 위치에 값을 채워 넣는 간편한 방법 문자열 템플릿 안에서는 달러기호가 특수문자가 된다. 달러기호 다음에 중괄호로 감싼 값을 쓰면 그 값이 문자열에 삽입된다. 심볼 심볼은 항상 유일하다. 고유한 식별자, 심볼은 모두 서로 다르다. null, undefined null은 프로그래머에게 허용된 데이터 타입 undefined 는 자바스크립트 자체에서 사용 (프로그래머가 사용 할 수는 있지만 지양) 객체 객체의 본질은 컨테이너 - 내용물이 바뀐 다고 컨테이너가 바뀌는 것은 아니다. 중괄호를 사용하는 리터널 문법이 있다. 객체의 콘텐츠는 프로퍼티 또는 멤버라고 부름 프로퍼티 이름에 유효한 식별자를 써야 멤버접근연산자(.)를 사용 할 수 있다. 유효하지 않다면 계산된 멤버접근연산자([])를 써야한다. -유효한 식별자여도 사용가능하다. 심볼프로퍼티에 접근할 때도 사용할수 있다. 객체에 함수를 담을 수도 있다. 배열 배열크기는 고정되지 않는다 - 언제든 요소를 추가하거나 제거할 수 있다. 요소의 타입을 가리지 않는다. 배열요소는 0으로 시작한다.(숫자가 아닌 키나 분수, 음수 등을 키로 쓸수 있지만 지양) 대괄호 안에 배열요소를 쉼표로 구분해서 쓴다. 요소 숫자를 반환하는 length프로터티가 있다. 요소에 접근할 때는 대괄호 안에 요소의 인덱스 숫자(Key)를 씀 값을 덮어 쓸때에는 새 할당 하면된다. 데이터타입 변환 숫자로 변환 : Number객체 생성자 - parseInt, pasrseFloat (parseInt- 기수를 지정 할 수 있음, parseFloat- 항상 기수가 10이라고 가정) Date객체를 숫자로 변환 : valuOf()메서드를 사용 - UTC 1970년1월 1일 자정으로부터 몇밀리초가 지났는지를 나타내는 숫자(타임스태프) 문자열로 변환 : toString()메서드를 사용, 문자열병합을 사용(숫자 + 문자열 = 문자열) 배열에서의 toString()메서드는 각 요소를 문자열로 바꾼다음 쉼표로 연결한 문자열을 반환한다.","link":"/2019/06/20/Learning-JavaScript-chapter3/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 2. 자바스크립트 개발 도구","text":"CHAPTER 2. 자바스크립트 개발 도구에서는 제목 그대로 개발도구들에 대해서 설명하고 세팅하는 방법에 대해서 나와있었다. 책에있는 개발도구들을 정리해보면 아래와 같다. Git : 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템 node.js : 확장성있는 네트워크 애플리케이션 개발에 사용되는 소프트웨어 플랫폼 npm(노드 패키지 매니저/Node Package Manage ) : 자바스트립트 프로그래밍 언어를 위한 패키지 관리자 gulp : 반복작업을 자동화하는 빌드도구의 하나 babel : ES6/ES7 코드를 ECMAScript5 코드로 트랜스파일링(transpiling) 하기 위한 도구 ESlint : ES + Lint입니다. ES는 EcmaScript, 즉 자바스크립트를 의미. Lint는 보푸라기라는 뜻인데 프로그래밍 쪽에서는 에러가 있는 코드에 표시를 달아놓는 것을 의미. 자바스크립트 소스 코드가 코딩 규칭을 준수하는지 확인하기 위해 소프트웨어 개발에 사용되는 정적코드분석 도구 Git Git의 관련 내용은 이전에 정리한 포스팅으로 대체한다.Git의 기본적인 명령어 빌드도구: 걸프(gulp)와 그런트(grunt) 이 책에서는 그런트에 대한 설명은 없고 걸프만을 사용한다. 반복 작업을 자동화해주는 빌드 도구들이다. 먼저 걸프를 전역으로 설치합니다. bash1npm install -g gulp *걸프의 전역설치는 개발에 사용할 컴퓨터에서 한 번만 하면된다. 프로젝트 루트에서 아래명령어를 통해 사용한다. bash1npm install --save-dev gulp --save-dev 명령어는 최종 사용자에게는 필요없는 dev 버전임을 뜻한다.걸프는 최종 사용자에게는 필요없지만, 개발 과정에서 도움이 되는 개발 의존성에 속합니다. 설치가 완료되면 프로젝트 루트에 gulpfile.js를 만듭니다. gulpfile.js123456const gulp = require('gulp');//걸프 의존성을 작성합니다.gulp.task('default', function() { //걸프 작업을 작성합니다.}); gulp를 실행하면 정상적으로 작동해야 하는데 아래와 같이 정상적으로 실행되지 않는다. 12345$ gulp[17:03:41] Using gulpfile c:\\LearningJS\\gulpfile.js[17:03:41] Starting 'default'...[17:03:41] The following tasks did not complete: default[17:03:41] Did you forget to signal async completion? 원인을 찾아보니 책출판 당시와 지금의 걸프버전이 바뀌면서 변화가 있었다고 한다. 이 부분은 바벨과 같이 엮어서 다시 살펴보기로 한다.일단 실행을 된다. 트랜스컴파일러 - 바벨(babel)바벨을 ES5를 ES6로 바꾸는 트랜스컴파일러로 시작했고, 프로젝트가 성장하면서 ES6와 리액트, ES7등 여러 가지를 지원하는 범용 트랜스 컴파일러가 됐다.바벨 버전6부터는 ES5를 ES6로 변환하려면 ES6변환 프리셋을 설치하고 바벨이 해당 프리셋을 사용하게끔 설정을 해야 한다. ES6 프리셋 설치는 아래와 같다. bash1npm install --save-dev babel-preset-es2015 실행하면 중간에 경고 문구가 하나 뜬다. 1npm WARN deprecated babel-preset-es2015@6.24.1: 🙌 Thanks for using Babel: we recommend using babel-preset-env now: please read https://babeljs.io/env to update! babel-preset-env로 업데이트가 되었으니 업데이트를 사용하는 것을 권하는 멘트이다.babel-preset-es2015대신 babel-preset-env를 설치하여준다. @babel/core도 같이 설치 해줘야 정상적으로 실행이 된다. bash1npm install --save-dev gulp-babel @babel/core @babel/preset-env 프리셋 설치 후에 프로젝트 루트에 .babelrc 파일을 만들고 파일 내용을 작성해 줍니다. .babelrc123{ \"presets\": [\"es2015\"] } #위와 같이 작성하는 프리셋내용도 아래와 같이 변경이 필요하다.{ \"presets\": [\"@babel/preset-env\"] } 파일 내용도 프리셋 버전에 맞춰서 새롭게 바꿔서 작성하여 준다. 바벨을 걸프와 함께 사용하기 책의 내용대로 gulpfile.js를 작성하려다 간편하게 바꿔서 작성하였다. gulpfile.js12345678910const gulp = require('gulp');const babel = require('gulp-babel');gulp.task('default', function(){ gulp.src(\"public/es6/**/*.js\") .pipe(babel()) .pipe(gulp.dest(\"public/es5\"));}); 그리고 책의 예제대로 ES6샘플파일을 만들고 걸프 명령어를 실행해주면 오류가 난다. ㅎㅎㅎ;;;;위에서 언급한대로 걸프의 버전이 달라져서 변화가 있었다.이리저리 해매이다가 구글링으로 해결 방법을 찾았다.해결방법원문 여러가지 해결책중에서 가장 간단하다는 콜백함수를 추가하는 방법을 사용하여 문제를 해결하였다. gulpfile.js1234567891011const gulp = require('gulp');const babel = require('gulp-babel');gulp.task('default', function(done){ gulp.src(\"public/es6/**/*.js\") .pipe(babel()) .pipe(gulp.dest(\"public/es5\")); done();}); 콜백함수에 done을 추가하고 함수 끝 부분에서 실행해 줍니다. 린트(ESlint)ESlint는 책에서 소개한 예제대로 정상작동하였다. 하나라도 그냥 넘어가서 다행이었다 ㅎㅎㅎ;; ESlint 설치1npm install -g eslint 프로젝트 루트에서 eslint --init명령을 실행해주면 질문들이 나오는데 모든 질문에 답하면.eslintrc파일이 생성됩니다. 린트 설정에 관련해서는 나중에 따로 포스팅하면 좋을것 같다. 걸프와 같이 eslint를 실행하기 위해 다음 명령을 실행합니다. bash1npm install --save-dev gulp-eslint gulpfile.js파일을 책의 예제대로 수정하고 gulp를 실행하면 정상 작동합니다.","link":"/2019/06/19/Learning-JavaScript-chapter2/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 4. 제어문","text":"이번챕터에서는 제어문에 대해서 나와 있었다. 제어문은 크게 조건문과 반복문으로 나눌 수 있다.대표적으로 조건문에는 if…else 문,switch 문이 있고 반복문에는 for 문, while 문 등이 있다.제어문을 시각적으로 나타내는 방법에는 순서도가 있다. 순서도 순서도에서 마름모 모양은 예/아니오 인 결정이며 사각형은 행동입니다. 시작과 끝은 원으로 나타냅니다. 순서도를 프로그램으로 바꿀 때 중요한 것은 컴퓨터가 이해 할수 있는 말로 변환하는 것이다. 블록문 제어문과 함께 쓰인다. 복합문(Compound Statement) 이라고도 함 문 여러개를 중괄호로 묶은것을 말한다. 한 줄 일때에는 블록문과 같이 사용하지 않아도 된다. 공백 자바스크립트는 줄바꿈 문자를 포함해, 추가 공백을 신경쓰지 않는다. 들여쓰기는 항상 의미가 명확히 드러나도록 써야 한다. 조건문if…else 문if…else 문은 주어진 조건식의 평가 결과, 즉 논리적 참,거짓에 따라 실행할 코드 블록을 결정하여 if 문 혹은 else 문을 실행합니다.만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제변환 되어서 논리적 참,거짓을 구별합니다. if...else 문의 문법12345if(조건식){ // 조건식이 참이면 이 코드 블록을 실행합니다.}else { // 조건식이 거짓이면 이 코드 블록을 실행합니다.} 조건식을 추가 하고 싶으면 else if 문을 사용한다.else if문과 else문은 옵션으로 사용 할 수도 있고 사용하지 않을 수도 있다.if 문과 else문은 1번씩만 사용이 가능하고 else if문은 여러 번 사용이 가능하다. switch 문if 문은 두 가지 중 하나를 선택하지만 switch 문은 조건 하나로 여러가지 중 하나를 선택 할 수 있다.다양하게 나뉘는 조건을 표현 할때 사용 switch 문의 문법1234567891011121314switch(표현식){ case value1: // 표현식을 평가한 결과가 value1 일때 실행 [break;] case value2: // 표현식을 평가한 결과가 value2 일때 실행 [break;] case valueN: // 표현식을 평가한 결과가 valueN 일때 실행 [break;] default: // 표현식을 평가한 결과가 없을때 실행 [break;]} default 절은 일치하는 case 절이 없을 때 실행 필수는 아니지만, 보통 맨 마지막에 사용 break문이 없어도 되지만 사용하는 습관이 중요한다. switch 문을 함수 안에서 사용 할때는 return 문을 break 문 대신해서 사용 할 수 있다. 제어문의 예외 break - 루프 중간에 빠져 나갑니다. continue - 루프에서 다음 단계로 바로 건너뜁니다. return - 제어문을 무시 하고 현재 함수를 즉시 빠져나갑니다. throw - 예외 핸들러에서 반드시 처리해야 할 예외를 일으킵니다. 예외 핸들러는 현재 제어문 바깥에 있어도 상관없습니다. 반복문while 문조건을 만족하는 동안 코드를 계속 반복한다. while 문의 문법123while(조건식){ //조건식이 참이면 실행} do…while문최소 한번은 실행 하려 할 때 사용합니다. do...while 문의 문법123do{ //실행문}while(조건문) for 문while문,do...while문은 모두 for 문으로 고쳐 쓸 수 있습니다. 어떤일을 정해진 숫자만큼 반복할거나 특히 그 일을 지금 몇번째 하는지 알아야 할때 사용합니다. for 문의 문법123for( 초기화식; 조건식; 증감식){ //조건식이 참인경우 실행문이 반복된다.} for 문의 다른 패턴 쉼표 연산자를 쓰면 초기화와 마지막 표현식에 여러가지 문을 결합 할 수 있다, 보통 정수 인덱스를 늘이거나 줄이면서 반복하지만 꼭 그래야 하는 건 아니다. 어떤 표현식이든 쓸수 있다.(문자열, 정수가 아닌 수, 객체 프로퍼티) 장점 제어부가 첫번째 행에 모여 있어서 일목요연하게 파악 할 수 있다. 초기화한 변수가 for문 안에서만 유효하다.(호이스팅) for..in 문for…in 문은 객체의 프로퍼티에 루프를 실행 하도록 설계된 반복문이다. for...in 문의 문법123for(variable in object){ //실행문 } for…in 문 주의사항객체 리터럴에 쓴 순서대로 열거되지 않는다.(순서가 보장되지 않는다.)열거 할 수 없는 프로퍼티가 존재한다.(객체의 모든 내장 메서드를 비롯해 각종 내장 프로퍼티 같은 비열거형 속성은 반복되지 않는다. 예:length)프로토타입에서 상속한 프로터티도 나열한다.hasOwnProperty 관련 참고링크 for…of 문ES6에서 새로 생긴 반복문, 컬렉션의 요소에 루프를 실행하는 다른 방법 for...of 문의 문법123for(variable of object){ //실행문 } 배열은 물론 이터러블 객체(member를 하나씩 차례로 반환 가능한 object)에 모두 사용 할 수 있는 범용적인 루프루프를 실행해야 하지만 각 요소의 인데스를 알 필요는 없을 때이터러블 관련 참고링크 메타문법 다른 문법을 설명하는 문법","link":"/2019/06/27/Learning-JavaScript-chapter4/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 7. 스코프","text":"스코프는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정합니다. 변수가 존재하지 않으면 그 변수는 스코프안에 ‘있지않음’을 직관적으로 알수 있다.즉 아직 선언하지 않은 변수나 함수가 종료되면서 존재하지 않게 된 변수는 분명 스코프안에 ‘있지 않다’ 스코프와 존재를 구별해야 한다.가시성이라고도 불리는 스코프는 프로그램의 현재 실행 중인 부분, 즉 실행 컨텍스트에서 현재 보이고 접근 할 수 있는 식별자들을 말한다. 반면 존재한다는 말은 식별자가 메모리에 할당된 무언가를 가리키고 있다는 뜻이다. 정적스코프와 동적스코프자바스크립트의 스코프는 정적이다. 소스코드만 봐도 변수가 스코프에 있는지 판단 할 수 있다.다만 소스코드만 봐도 즉시 스코프를 분명히 알 수 있다는 뜻은 아니다. 정적스코프어떤 변수가 함수 스코프 안에 잇는지 함수를 정의 할 때 알 수 있다는 뜻 이다. 호출할 때 알 수 있는 것은 아니다.자신이 정의 될 때 접근 할 수 있었던 식별자에는 여전히 접근 할 수 있지만, 호출 할 때 스코프에 있는 식별자에는 접근 할 수 없다. 전역스코프전역스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있다.전역스코프에서 선언된 것들을 전역변수(global)라고 합니다.전역스코프에 의존하는 것은 피해야한다. 블록스코프let 과 const 는 식별자를 블록스코프에서 선언합니다.블록스코프는 블록(문을 중괄호로 묶은것)의 스코프에서만 보이는 식별자를 의미한다. 변수 숨기기123456789101112{ // 외부블록 let x = 'blue'; console.log(x); // \"blue\" { // 내부블록 let x = 3; console.log(x) // \"3\" } console.log(x); // \"blue\"}console.log(typeof x); // \"undefined\"; x는 스코프에 있지 않습니다. 내부블럭의 x는 외부 블록에서 정의한 x와 이름만 같을 뿐 다른 변수이므로 외부 스코프의 x를 숨기는 효과가 있다.실행 흐름이 내부 블록에 들어가 새 변수 x를 정의 하는 순간 두 변수는 모두 스코프안에 있다.(외부 변수가 숨겨짐)변수의 이름이 같으므로 외부 스코프에 있는 변수에 접근할 방법이 없다. 스코프 체인스코프가 계속 연결됨(중첩), 스코프안에 스코프가 있는 형태내부 함수에서는 외부 함수의 변수에 접근이 가능하지만 외부 함수에서는 내부 함수의 변수에 접근 할수 없다.모든 함수들은 전역 객체에 접근 할 수 있다. 함수, 클로저, 정적스코프클로저는 함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의 하는 경우, 스코프를 함수 주변으로 좁히는 것을 말한다. 12345678let globalFunc; // 정의 되지 않는 전역 함수{ let blockVar = \"a\" // 블록 스코프에 있는 변수 globalFunc = function(){ console.log(blockVar); }}globalFunc(); // \"a\" globalFunc는 블록 안에서 값을 할당받았습니다. 이 블록 스크로와 그 부모인 전역 스코프가 클로저를 형성합니다.globalFunc를 어디서 호출하든 이 함수는 클로저에 들어있는 식별자에 접근 할수 있다.globalFunc을 호출하면, 이 함수는 스코프에서 빠져나왔음에도 불구하고 blockVar에 접근 할 수 있습니다. 즉시실행함수IIFE(즉시실행함수)는 함수를 선언하고 즉시 실행합니다. 123(function(){ // 즉시실행함수 바디})(); IIFE의 장점은 내부에 있는 것들이 모두 자신만의 스코프를 가지지만 IIFE 자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있는 것이다. 내부 변수는 IIFE안에 안전하게 보관되어 있으므로 손댈 방법이 없다.ES6에서 블록스코프 변수를 도입하면서 IIFE가 필요한 경우가 줄긴 했지만 여전히 널리 쓰인다.클로저를 만들고 클로저에서 무언가 반환 받을 때에는 유용하게 쓸 수 있다. 함수스코프와 호이스팅var로 선언된 변수들은 함수스코프라 불리는 스코프를 가진다.var로 선언한 전역 변수는 명시적인 함수 안에 있지 않지만 함수 스코프와 똑같이 동작한다. let으로 변수를 선언하면, 그 변수는 선언하지 전에는 존재하지 않습니다.var로 선언한 변수는 현재 스코프 안이라면 어디서든 사용 할 수 있으며, 심지어 선언하기도 전에 사용할 수 있습니다. 12345let var1;let var2 = undefined;var1; // undefined;var2; // undefinde;undefinedVar; // ReferenceError:undefinedVar is not defined let을 쓰면 변수를 선언하기 전에 사용하려 할때 에러가 일어 납니다.반면 var로 변수를 선언하면 선언하기도 전에 사용 할 수 있습니다. 호이스팅var로 선언한 변수는 호이스팅이라는 메커니즘을 따릅니다.자바스크립트는 함수나 전역스코프 전체를 살펴보고 var로 선언한 변수를 맨 위로 끌어올립니다.(여기서 중요한 것은 선언만 끌어올려진다는 것이며, 할당을 끌어 올려지지 않는다는 것이다.) 12345678910111213141516// 원래코드var x = 3;if(x ===3){ var x = 2; console.log(x);} console.log(x);// 자바스크립트가 해석한 코드var x;x = 3;if(x === 3){ x = 2; console.log(x);}console.log(x); 위의 예제를 보면 같은 함수나 전역스코프 안에서는 var로 새 변수를 만들수 없으며 let으로 가능 했던 변수숨김도 불가능하다.(블록 안에서 두번째 var문을 썻지만 변수x는 하나뿐이다.) 함수 호이스팅함수 선언도 스코프 맨 위로 끌어올려집니다.따라서 함수를 언언하기 전에 호출 할 수 있습니다. 1234f(); // 'f'function f(){ console.log('f');} 단, 변수에 할당한 함수 표현식은 끌어올려지지 않습니다. 이들은 변수의 스코프 규칙을 그래도 따릅니다. 1234f(); // ReferrenceError: f 는 정의되지 않았습니다.let f = function(){ console.log('f');} 사각지대스코프안에서 변수의 사각지대는 변수가 선언되기 전의 코드입니다. ES6 이전에 주의 해야한다. 스트릭트 모드스트릭트 모드에서는 암시적 전역 변수를 허용하지 않습니다.스트릭트 모드를 사용하려면 문자열 “use strict”(작은 따옴표도 가능) 하나만으로 이루언진 행을 코드 맨 앞에 쓰면 됩니다.전역스코프에서 사용하면 스크립트 전체가 스트릭트 모드로 실행되고, 함수 안에서 사용하면 해당 함수만 스트릭트 모드로 실행됩니다.","link":"/2019/07/12/Learning-JavaScript-chapter7/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 9. 객체와 객체지향 프로그래밍","text":"객체배열과 마찬가지로 자바스크립트 객체 역시 컨테이너지만, 크게 보면 다음 두 가지 측면에서 배열과 다릅니다.배열은 값을 가지며 각 값에는 숫자형 인덱스가 있습니다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있습니다.배열에는 순서가 있습니다. 즉 arr[0] 는 항상 arr[1]보다 앞에 있습니다. 반면 객체에는 그런 순서가 보장 되지 않습니다.obj.a가 obj.b보다 앞에 있다고 말할 수는 없습니다. 프로퍼티는 키(문자열 또는 심볼)과 값으로 구성됩니다. 객체의 특징은 키를 통해 프로퍼티에 접근할 수 있다는 점입니다. 프로퍼티나열프로퍼티 나열에서 기억해야 할 것은 순서가 보장되지 않는다는 점입니다.객체프로퍼티에는 순서가 없습니다. Object.keysObject.keys는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환한다. 123const SYM = Symbol();const o = { a:1, b:2, c:3, [SYM]:4; }Object.keys(o).forEach(prop => console.log(`${prop}: ${o{prop}}`)); 객체의 프로퍼티 키를 배열로 가져와야 할때는 object.keys가 편리합니다. 객체지향 프로그래밍객체지향 프로그래밍(OOP)은 컴퓨터 과학에서 전통적인 패러다임입니다.OOP의 개념중 일부는 1950년대부터 있었지만 , 시뮬러 67과 스몰토크가 등장하면서 OOP의 형태가 갖춰지기 시작했습니다.OOP의 기본아이디어는 단순하고 직관적이다. 객체는 데이터와 기능을 논리적으로 묶어 놓은겁니다.OOP는 우리가 사물을 이해하는 자연스러운 방식을 반영하도록 설계됐습니다. 또한 OOP는 사물에 관해 추상적으로, 구체적으로 생각할 수 있게 합니다. 클래스는 어떤자동차 처럼 추상적이고 범용적인 것인스턴스는 특정자동차 처럼 구체적이고 한정적인 것메서드는 기능클래스 메서드는 클래스에 속하지만 특정 인스턴스에 묶이지는 않는 기능oop는 클래스를 계층적으로 분류하는 수단도 제공합니다. 클래스와 인스턴스 생성클래스 문법123456789class Car { let = a constructor(b){ this.a = b }}let c = new Car(3); console.log(c.a) 클래스를 만들때 사용한 this 키워드는 나중에 만들 인스턴스의 플레이스 홀더입니다.메서드를 호출하는 시점에서 this가 무엇인지 알 수 있게 됩니다. 클래스는 함수다class 키워드를 도입하기 전까지 클래스를 만든다는 것은 곧 클래스 생성자로 사용할 함수를 만든다는 의미였다.class 문법이 훨씬 더 직관적이고 단순하긴 하지만, 사실 class 는 단축 문법일 뿐이며 자바스크립트의 클래스 자체가 바뀐것은 아니다.따라서 클래스 자체를 이해하는 것이 중요하다.클래스는 사실 함수일 뿐이다. 12function Es5Car {}class Es6Car {} 클래스가 바뀐것이 아니라 간편한 새 문법이 생겼을 뿐이다. 프로토타입클래스의 인스턴스에서 사용할 수 있는 메서드라고 하면 그건 프로토타입 메서드를 말하는 것이다. 최근에는 프로토타입 메서드를 #으로 표시하는 표기법이 널리 쓰입니다.Car.prototype.shift 를 Car#shift 로 표기한다. 모든 함수에는 prototype이라는 특별한 프로퍼티가 있다.일반적인 함수에서는 프로토타입을 사용할 일이 없지만객체 생성자로 동작하는 함수에서는 프로토타입이 대단히 중요하다.함수의 prototype 프로퍼티가 중요해지는 시점은 new 키워드로 새 인스턴스를 만들었을 때이다new키워드로 만든 새 객체는 생성자의 prototype프로퍼티에 접근할 수 있습니다.객체 인스턴스는 생성자의 prototype프로퍼티를 __proto__프로퍼티에 저장합니다. 프로토타입에서 중요한 것은 동적 디스패치하는 매커니즘입니다.여기서 디스패치는 메서드호출과 같은의미입니다.객체의 프로퍼티나 메서드에 접근하려 할 때 그런 프로퍼티나 메서드가 존재하지 않으면자바스크립트는 객체의 프로토타입에서 해당 프로퍼티나 메서드를 찾습니다. 클래스의 인스턴스는 모두 같은 프로토타입을 공유하므로 프로토타입에 프로퍼티나 메서드가 있다면해당 클래스의 인스턴스는 모두 그 프로퍼티나 메서드에 접근 할 수 있습니다. 인스턴스에서 메서드나 프로퍼티를 정의하면 프로토타입에 있는 것을 가리는 효과가 있습니다.자바스크립트는 먼저 인스턴스를 체크하고 거기에 없으면 프로토타입을 체크하기 때문이다. 정적메서드특정인스턴스에 적용되지 않는다.정적메서드에서 this는 인스턴스가 아니라 클래스자체에 묶인다.일반적으로 정적 메서드에는 this대신 클래스 이름을 사용하는 것이 좋은습관이다.정적메서드는 클래스에 관련되지만 인스턴스와는 관련이 없는 범용적인 작업에 사용된다. 상속클래스의 인스턴스는 클래스의 기능을 모두 상속한다. 상속은 한 단계로 끝나지 않는다.객체의 프로토타입에서 메서드를 찾지 못하면 자바스크립트는 프로토타입의 프로토타입을 검색한다.조건에 맞는 프로토타입을 찾을 때까지 프로토타입 체인을 거슬러 올라갑니다.조건에 맞는 프로토타입을 찾지 못하면 에러를 일으킨다. extends키워드는 Car를 Vehicle의 서브클래스로 만듭니다. 12345class Car extends Vehicle { constructor(){ super(); }} super() 는 슈퍼클래스의 생성자를 호출하는 함수이다.서브클래스에서는 이 함수를 반드시 호출해야 한다. 호출하지 않으면 에러가 난다. 상속은 단방향이다. 다형성디형성이란? 객체지향 언어에서 여러 슈퍼클래스의 멤버인 인스턴스를 가리키는 말이다. 자바스크립트는 믹스인 방법을 사용한다.","link":"/2019/08/02/Learning-JavaScript-chapter9/"},{"title":"타입스크립트 - 고급타입","text":"유니언 타입유니언 타입은 타입스크립트 1.4에 추가된 특징입니다. 유니언타입은 2개 이상의 타입을 하나의 타입으로 정의한 타입입니다.유니언 타입을 선언 할 때는 파이프(|)를 타입명 사이에 넣습니다. 타입A | 타입B | 타입C … 유니언 타입으로 선언된 변수는 나열된 타입 중 하나의 타입에 속한 값만 할당 받습니다. 타입 가드유니언 타입은 여러 타입을 받을 수 있다는 장점이 있습니다. 그런데 유니언 타입은 여러 타입을 받음으로써 타입을 활신할 수 없다는 문제가 있다.매개변수가 유니언 타입일 때 안전한 값을 할당하려면 타입 검사를 거쳐 매개변수 값을 답아야 한다.유니언 타입에 대한 타입 검사를 통해 타입 안전성을 주는 방법을 ‘타입가드(type guards)’라고 합니다. 타입 가드는 유니언 타입으로 지정된 변수에 대해 typeof나 insranceof 연산자를 활용해 타입 질의를 한 후 명시된 타입과 일치하는지 검사 합니다. typeof를 이용한 타입 검사123if (typeof x === 'string') { return x.indexOf(y);} 클래스도 유니언 타입 형태로 지정할 수 있습니다. 클래스에 대한 타입을 확신할 수 있으려면 instanceof 연산자를 통해 같은 클래스인지 확인 해야합니다. instanceof를 이용한 타입 검사1234if (x instanceof Dog) { console.log(x.name); console.log(x.leg);} 조건 검사가 이뤄지지 않은 영역에서는 오류가 발생합니다. 문자열 리터럴 타입문자열 리터럴 타입은 타입에 정의한 문자열만 할당받을 수 있게 하는 타입입니다. 사용자 정의 타입이므로 사용자가 정의해 사용합니다.타입 에일리어스를 이용하면 좀 더 일관성 있게 타입을 관리 할 수 있습니다. type 키워드를 이용해 ‘keyup’만 할당받을 수 있는 문자열 리터럴 타입인 EventType은 다음과 같은 형태로 선언합니다. 12345678// 문자열 리터럴 타입let event: 'keyup' = 'keyup';// 타입 에일리어스type EventType = 'keyup'// 유니언 타입과 결합type EventType = 'keyup' | 'mouseover'; 유니언 타입과 결합해 사용하면 허용할 문자열을 여러 개 지정할 수 있습니다. 룩업 타입룩업(lookup)타입은 타입스크립트 2.1에 추가된 타입입니다. 룩업 타입은 인덱스 접근타입으로 불리는데, keyof를 통해 타입T의 하위 타입을 생성해 내기 때문입니다.여기서 타입T는 여러 타입으로 이뤄진 유니언이나 인터페이스 타입을 가리킵니다. 1let testUnion: 'name' | 'gennder' | 'age' = 'name'; 유니언 타입을 다음과 같이 인터페이스 구조로 바꿀 수 있습니다. 12345interface Profile { name: String; gender: String; age: number;} 이 인터페이스를 keyof를 이용해 룩업 타입으로 선언하면 다음과 같습니다. 룩업타입1type Profile1 = keyof Profile; non-nullable 타입타입스크립트 2.0에 추가된 특징으로 non-nullable 타입은 컴파일러가 null이나 undefined를 엄격하게 제한합니다. 타입스크립트 2.0 전에는 null이나 undefined를 모든 타입의 변수에 할당할 수 있었으나 null이나 undefined를 할당하면 타입이 명확하지 않아서타입스크립트 2.0에서 strictNullChecks 라는 옵션이 추가되었습니다. strictNullChecks 옵션을 true 로 설정하면 특정 타입으로 선언된 변수에 null과 undefined 가 할당되지 않아 타입 사용이 명확해집니다. strictNullChecks 가 true일 때 null이나 undefined를 할당하려면 유니언타입으로 만들면 됩니다. 네버타입타입스크립트 2.0에 내장 타입으로 네버(naver)이 추가 됐습니다. 네버는 모든 타입의 하위 타입으로 사용할 수 있지만, any 타입을 never 타입에 할당 할 수는 없습니다. 함수에 닿을 수 없는 코드 영역이 있어 반환값이 존재하지 않을 때 함수에 Throw 객체가 반환돼 오류가 발생할 때 닿을 수 없는 코드함수를 실행하다 보면 ‘닿을 수 없는 코드(unreachable code)’가 발생할 때가 있습니다. 한 예로는 무한루프가 있습니다.닿을 수 없는 코드가 포함된 함수를 변수에 할당하려면 할당 받을 변수도 never 타입이 돼야 합니다.닿을 수 없는 코드를 없애려면 조건 검사에서 예외 상황이 없게끔 수정하면 됩니다. 예외 객체가 반활될 때오류를 발생시키려면 throw new Error(…)구문을 사용합니다. 오류 객체를 생성하고 던지면 함수가 반환값을 줄 수 없으므로 네버 타입이 됩니다. this 타입this 타입은 인터페이스와 클래스의 하위 타입이면서 이들을 참조할 수도 있는 타입입니다. this 타입은 this 키워드를 이용해 선언합니다.this 타입은 다형적 this 타입(polymorphic this type)이라고도 하는데, 선언 위치에 따라 참조하는 대상이 달라지기 때문입니다.클래스 멤버 변수나 생성자에서 this 타입을 사용하면 가장 가까운 클래스의 인스턴스를 참조합니다. 인터페이스 멤버에 this 타입을 사용하면 this 타입은 인터페이스를 참조합니다. 1234interface ListItem { getHead(): this; getTail(): this;} 각 인터페이스의 멤버는 인터페이스 자신을 참조합니다. 인터페이스는 구현 클래스의 객체를 통해 getHead() 라고 호출하면 자신을 호출하므로 재귀 타입이 됩니다. 이처럼 자기 자신을 반환하는 인스턴스 메서드를 활용해 체이닝 형태로 사용하면 마치 데이터가 흐르는 듯이 표현할 수 있는데 이러한 패턴을 프루언트 인터페이스패턴이라 하고 줄여서 플루언트 패턴이라고 합니다.플루언트 패턴을 구현할 때는 매세드가 인스터스 자신을 가리키는 this 타입을 반환하게 합니다.","link":"/2020/05/20/TypeScript-Advancedtype/"},{"title":"타입스크립트 - 타입 선언과 변경, 타입호환","text":"타입 에일리어스(type alias)타입 에일이어스는 타입스크립트 1.4 버전부터 지원된 특징입니다. 타입 에일리어스를 이용하면 기존 타입에 새로운 이름을 지을 수 있습니다. [형식]type = 타입; 바인딩 식별자(binding identifier)는 타입의 별칭에 해당하는 타입 에일라어스입니다.타입에 새로운 별칭을 만드는 과정을 줄여서 에일리어싱(aliasing)이라고 합니다. 1type myId = string; 타입 에일리어스는 단일 타입보다는 유니언 타입이나 리터럴 타입과 같은 다소 복작한 형태의 타입에 적용하면 좋습니다. 1type myAlias = string | undefined; 타입 추론타입스크립트에서는 값을 할당할 때 타입을 명시하지 않으면 타입 추론(type inference)을 통해 타입이 결정됩니다.values는 Object 타입이며, 내부 요소는 타입이 다르더라고 서로간에 할당할 수 있습니다. 1values[0] = values[1] 그런데 변수의 경우 각 변수에 처음 갑싱 할당되는 시점에 타입이 정해지므로 초기화가 이뤄진 다음에는 다른 타입의 값을 할당할 수 없습니다. 타입 캐스팅과 변환타입 캐스팅(type casting)은 명시적으로 선언한 캐스팅 코드에 의한 타입 변경을 의미하며, JS 인터프리터에 의해 타입이 바뀌는 타입 변환(type conversion)과 구분됩니다.타입 캐스팅의 예로, null 이나 undefined를 제외한 인수 값은 기본 래퍼 객체을 이용해 캐스팅 할 수 있습니다. 기본 래퍼 객체1234stringNumberBooleanSymbol 타입을 변경할 때 기본 래퍼 객체 외에도 +연산자를 이용할 수 있습니다. parseInt 함수가 Number 함수와 다른 점이 있다면 parseInt는 함수 이름 처럼 파싱 기능이 있어 숫자 외에 여러 문자가 섞여 있을 때 숫자만을 골라서 숫자 타입으로 변경할 수 있다는 점입니다. 123parseInt('50px'); // 50parseInt('1010', 2); // 2진수를 인식해 10진수로 바꿔 10Number('50px'); // NaN을 반환 타입 어설션타입 어설션(type assertion)을 이용하면 타입스크립트 컴파일러가 타입 어설션 정보를 이용해 컴파일을 수행합니다. 따라서 타입 어설션은 컴파일 과정까지만 유효하고 컴파일 후에는 사라집니다.타입 어셜션의 선언 방식은 크게 꺽쇠 괄호 방식과 as 문법이 있습니다. 12let num1: number = myNum;let num2: number = myNum as number; 타입 어설션에 사용되는 꺽쇠 기호가 포함된 의 선언형태는 자바스크립트 라이브러리중 하나인 리액트에서 사용하는 JSX 문법과 유사해 충돌을 일으킵니다.이러한 단점을 보완하기 위해 as 문법사용을 권장합니다. 타입 어설션은 컴파일러에게 전달되는 타입 정보이므로 컴파일러는 타입 어셜션을 보고 유효성을 검증합니다. 예를 들어 타입이 지정된 변수와 타입 어설션이 선언된 변수 간에 유효성에 문제가 없으면 두 변수 간에 타입 호환이 이뤄집니다. 타입 호환프로그래밍 언어마다 타입 검사 시점이 다른데 타입 검사는 크게 다음과 같은 두가지 방식이 있습니다. 동적 타입 검사(dynamic type checking) 정적 타입 검사(static type checking) 자바스크립트 같은 동적 프로그래밍 언어는 런타임 시점에 동적 타입 검사를 수행하고, 타입스크립트 같은 정적 언어는 컴파일 시점에 정적 타입 검사를 수행합니다. 타입스크립트는 두 부류의 타입 시스템을 지원합니다. 구조 타입 시스템(structural type system) 명목 타입 시스템(nominal type system) 구조 타입 시스템은 타입의 구조와 정의만 같다면 타입 호환이 가능합니다. 이와 달리 명목 타입 시스템은 타입 호환이 되려면 명시적으로 같은 타입이어야 합니다. 타입 스크립트는 크게 네 부류의 타이핑 방식을 지원합니다. 덕 타이핑(duck typing) - 런타임시 동적으로 타입의 구조가 정해지는 타입 지정 방식 구조 타이핑(structural typing) - 타이브이 구조만 같으면 서로 호환 가능한 타입 지정 방식 구조 서브타이핑(structural subtyping) - 구조가 부분적으로 같더라도 타입 호환을 지원합니다. 명목 타이핑(nominal typing) - 타입 구조뿐 아니라 타입까지 같아야 호환 가능한 타입 지정 방식 덕 타이핑덕 타이핑은 동적으로 타입이 결정되므로 유연하지만 타입 안정성은 떨어집니다. 만약 덕 타이핑을 할 때 타입 안정성을 강화하려면 인터페이스를 도입하면 됩니다.덕 타이핑을 수행할 때 매개변수에 지정할 타입으로 사용하기 위한 인터페이스 타입을 선언하고 함수의 매개변수에 인터페이스 타입을 선언하면 덕 타이핑에도 타입 안정성이 생깁니다. 12345678interface DuckGoose { speak(); swim();}function swim(obj: DuckGoose) { obj.speak(); obj.swim();} 구조 타이핑타입 호환이 가능하며 컴파일을 통과시키고 타입 호환이 불가능 하면 컴파일 오휴를 출력합니다.구조가 같은 클래스 간에는 서로 타입 호환이 가능해서 서로의 타입으로 구조 타이핑이 가능합니다.생성자의 매개변수가 달라로 타입 호환이 되는 데는 문제가 없습니다. 생성자 매개변수는 접근 제한자가 설정되지 않아 생성자 내부에서만 사용할 수 있으므로 클래스 구조에 영향을 미치지 않기 때문입니다. 구조 서브 타이핑구조 타이핑은 타입 구조가 같아야지만 타입 호환이 이뤄지지만, 구조 서브 타이핑은 구조가 부분적으로 같더라도 타입 호환을 지원합니다. 구조 서브 타이핑의 조건구조 서브 타이핑은 하위 타입이 상위 타입으로만 호환되는 조건이 있습니다. 상위 타입은 타이핑 관점에서 공통되는 구조(변수 메서드 등)가 들어있는 기본 형태이고, 하위 타입은 상위 타입을 포함하면서 구조가 보태어진 특정한 형태를 의미 합니다. 하위 타입은 상위 타입의 속성을 포함합니다. 이때 “상위 타입 = 하위 타입”처럼 하위 타입을 상위 타입에 대입하는 것으로 구조 서브타이핑이 가능합니다. 이때 하위 타입은 상위 타입으로 타입 호환이 가능합니다. 구조가 일부 같으면 타입이 ㅇ벗더라고 변수 간의 구조 서브 타이핑이 가능합니다. 매개변수 개수와 호출시 전달하는 인수의 개수가 다르면 오류가 발생합니다. 함수의 매개변수가 다른 경우 매개변수가 적은 사위 함수 타입이 매개변수가 많은 하위 함수 타입으로 타입 호환이 가능합니다. 객테 리터럴이 할당된 변수에 인터페이스 타입을 지정하면 해당 변수는 구조 서브 타이핑이 적용됩니다. 명목 타이핑명목 타이핑은 자바나 C++, C#과 같은 언어에서 사용하는 타이핑방식으로 명시적으로 지정된 타입 간에만 타입이 호환됩니다.","link":"/2020/06/03/TypeScript-typeChange/"},{"title":"타입스크립트 - 제네릭","text":"제네릭(generics)은 클래스와 함수에 타입이 고정되는 것을 방지하고 재사용할 수 있는 요소를 선언할 수 있게 합니다. 제네릭은 C#이나 자바와 같은 언어에서 제공됐던 기능으로 타입스크립트 0.9 부터 지원됐습니다. 제네릭의 타입 검사를 컴파일 시간에 진행해 타입 안정성을 보장한다. 캐스팅과 관련한 코드를 제거할 수 있다. 제네릭을 이용하면 제네릭 로직을 이용해 재사용이 가능한 코드를 만들 수 있다. 타입 매개 변수를 통해 타입 안정성을 보장할 수 있다. 타입 안정성은 제네릭 함수명 끝에 선언된 T에 의해 결정됩니다.T는 타입의 약자로 ‘타입 매개변수’ 또는 ‘제네릭 타입 변수’라 합니다. 타입 매개변수 T 는 타입이 정해져 있지 않은 가상의 타입으로 임의 알파벳이나 단어로 선언해도 좋습니다. 타입 매개 변수 T는 제네릭 함수를 호출 할 때 타입 인수로 타입을 결정합니다. 제네릭 함수의 타입이 결정되는 과정을 ‘타입 바인딩’이라 합니다. 타입 바인딩이 이뤄 지면 타입 안정성이 생깁니다. 캐스팅과 관련한 코드를 제거할 수 있다. 만약 타입 매개변수로 반환 타입의 지정돼 있다면 더는 함수의 반환값에 대해 캐스팅하지 않아도 됩니다. 제네릭 로직을 이용해 재사용할 수 있는 코드를 만들 수 있습니다. 제네릭 로직을 이용하면 타입은 다르지만 같은 로직을 수행하는 재사용성이 좋은 코드를 만들 수 있습니다. 제네릭 함수타임 매개 변수는 제네릭에서 가장 중요한 요소입니다. 타입 매개변수는 함수 선언에 함수를 제네릭 함수로 변경 할 수 있게 합니다. 1234function concat(strs: T, strs: T) { return strs + strs2;}concat('abc','123'); 제네릭 함수의 매개변수 strs가 타입이 결정됐을 때 타입 매개변수와 다른 타입의 인수가 전달되면 타입 오류가 발생합니다.타입 인수를 전달하면 함수가 불필요한 추론을 하지 않아도 됩니다. 바운드 타입 매개변수를 이용한 T+T 연산시도타입을 제약 하려면 타입 매개변수는 특정 타입을 상속해야 합니다.타입 매개변수가 특정 타입으로 묶였다면 해당 타입 매개변수는 T를 바운드 타입 매개변수라고 부릅니다.(유니언 타입을 상속해 선언 할 수도 있습니다.) 12 오버로드 함수를 이용한 타입 매개변수 간의 연산오버로드 함수를 이용하면 T+T 와 같은 타임 매개변수 간에 연산이 가능합니다, 오버로드 함수는 이름만 같고 매개변수의 타입이나 개수가 다르게 선언된 함수를 의미합니다. 제네릭 클래스와 인터페이스자료구조나 알고리즘은 타입에 의존적이면 범용으로 사용할 수 없습니다. 범용으로 사용할 목적의 자료구조나 알고리즘이 있다면 다양한 타입에 대응하도록 제네릭을 적용해야합니다.제네릭은 함수처럼 작은 단위뿐아니라, 클래스처럼 큰 단위에서도 적용할 수 있습니다. 제네릭 클래스 선언제네릭 클래스는 외부로부터 타입을 받아들여 클래스 내부에 입력된 타입을 적용할 수 있는 클래스입니다. 123456[형식]class 클래스명 { getValue(elms: Array, index: number): T { return elms[index]; }} 클래스 명 뒤에 타입 매개변수인 를 선언해 줍니다. 는 타입 매개변수이며 매개변수나 반환 타입으로 사용될 수 있습니다. 타입 매개변수에 인터페이스 상속제네릭 클래스에 전달된 매개변수가 클래스이고 타입 매개변수일때 코드 어시스트를 받지 못할 때가 있다. 이유는 타입 매개변수에 타입이 없기 때문명시적으로 타입을 선언하려면 처럼 클래스에 대한 인터페이스를 상속해주면 됩니다. 제네릭 클래스를 사용하면 클래스 전역에 걸쳐 타입 매개변수가 적용됩니다. 만약 특정 메서드만을 대상으로 제네릭을 적용하려면 해당 메서드를 제네릭 메서드로 선언하면 됩니다.메서드 단위로 제네릭을 적용하는 것은 특정 메서드에만 타입 인수를 전달할 수 있으므로 타입의 재활용성이 다소 떨어집니다.그런데 클래스 단위로 제네릭을 적용하며 클래스 내에 존재하는 불특정 메서드에 대해 일괄적으로 제네릭 메서드로 선언할 수 있어서 더 편리합니다. 제네릭의 여러 활용방법룩업 타입을 제네릭 클래스에 적용룩업 타입은 keyof로 속성을 포함하는 대상을 탐색해 유니언 타입처럼 동작합니다. 123456function getValue(obj: T, key: K) { return obj[key];}let numberKeys = { one:1, two:2, three:3 };console.log(getValue(numberKeys, 'one'));// 1 타입 매개 변수K는 타입 매개변수 T에 의해 정해지는 룩업 타입이 됩니다. 따라서 타입 매개변수 K는 keyof를 이용해 타입 매개변수 T의 속성을 탐색해 하나의 속성만 허용하도록 제약합니다. 인터페이스를 상속해 제네릭 확장하기인터페이스는 클래스가 구현해야 할 메서드나 프로퍼티를 선언할 수 있습니다. 만약에 구현해야 할 클래스가 제네릭 클래스라면 인터페이스는 제네릭 인터페이스로 선언해야 합니다.제네릭 인터페이스는 타입 매개변수가 선언된 형태로 선언합니다. 12345678910111213interface IFilter { unique(array: Array): Array;}class Filter implements IFilter { unique(array:Array):Array { return array.filter((v, i, array) => array.indexOf(v) === i); }}let myFilter = new Filter();let resultFilter = myFilter.unique(['a', 'b', 'c', 'a', 'b']);console.log(resultFilter);","link":"/2020/06/03/TypeScript-generic/"},{"title":"Hexo 배포 원리에 따른 백업(backup) 방법","text":"Hexo를 이용해서 블로그를 만들고 관리 하다보니 문제점을 하나 발견했다.바로 백업에 관한 문제인데 Hexo 블로그는 Github에 repository를 통해 구성되어 있으니다른 곳에서 작업할때 그것을 clone해서 수정하면 된다고 생각했다. 그러나 다른 곳에서 clone을 해보고는 문제가 있음을 알 수 있었다.라이브되는 repository에 올라가는건 public 폴더의 내용이라 실제로 작업한 것은 repo에 push 되지 않고 로컬에만 저장되어있는 것이다. 그래서 해결책으로 별도의 백업 repository 하나를 생성하여 별도로 백업을 하기로 했는데 이 방법도 문제가 있었다.Hexo의 테마가 별도의 git을 가지고 있어서 하나의 백업 repository만으로는 완벽하게 백업 관리가 어려웠다 그래서 두개의 백업 repository와한개의 라이브 repository를 가지고 총 3개의 repository를 가지게 되었다. 새 저장소 생성기존의 블로그가 라이브(.github.io) 되어있는 repository외에 2개의 저장소가 추가로 필요합나디.테마 백업용와 포스팅 백업용 이렇게 2개 입니다. 저는 제가 사용하는 테마의 이름인 icarus라는 저장소와 blog_backup 이라는 두 개의 저장소를 private로 만들어 줬습니다. 2019.01.07일부로 Github의 private 저장소가 무료로 전환 되었습니다. 테마 백업먼저 테마폴더를 백업해줍니다. 보통 테마를 설치 할때는 아래와 같은 명령어를 사용합니다. 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 물론 위와 같은 방법으로 설치해도 테마를 수정없이 사용하면 별다른 문제는 없습니다. 다만 테마의 들어가는 내용을 수정을 하게 되면 변경사항을 저장해야되고그것을 한군데가 아니 여러곳에서 관리하러면 별도의 백업이 필요합나다. 그래서 설치되어 있는 테마의 원격 저장소의 주소를 변경해줍니다. 아래 명령어는 해당 테마폴더에서 실행해야합니다.(cd themes/icarus) bash123456789101112# 테마 폴더에서 원격 저장소를 확인합니다.$ git remote -v# 원격 저장소를 변경해 줍니다. (자신의 저장소 주소로 변경)$ git remote set-url origin # 변경된 원격 저장소를 확인합니다.$ git remote -v# 변경 사항 올려줍니다.$ git commit -a -m 'theme backup'$ git push -u origin master 블로그 자료 백업블로그 폴더를 git으로 초기화 시켜줍니다. bash123456789101112#git 초기화git init#현재 내용을 전부 커밋해 줍니다.git commit -a또는git add .git commit -m \"커밋메세지\"#백업 repo에 연결하고 pushgit remote add origin git push -u origin master 이렇게 하면 각 repo에 테마백업과 포스팅 백업을 할 수 있습니다. 그러고 나서 hexo 명령어를 통해 배포해 줍니다. 배포하기12hexo cleanhexo d -g 힘든 백업 작업이 끝났습니다. ㅎㅎㅎ 약간 번거롭지만 안전한게 좋아서 이렇게 세팅하긴 했습니다.그리고 마지막으로 테마폴더의 내용을 변경하게 되면 루트위치에서 한번에 관리가 되지 않습니다. themes/icarus 위치에서 테마백업 repo에push 해주고 다시 루트 위치로 돌아와서 별도의 push를 해줘야 정상적으로 백업관리가 됩니다. 결과적으로 총 3개의 repo를 활용해서 블로그를 백업하고 라이브 하는 작업을 하였습니다. 먼가 조금 더 스마트한 방법이 있을것 같은데아는게 없네요 ㅎㅎㅎ; 좋은 방법이 있으신 분은 댓글이나 메일로 남겨주시면 감사하겠습니다.","link":"/2019/06/20/backup/"},{"title":"쿠팡파트너스 Hexo 블로그에 등록하기","text":"모든 블로거들의 목표중에 하나인 블로거를 통한 수익창출을 시도해 보았습니다.물론 큰 기대는 하지 않습니다 ㅎㅎㅎ;;;많은 광고 시스템중에서 오늘 해볼것은 간단하게 설치가 가능한 쿠팡 파트너스 입니다. 쿠팡 파트너스는 CPA 방식의 광고 시스템입니다. CPA란?Cost Per Action 의 줄임말입니다. 변역하자면 ‘행위 당 과금’ 방식입니다.단순히 광고를 클릭하는 것으로 수익배분이 일어나는 것은 아니고 광고를 클릭해서 사이트로 접속하여 제품을 구매했을 때, 제품 구매가의 3%가 포인트로 적립되는 방식입니다. 가입먼저 회원가입이 필요합니다. 쿠팡파트너스로 접속하여 회원가입을 하여 줍니다.기존 쿠팡아이디로도 사용가능하니 있으신 분은 별도의 가입이 필요없습니다.가입 하는 방법 자체는 매우 간단하니 생략하도록 하겠습니다. 가입승인이 2~3일 정도 걸린다고 하는데 그 사이에 시스템이 바뀌었는지 저는 가입하자마자 바로 등록할 수 있었습니다. 회원가입시에 추천인 코드를 쓰면 1%추가 적립을 받을수 있다고 합니다.추천인코드가 필요하신 분은 가져다 쓰세요 ^^ ID : AF3074287 상품링크쿠팡 파트너스에서는 여러가지 형태의 배너를 제공하고 있습니다.상품링크에 메뉴를 선택하면 위와 같이 여러가지 형태에 링크 또는 배너를 만들 수 있습니다.블로그에 맞는 배너를 선택하셔서 사용 할 수 있습니다. 배너생성링크링크의 경우 마음에 드는 상품을 선택해서 url 혹은 배너로 만들수 있는 기능입니다.한가지 상품만 노출되는 형태로 쿠팡에 있는 상품을 블로그로 작성하고 광고 할때 수익을 볼 수 있는 형태로 작성하는 것이 좋을 것 같습니다. 상품 탐색에서 원하는 상품을 검색 마음에 드는 상품 선택단계로 넘어가면 상품탐색에서 검색한 상품들이 나옵니다. 그 중에 원하는 상품상품 정보를 확인하고 링크생성을 누릅니다. URL 혹은 배너 만들기에서 생성된 단축 URL만을 사용하셔도 되고 아래에 있는 태그를 복사하셔서 블로그에 사용하시면 됩니다. 간편링크만들기간편링크만들기의 경우에는 URL을 생성하는 기능입니다.추천링크로는 쿠팡홈, 골드박스, 로켓와우, 로켓배송, 로켓직구가 있고 그 외의 링크도 쿠팡에서 원하는 페이지 찾아보기를 클릭하셔서원하는 링크를 아래 인풋창에 복사하셔서 링크생성 버튼을 누르면 파트너스URL이 생성됩니다.이 링크를 블로그에 사용하셔서 사용자가 링크를 타고 물건을 구매하게 되면 수익배분이 일어납니다. 다이나믹 배너저는 이 기능을 이용해서 배너를 만들었습니다. 크기를 마음대로 조정 할 수 있어서 자신의 블로그에 맞는 형태로 적용할수 있으며여러가지 상품들이 슬라이드 형태로 노출되어서 특정상품의 배너 보다는 방문자의 클릭이 있을것 같아서 선택했습니다. 배너생성버튼을 눌러서 배너 만들기를 시작합니다. 배너명을 정해주고 배너타입,카테고리를 선택해 줍니다. 저는 랜덤으로 돌아가는 파트너스 추천과 Coupang Only를 선택했습니다.그리고 원하는 크기를 입력하고 테두리 여부를 선택합니다.미리보기 화면을 통해서 원하는 형태로 만들어 졌는지 여부를 확인 할 수 있습니다. 배너 만들기 버튼을 클릭하면 하단에 파트너스 코드가 생성됩니다.이 코드를 복사해서 블로그에 넣으시면 배너 등록 완료입니다. 배너의 크기를 %로 작성 할수 있습니다. 100%로 작성하시면 반응형 페이지에도 사용하기 편합니다. 배너, 검색위젯배너와 검색위젯 기능은 미리 만들어진 배너를 사용할수 있는 코드들을 보여줍니다.원하는 형태의 배너를 선택하셔서 사용하시면 됩니다. Hexo 블로그에 적용레이아웃의 경우 적용하신 테마에 따라 형식이 조금씩 다르겠지만 보통 layout 폴더에서 ejs파일들로 관리합니다.EJS 는 Embedded JavaScrip의 줄임말로 간단한 자바스크립트로 HTML마크업을 생성 할수 있는 간단한 템플릿언어입니다.hexo블로그들은 대부분 ejs로 작성되어있습니다. layout폴더 경로에 layout/ads라는 폴더를 만들고 coupang_ad.ejs라는 파일을 새로 생성합니다.배너 만들기를 통해 생성한 코드를 coupang_ad.ejs에 입력해 줍니다. coupang_ad.ejs12345//예시코드입니다. 생성받으신 코드를 입력하시면 됩니다. new PartnersCoupang.G({ id: }); 그리고 원하시는 위치에 위의 코드를 불러오면 됩니다.형태는 이것 처럼 넣으시면 됩니다. 이때 확장자는 쓰시면 안됩니다. 원하는위치.ejs1 이제 모든 과정이 끝났습니다. 블로그를 재배포 해준후에 확인하시면 잘 들어가 잇는 것을 볼 수 있습니다.쿠팡파트너스 페이지에서 클릭,구매액,수익 등을 확인 할 수 있습니다. 그리고 회원가입시에 추천인 코드를 쓰면 1%추가 적립을 받을수 있다고 합니다.추천인코드가 필요하신 분은 가져다 쓰세요 ^^ ID : AF3074287 우리모두 블로그로 부수입을 창출해 봅시다. ㅎㅎㅎ","link":"/2019/06/21/blog-ad-coupang/"},{"title":"Git의 기본적인 명령어","text":"안녕하세요 미슈카 입니다.오늘은 git의 기본적인 명령어들을 정리해보려고 합니다.모든 명령어들을 정리하는 것이 아닌 많이 쓰이는 명령어들을 위주로 정리 하려고 합니다. 그전에 먼저 간단하게 git이란 무엇인가? 그리고 git에서 사용하는 용어들을 정리해 보겠습니다. git이란 무엇인가? git은 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템이다.위키백과위키 백과에서는 위와 같이 말하고 있다. 그 중에서 우리가 주위깊게 보아야 할 단어들은“추적, 분산 버전 관리 시스템”이다.git은 2005년 리누스 토르발스가 리눅스 커널 개발을 위해 처음 개발하였다.많은 버전 관리 시스템(VCS : Version Control System)중에 하나인데 다른 버전 관리 시스템과 다른점은저장소를 분산해서 관리 한다는 점이다. 즉 중앙 저장소에 문제가 생겨도 로컬저장소를 이용하여 복원이 가능하다는 것이다. git에서 사용하는 용어 Working tree : 현재 작업하고 있는 공간, git이 관리하고 있지만 아직 추적(track)하고 있지 않은 상태 (또는 Working Directory) Staging area : 커밋 하기전 staged 된 파일들이 있는 공간,수정한 파일을 커밋하기 전에 표시(add)해둔 공간 Commit : 작업한 내용을 로컬 저장소에 저장하는 것을 의미합니다. Repository : 저장소를 의미 합니다. 저장소에는 2가지가 있습니다. -Local Repository : 본인 PC에 존재하는 저장소를 의미합니다.-Remote Repository : Github, Gitlab과 같은 원격저장소를 의미합니다. Push : 로컬저장소(Local Repository) 에서 Commit이 완료된 내용을 원격저장소에 업로드 하는 것. Clone : 원격저장소의 내용을 통째로 다운로드 하는 것을 말합니다. Branch : 가지 또는 분기점을 의미, 현재 상태를 복사하여 자신만의 branch를 만들수 있고 작업이 완료되면 merge를 통해 합칠 수 있다. Checkout : 특정 시점이나 브런치로 이동하는 것을 의미 Fetch : master나 다른 branch에서 작업한 내용이 내 로컬저장소와 버전이 맞지 않을때 최신버전으로 업데이트 Merge : 다른 branch의 내용을 현재 branch로 가져와 합치는 작업 Pull : 원격저장소의 변경된 내용이 로컬저장소에 반영됩니다.(fetch + merge) git에서 일어나는 상태변화위 그림은 git을 사용하면서 일어나는 트랜젝션을 정리해 본 그림이다. git 명령어 본격적으로 git 명령어 들에 대해 알아보자모든 명령어를 나열하는 것은 아니고 주로 사용하는 명령어를 기준으로 써보고자 한다. 환경설정git configbash123git config --global --list // 현재 설정 정보를 조회합니다.git config --global user.name \"사용자명\" // 사용자명을 등록합니다.git config --global user.email \"이메일주소\" // 사용자 이메일주소을 등록합니다. 기본명령어git initbash1git init // 깃 저장소를 초기화 한다. 현재 디텍토리에서 git 저장소를 생성합니다. git statusbash1git status // 저장소 상태 보기 저장소의 상태를 체크 합니다. Commit이 필요한 변경사항이 있는지, 현재 저장소의 어떤 브런치를 작업하고 있는지 등을 볼 수 있다. git diffbash123456git diff // 스테이징 영역과 현재 작업트리의 차이점을 보여준다.옵션HEAD // 저장소, 스테이징 영역, 작업트리의 차이점을 모두 볼수 있다.--cached // 스테이징 영역과 저장소의 차이점을 볼 수 있다.--stat // 변경사항에 대한 통계를 볼 수 있다. git addbash123456789git add // 파일단위로 선택git add . // 모든 파일 추가 또는git add *옵션 -i // 대화형모드 실행, 일부분만 선택하여 스테이징 가능-p // 대화형 모드 없이 바로 패치모드 사용 단일 파일 또는 변경된 모든 파일을 스테이징 한다. git commitbash123git commitgit commit -m \"커밋메세지\"git commit -a // 스테이지에 올리는 것과 커밋을 동시에 진행 git revertbash1git revert 기존 커밋에서 변경한 내용을 취소해서 새로운 커밋을 만듭니다. git resetbash123git reset -- // 커밋 취소git reset --hard // 해당 위치로 되돌림git reset --hard HEAD // 마지막 커밋 상태로 되돌림 git logbash123456git log옵션-3 // 출력할 커밋로그의 갯수를 지정 할 수 있습니다.--oneline // 한 줄로 간단하게 보여줍니다.--graph // 브런치 트리를 볼 수 있습니다. 커밋로그들을 볼 수 있습니다. 여러가지 옵션들을 적절히 사용하면 자신이 원하는 로그만을 볼 수 있습니다. Branch 명령어branch 목록bash1234git branch // 로컬 브런치git branch -v // 해당 브런치의 commit ID도 볼 수 있다.git branch -r // 리모트 브런치git branch -a // 로컬, 리모트 포함된 모든 브런치 브런치목록을 보여줍니다. 옵션을 통해 원하는 저장소의 브런치를 볼 수 있습니다. branch 생성bash1git branch // 원하는 이름으로 브런치를 생성한다. branch 삭제bash1git branch -d git checkoutbash1git checkout // 활성 브런치 변경 git mergebash1git merge // 브런치이름의 내용을 현재 브런치로 합친다. 원격저장소git clonebash1git clone //원격저장소를 복제하여 저장소를 생성합니다.(폴더명은 생략가능) git remotebash123git remote add // 원격저장소 연결git remote -v // 연결된 원격 저장소를 보여줍니다. git remote rm // 원격저장소를 제거합니다. git fetchbash1git fetch 원격저장소의 변경사항을 가져와서 갱신합니다. git pullbash12git pull git pull -rebase // 커밋메세지를 남기지 않는다. git pushbash123git push // 원격저장소에 업로드 한다.git push git push origin master 파라미터 값을 주지 않으면 origin 저장소에 푸싱하며 현재 지역브런치와 같은 이름으로 브런치에 푸싱합니다.","link":"/2019/06/03/git-basic/"},{"title":"Vue 에서 Axios를 사용하여 서버통신 해보기","text":"Axios 란?Axios는 HTTP 클라이언트 라이브러리 중 하나이다.비동기 방식으로 HTTP 데이터 요청을 실행하고 또한 IE8 이상을 포함한 모든 최신 브라우저를 지원한다.Axios는 Promise를 기반의 자바스크립트 비동기 처리 방식을 사용합니다. 설치보통 npm을 통해 설치를 진행합니다. 1npm install axios 이밖에도 yarn,bower,CDN 을 통해 설치도 가능합니다. 12345678// yarnyarn add axios// bowerbower install axios// Using unpkg CDN 사용방법Axios는 여러가지 별칭 method를 제공하고 있습니다. axios.get(url[, config])axios.post(url[, data[, config]])axios.patch(url[, data[, config]])axios.delete(url[, config])위에 자주 쓰이는 4가지 이외에도 여러가지 를 지원 하고 있다.axios.request(config)axios.head(url[, config])axios.options(url[, config])axios.put(url[, data[, config]]) 별칭으로 사용하는 경우에는 url, method 및 data 특성을 구성에 지정할 필요가 없습니다. GET (불러오기)GET은 말 그대로 서버에서 데이터를 가져오는데 사용합니다. 많이 사용하는 명령어 중에 하나입니다.서버 주소 /api로 부터 값을 가져올때는 아래와 같이 사용합니다. GET1234567axios.get('/api') .then(res => { console.log(res); }) .catch(err) => { console.log(err); }); axios 요청할 때 메소드의 두번제 인자인 config 객체에 요청값을 같이 넘길수 있습니다. 1234567axios.get('/api', { params: { title: '타이틀' }, headers: { 'Content-Type': 'application/json' }, timeout: 1000 }).then(res => { console.log(res); }) POST (입력하기)서버에 값을 입력 할 때 사용합니다. 서버의 데이터 리스트의 마지막에 넘기는 정보를 추가합니다. 1234axios.post('/api', { title: '타이틀' }) .then(res => { console.log(res); }) PATCH (수정하기)서버의 특정 데이터를 수정합니다. 1234axios.patch('/api', { title: '타이틀변경' }) .then(res => { console.log(res); }) DELETE (삭제하기)서버의 특정 값을 삭제합니다. 1234axios.delete('/api/val') //val = 특정 값 .then(res => { console.log(res); }) Vue 에서 Axios 사용하기vue 에서 axios 를 사용하려면 Vue.prototype에 axios를 추가하면 된다. main.js에 나래와 같은 내용을 추가한다. main.js1234567891011import Vue from 'vue'import App from './App.vue'import axios from '.axios' // import axiosVue.prototype.$axios = axios; // prototype에 axios 추가Vue.config.productionTip = falsenew Vue({ render: h => h(App),}).$mount('#app') 위와 같이 작성하면 Vue 인스턴스 내부에서 axios를 따로 import 하지 않아도 this.$axios를 이용해서 사용 할 수 있다. Referencehttps://github.com/axios/axioshttps://tuhbm.github.io/2019/03/21/axios/https://ux.stories.pe.kr/138https://luji.tistory.com/83","link":"/2020/02/19/axios/"},{"title":"실행 컨텍스트(execution context)","text":"실행 컨텍스트(execution context)는 쉽게 보면 코드가 실행되고 있는 구역,범위에 대한 개념정도로 볼 수 있다.실행 컨텍스트는 실행할 코드에 제공할 환경정보들을 모아놓은 객체이다.ECMAScript 스펙에서는 실행 컨텍스트를 ‘실행 가능한 코드를 형상화하고 구분하는 추상적인 개념’이라고 정의 한다. 자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러가지 정보들을 알고 있어야 한다고 한다. 실행에 필요한 정보들을 아래와 같다. 변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티 함수 선언 변수의 유효범위(Scope) this 코드를 실행하면 ‘전역 컨텍스트(Global execution Context)’가 생깁니다. 전역 컨텍스트는 브라우저가 종료 될 때까지 유지됩니다.특정 ‘함수’안에서 실행되는 코드가 아니라면 코드는 전역 컨텍스트에서 실행됩니다. 함수가 호출 될때 해당 함수에 대한 실행 컨텍스트가 생성된다.(Functional Execution Context) 함수들은 각각 자신만의 실행 컨텍스트를 가지지만이를 함수가 호출 되어야 만들어 집니다. 예제로 한번 보겠습니다. javascript12345678910111213// (1)var a = 1function outer() { function inner() { console.log(a) // undefined var a = 3 console.log(a) // 3 } inner() // (2) console.log(a) // 1 }outer() // (3)console.log(a) // 1 위의 코드의 실행 순서를 따라가 보면 처음에 자바스크립트 코드를 실행하면(1) 전역 컨텍스트가 콜 스텍에 담깁니다. 순차적으로 코드를 읽다가 (3)에서 outer 함수를 호출하면 outer함수에 대한 실행 컨텍스트를 생성한 후 콜 스텍에 담습니다. 콜 스텍에 새로운 컨텍스트가 놓인상태가 됐으므로 전역 컨텍스트와 관련된 코드 실행을 일시 중단하고 outer 함수에 대한 실행 컨텍스트를 실행합니다. outer 함수 내부의 코드들을 순차로 실행합니다. (2)에서 inner 함수가 호출되서 inner함수의 실행 컨켄스트가 콜 스택의 가장 위에 담기면 outer 컨텍스트와 관련되 코드의 실행을 중단하고 inner함수 내부의 코드를 순서대로 진행합니다. inner함수 내부의 값을 출력하고 나면 inner함수의 실행이 종료되면서 inner 실행 컨텍스트가 콜 스택에서 제거됩니다. inner컨텍스트의 의해 중단되었던 outer (2)줄 다음부터 실행됩니다. a 변수 값을 출력하고 outer함수의 실행이 종료되며 outer실행 컨텍스트가 종료되며 콜 스택에서 제거됩니다. 중단되었던 전역 컨텍스트 (3)의 다음 줄부터 실행됩니다. a 변수의 값이 출력되고 전역 컨텍스트도 콜 스택에서 제거 됩니다. 스택구조를 잘 살펴보면 한 실행 컨텍스트가 콜 스택의 맨위에 쌓이는 순간이 곧 현재 실핼할 코드에 관여하게 되는 시점임을 알 수 있습니다.기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치 할 수 밖에 없기 때문입니다. 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장합니다. 실행 컨텍스트의 3가지 객체실행 컨텍스트 자체는 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 가지며 3가지 프로퍼티를 가진다. Variavle Object (VO / 변수객체)변수, 매개변수, 인수정보, 함수 선언의 정보를 담고있는 객체컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 정보를 수집전역 실행 컨텍스트와 함수 실행 컨텍스트 일때 내용이 다르다전역 컨텍스트의 경우 - 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Gloval Object / GO)함수 컨텍스트의 경우 - Acrivation Object(AO / 활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고있는arguments object가 추가됨 호이스팅변수를 선언하고 초기화 했을때 선언 부분이 코드의 최상단으로 끌어올려지는 현상.선언부만 올라가므로 최기화 또는 대입 부분은 그대로 남아있음함수 선언식의 경우에는 함수 전체가 통째로 끌어올려짐 javascript12345678function a (x) { console.log(x); var x; console.log(x); var x = 2; console.log(x);}a(1) 위의 코드를 호이스팅 개념처럼 변경하면 javascript123456789101112function a () { var x; var x; var x; x = 1 console.log(x); console.log(x); x = 2; console.log(x);}a() 인자들과 함께 함수를 호출한 경우의 동작은 전달된 인자를 arguments object에 담는 것을 제외하면 코드내부에서 변수를 선언한 것과 다르지 않아서 함수 내부의 코드 최상단에서 선언 및 할당이 이뤄진것으로 간주하여 적용 javascript12345678function a () { console.log(b); var b = 'bbb'; console.log(b); function b () {}; console.log(b);}a(); 위의 코드를 호이스팅 개념처럼 변경하면 javascript123456789function a () { var b; function b () {}; console.log(b); b = 'bbb'; console.log(b); console.log(b);}a(); 함수 선언식의 경우는 식이 통째로 끌어올려지는것에 주의 Scope Chain(SC)스코프 체인은 일종의 리스트, 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장해당 전역 또는 함수가 참조 할 수 있는 변수, 함수 선언 등의 정보를 담고있는 전역 객체 또는 활성 객체의 리스트현재 실행 컨텍스트의 활성 객체로 시작해서 순차적으로 상위 컨텍스트의 활성 객체를 가리키며 마지막에는 전역 객체를 가리킴스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하며 스코프 체인은 식별자 중에서 변수를 검색하는 메커니즘 javascript1234567891011var a = 1;var outer = function () { var inner = function () { console.log(a); var a = 3; }; inner(); console.log(a);};outer();console.log(a); this valuethis 프로퍼티에는 this 값이 할당 됨this에 할당되는 값은 함수 호출 패턴에 의해 결정된다. Reference 코어 자바스크립트 - 위키북스 https://poiemaweb.com/js-execution-context https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy https://velog.io/@stampid/Execution-Context%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80 https://reinvint.tistory.com/6","link":"/2020/01/02/execution_context/"},{"title":"hexo 포스팅 스타일 설정하기","text":"hexo를 통해 포스팅을 하다보니 테마커스텀에 대한 욕구가 스멀스멀 솟아올랐다. ㅎㅎㅎ;;메인 이미지도 그리고 아이콘이나 위젯들의 위치도 이곳 저곳 옮겨보기도 하면서나름 나만의 스타일로 하나씩 바꿔나가는 재미가 있었다, 아래 내용들은 현재 제가 사용하고 있는 icarus 테마를 기준으로 작성한것입니다.다른 테마에서는 다른 방법이 있을 수 있습니다. 그렇게 블로그를 조금씩 꾸미고 여러가지 포스팅들도 올리고 하다가 한 가지 의문이 생겼다.바로 포스트 리스트에서 사용하는 위젯들을 _config.yml 에서 설정으로 잡아 주었는데포스트 상세페이지에서도 똑같이 노출이 되다보니 포스트 본문의 가로 넓이가 너무 적게 보인다는 점이었다. 그래서 _config.yml에 있는 설정들을 하나씩 뜯어보고 해당 기능이 있는지 찾아보았지만원하는 기능은 없는것 같아서 기운없이 여러 블로그를 돌아다니고 있는 도중에 내가 사용하는 테마를 같이 사용하는블로그에서 리스트와 포스트 상세페이지에 스타일이 다른 것을 발견하고는 다시 이것 저것 세팅을 바꿔보고해당 블로그와 코드도 비교해 보면서 방법을 찾기 시작했다. 그러던 중 정말 우연히 내 포스트와 다른 점을 발견하게 됐고 방법을 찾았다.나와 같은 필요를 느끼고 있는 분들을 위해 그 방법을 간단하게 정리해 보고자 한다. 우선 포스팅방법이 궁금하신 분들은 지난번에 작성한 hexo 포스팅 방법을 참고하면 됩니다. 여러가지 실험끝에 발견한 방법은 그러한 세팅이 따로 존재하는 것이 아니라 포스팅을 작성할때머리말(Front matter)에 해당 파일의 정보를 입력해주면 되는 것이었다. 머리말은 지난 포스트에서 설명했듯이 포스트 생성시 포스트 최상단에 자동으로 생성이 됩니다.저자는 이곳에 카테고리,태그,썸네일등을 지정하여 포스트마다 다르게 노출되는 값들을 입력하는 곳이라 생각하였고머리말을 이용하여 위젯이나 레이아웃을 변경할 수 있을것이라고는 미처 생각하지 못했었다.그렇게 한참 다른 곳을 해메이다가 우연히 머리말의 입력값이 다른 것을 발견하고는 유레카를 외쳤다. 저자는 포스트작성시 머리글에 카탈로그,카테고리,태그 클라우드 위젯을 추가하고 싶었고포스팅 우측에 고정으로 놓고 싶었다. 그래서 아래와 같은 설정을 머리말에 추가해 주었다. 머리말1234567891011toc: truewidgets: - type: toc position: right - type: category position: right - type: tagcloud position: rightsidebar: right: sticky: true 하나씩 옵션을 살펴보면 머리말12345678910111213141516toc: true# 카탈로그 옵션을 사용하기 위해 true옵션을 사용하였다.widgets: - type: toc position: right - type: category position: right - type: tagcloud position: right # 위젯의 타입을 지정하여주고 위치를 오른쪽으로 지정하였다. sidebar: right: sticky: true# sticky 옵션은 true로 하여 우측에 고정을 시켜주었다. 위와 같은 내용들을 머리말에 추가하여 원하는 스타일로 꾸밀 수 있었다. 그리고 매번 포스팅을 할때위의 내용을 작성하면 번거롭기 때문에 스캐폴드에 해당내용을 추가해서 자동으로 추가되게 세팅하였다. 이상으로 hexo 포스팅 스타일 설정하기 포스팅을 마칩니다. 해당글로 많은 분들이 조금이나마 쉽게 hexo 블로그를 접하고 꾸밀 수 있기를 바랍니다.도움이 되었다면 댓글을 살포시 남겨주시면 감사하겠습니다.","link":"/2019/07/29/hexo-post-setting/"},{"title":"Github 블로그에 Custom 도메인 연결하기","text":"블로그를 운영하다보니 조금씩 욕심이 생기는것 같다 ㅎㅎ Hexo를 이용해 github 블로그를 만들고 SEO를 적용시켜보기도 하고 댓글 시스템도 연결하고 스타일도 조금씩 건들여보고 하다보니 결국에 나만의 도메인을 만들어서 연결해 보고 싶었다. 그래서 여러가지를 알아보다보니 Github 자체에서 Custom Domain을 간편하게 연결할수 있도록 해주고 있었다.한편 살펴 볼까요? 기본적으로 Github를 통해서 정적페이지를 호스팅 하게되면 기본도메인이 주어집니다. USERNAME.github.io그래서 저는 mishka86.github.io 로 설정되었습니다. 원하는 도메인을 연결하려면 원하시는 도메인 주소를 구입하신 후에 도메인 연결을 하시면 됩니다.저는 mishka.kr 도메인을 hosting.kr을 통해서 구입했습니다. DNS 설정 방법저는 hosting.kr 설정을 위주로 설명하겠지만 다른 도메인 서비스에서도 비슷한 루트로 변경이 가능 하니 참고하시기 바랍니다.도메인의 네임서버를 변경해 주어야합니다. hosting.kr에서는 부가서비스로 구분이 되어있네요.Home > 도메인 > 부가서비스 > 네임서버 설정 관리 들어가서 github에서 요구 하는데로 변경을 시켜줍니다. Type 서브 도메인 IP주소 / 레코드 값 A Record 185.199.108.153 A Record 185.199.109.153 A Record 185.199.110.153 A Record 185.199.111.153 CName Record www USERNAME.github.io A Record는 Domain을 물리적인 IP 주소로 연결 할 수 있도록 합니다.CName은 물리적인 IP 주소가 아닌 다른 Domain을 연결 합니다. A Record의 경우 위에 것에서 하나를 선택해서 입력해 주면됩니다.저는 A Record와 CName을 위와 같이 세팅 해주었습니다. Github Pages 설정Github에서 블로그가 있는 Repository 로 이동합니다.메뉴에서 Settings > Options 에 Gihub Pages 항목에서Costom domain 을 자신이 가지고 있는 도메인 주소로 변경하고 Save 버튼을 눌러줍니다.HTTPS주소를 사용하시려면 하단에 Enfoce HTTPS 항목을 체크해 주시면 됩니다. 2018년 5월 1일 Github 공식 블로그 에서 정식 지원 소식이 올라왔습니다. 위와 같이 설정을 하면 이후에 USERNAME.github.io 로 접근되는 요청이 설정하신 도메인으로 Redirect 됩니다.이렇게 설정을 하면 설정하신 도메인으로 정상적으로 노출이 됩니다. 이렇게 진행을 했는데 저는 문제가 한가지 발생했는데요 새롭게 블로그를 배포하면 Costom domain 설정이 날아가는거였습니다.혹은 CName 파일이 정상적으로 생성되지 않은 경우도 발생할수도 있다고 하는데요 그럴 경우에 아래와 같은 해결법이 있습니다. hexo의 CNAME 생성을 위한 패키지를 설치 합니다. bash1npm install hexo-generator-cname --save 그리고 _config.yml 파일에서 아래와 같이 플러그인 설정을 해줍니다. _config.yml1plugins: hexo-generator-cname 그리고 _config.yml 에서 url 이름도 적용한 도메인과 같게 변경해 주세요. _config.yml1url: https://mishka.kr 이렇게 Github 블로그에 Custom Domain을 연결해 주었습니다. 여러분들도 자신만의 도메인을 연결해서 자신만의 블로그에 특징을 더해보세요. Referencehttps://www.holaxprogramming.comhttps://blog.chulgil.mehttps://blog.gaerae.com","link":"/2020/01/10/github-domain/"},{"title":"Disqus를 사용하여 댓글 기능 세팅하기","text":"오늘은 블로그의 세팅중 한가지인 댓글 기능을 세팅하는 방법에 대해 포스팅해보겠습니다. 사실 hexo 테마들의 대부분은 여러 댓글 시스템들을 간편하게 세팅 할 수 있도록 되어있습니다.그 중에 디스커스(Disqus)를 사용하여 댓글 기능을 세팅해보겠습니다. 디스커스(Disqus)란?디스커스는 소셜 댓글 서비스의 하나입니다. 소셜 댓글 서비스란 소셜미디어(SNS)를 활용한 댓글 시스템으로 페이스북,트위터 와 같은 SNS와 연동해서 댓글을 달 수 있게 만들어 주는 서비스입니다. 소셜 댓글 서비스를 활용하여 댓글을 달면 동시에 해당 댓글이 자신이 연동한 SNS에도 발행이 됩니다.별도의 댓글시스템을 구현할 필요없이 디스커스에서 제공하는 위젯을 설치함으로 사용 할 수 있는 것이 장점입니다. 설치순서 Disqus 회원가입 Settings > profile, Account 수정 Add Disqus To Site > I Want to comment on site 사이트 추가 Account > Username 확인 (shortname) _config.yml 설정 변경 회원가입Disqus 회원이 아니라면 회원가입이 필요합니다.Disqus 사이트에서 회원가입을 진행합니다. 정보 수정Settings 에 profile 과 Account에서 필요한 정보들을 수정해 줍니다. 사이트 추가우측 상단의 Add Disqus To Site 에 들어가서 I Want to comment on site 를 클릭 혹은 메인에서 GET STARTED 에 들어가서 I Want to comment on site 를 클릭 해당 정보들을 입력 후 Select a plan 에서 Basic 을 선택 Select Platform 단계에서는 맨 아래의 universal Code를 선택해 줍니다. 여기는 테마마다 조금 다릅니다. 디스커스를 지원하는 테마라면 configure 누르고 사이트 세팅을 마친다음_config.yml 의 설정만 변경 해주면 되고 안되어 있다면 소스를 추가해 주어야 한다. 그 때 이 코드를 사용하여 주면 됩니다.Installation instructions 계정정보 확인Account 에서 Username(shortname)을 확인하여 줍니다. _config.yml 설정_config.yml123comment: type: disqus shortname: disqus 계정이름 이 부분은 현재 제가 사용하는 icarus 테마의 _config.yml의 양식이고 테마마다 조금씩 다를수 있습니다. 배포1hexo d -g 배포를 시켜주고 아래와 같이 나온다면 성공입니다. 오류체크icarus테마는 기본적으로 disqus 댓글 시스템을 지원하고 있어서 위와같이 세팅하면 정상적으로 댓글기능이 작동해야 하지만무엇이 문제였는지 시스템 자체는 연결되었는데 댓글을 작성하는 위젯이 제대로 작동하지 않았다 ㅠㅜ icarus테마에서 제공하는 포스팅에서도 comment Plugin 의 설정만을 변경해 주면된다고 나오는데 말이다.Disqus Comment Plugin 여러가지를 시도해 보다 결국 소스코드 자체를 변경하는 것으로 해결하였다.icarus 테마의 경우 disqus.ejs 파일의 내용을 universal Code에서 제공하는 코드로 변경하니 정상적으로 작동되었다.테마마다 약간의 설정이 다를수 있으니 참고정도만 하시면 되겠습니다. 언어선택 문제현재 disqus에서는 한글을 지원하지 않는 것으로 변경되었다고 한다.그래서 편법으로 설정하는 방법이 있는데 편법이라 방법이 나와있는 포스팅을 공유하는 것으로 대체한다.디스커스 한글 세팅을 해보자","link":"/2019/07/02/hexo-comment-disqus/"},{"title":"gitflow 란? git-flow 를 사용한 브랜치 전략","text":"GitFlow?깃플로우(git-flow) 전략은 소프트웨어의 소스코드를 관리하고 출시하기 위한 ‘브랜치 관리 전략(branch management strategy)’중 하나이다.git-flow 전략외에도 github flow 와 gitlab flow 전략등도 있다. 각자에게 맞는 전략을 선택해서 사용하는게 가장 중요하다.git-flow 는 Vicent Driessen 이 제안한 git 의 workflow 디자인에 기반한 브랜칭 모델입니다. git-flow 에서 사용하는 브랜치의 종류는 5가지이며,크게 항상 유지되는 메인브렌치(master, develop)와 일정 기간 유지되는 보조 브랜치(feature, realease, hotfix)로 나뉩니다. Master - 제품으로 출시 되는 브랜치 Develop - 다음 출시 버전을 개발하는 브랜치 Feature - 기능을 개발하는 브랜치 Realease - 이번 출시 버전을 준비하는 브랜치 Hotfix - 출시 버전에서 발생한 버그를 수정하는 브랜치 많은 그림들 중에 역시 아래의 그림이 git-flow를 한눈에 이해하기에는 가장 좋은 것 같아서 가져왔습니다. 개발 흐름위의 그림을 토대로 개발 흐름을 보자면 처음에 Master 와 Develop 브랜치를 만듭니다. Develop는 Master에서 부터 시작되는 브랜치 입니다.새로운 추가 작업이 있는 경우 Develop 에서 Feature 브랜치를 생성한다.Feature는 언제나 Develop에서 시작해야 합니다. 기능추가 작업이 완료되면 Feature는 Develop로 Merge한다.QA를 위해 Develop에서 Release 브랜치를 생성한다. QA를 진행 하면서 발생한 버그들은 Release에 수정된다.QA가 끝나면 Release 브랜치를 Develop 와 Master 브랜치로 각각 Merge 한다.Hotfix 브랜치는 언제나 Master에서 시작해야 합니다. 작업이 완료되면 Hotfix는 Master 와 Develop 브랜치로 각각 Merge 한다. 자세한 내용은 A successful Git branching model 여기를 참고하세요. git 을 여러사람이 함께 사용하다보면 필연적으로 브랜치 전략을 세워서 git을 관리해야됩니다. 어떤 브랜치 전략을 사용하는지는 해당 팀의 성격에 맞게 선택하고 함께 공유하는게 중요하다고 생각합니다. ReferenceA successful Git branching model - 링크우린 Git-flow를 사용하고 있어요 - 우아한형제들 기술 블로그 링크","link":"/2020/03/30/gitflow/"},{"title":"hexo 블로그에 테마 적용하기 - icarus테마","text":"hexo를 이용해서 github블로그를 만들었습니다. 이제는 나만의 색깔을 입혀볼 테마를 적용해 보겠습니다.블로그 세팅 방법은 지난 블로그를 참고하시면 됩니다. hexo블로그에 테마를 입히는 방법은 사실 아주 간단 합니다.git을 이용하여 clone만 해주면 됩니다. 하지만 테마들마다 사용방법이나 설정법이 약간씩 다르고 자신의 색깔에 맞게커스텀을 하려고 한다면 점점 복잡해 집니다.테마마다 설정방법이 다르기 때문에 이번 포스팅에서는 제가 적용한 icarus테마를 기준으로 설명하겠습니다. 테마 고르기 우선 자신의 블로그에 적용할 테마를 고릅니다.Hexo Themes 에서 자신이 원하는 테마를 골라줍니다.Hexo Themes에는 많은 개발자들이 hexo를 사용하여 만든 테마 목록들을 확인하고 다운받을 수 있습니다. 물론 별도로 만들수도 있지만 시간이 많이 들고 잘 만들어진것들이 많이 있으니 오픈소스를 적극 활용 해보기로 합니다. ㅋ 저는 테마를 고를때 디자인, 반응형, 영문메뉴얼유무를 따져 보았고 그 중에 여러가지 테마를 적용해 보고 icarus테마를 골랐습니다. 테마 적용하기 앞에서 말했듯이 테마별로 적용 방법의 약간의 차이가 있을수 있으나 대체적으로 git clone 을 이용하여 설치하는 방법을repository에 README 파일로 적용방법을 알려주고있다.icarus테마도 hexo-theme-icarus repository에서 설치방법을 알려주고 있다. 설치터미널을 이용하여 hexo블로그가 있는 폴더에 들어가 줍니다. icarus테마를 themes/icarus 경로에 clone 받아 줍니다. bash12cd bloggit clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 위와 같이 입력해 주면 themes 디테토리 하위에 icarus 라는 디텍토리가 생기면서 해당 저장소의 내용을 clone 하여 줍니다. 그리고 blog 폴더 안에있는 _config.yml에서 theme 부분을 landscape에서 icarus로 수정해줍니다. _config.yml123# Extensions## Themes: https://hexo.io/themes/theme: icarus 이렇게만 설정하고 배포하면 테마가 잘 설정된 모습을 볼 수 있다. 설정themes/icarus 폴더에 있는 _config.yml에서 테마 설정을 변경 할 수 있습니다.블로그 폴더에도 _config.yml에서 설정을 변경하였는데 테마 역시 _config.yml를 사용하여 설정하여 준다. 블로그 폴더의 _config.yml가 hexo블로그의 전반적인 설정 이라면themes/테마 폳더의 _config.yml는 hexo 블로그에 적용된 테마의 추가 설정이라고 보면된다.","link":"/2019/06/19/hexo-themes/"},{"title":"Github SSH key 생성 및 적용하기","text":"많은 Git 서버들은 SSH 공개키로 인증을 합니다. 또한 Github 연결시마다 계정정보를 입력해야 하는 번거로운을 제거해 준다. 이번에 입사한 회사에서도 서버에서 SSH를 사용해서 인증하는 시스템을 가지고 있어서 이 기회에 세팅을하면서 적용방법을 정리해 보았다. SSH 공개키 생성일단 공개키를 사용하려면 공개키를 만들어야 한다. 그 전에 공개키가 있는지 확인이 필요하다. 기본적으로 사용자의 SSH키들은 사용자의 ~/.ssh 디텍토리에 저장한다. 디텍토리의 파일을 살펴서 공개키가 있는지 확인 할 수 있다. 12cd ~/.sshls 보통 id_dsa나 id_rsa라고 되어 있다. 그 중 .pub 파일이 공개키이고 다른 파일은 개인키 입니다.이 파일이 없거나 .ssh 디텍토리가 없으면 ssh-keygen 프로그램으로 키를 생성하여 준다. 터미널 실행하여 다음 명령어를 실행1ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 적은 이메일을 레이블로 사용해서 새 SSH 키를 작성한다는 메세지가 출력됩니다.(아래와 같은 메세지가 나온다면 성공입니다.) 1> Generating public/private rsa key pair. SSH Key 저장위치 설정“키를 저정할 파일을 입력하십시오” 라는 프로프트가 표시되면 Enter를 누르십시오.(기본위치로 지정) 1> Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] SSH Key 비밀번호 설정비밀번호 없이 설정할경우 엔터 두번을 눌러주면된다. 12> Enter passphrase (empty for no passphrase): [Type a passphrase]> Enter same passphrase again: [Type passphrase again] SSH Key 등록생성한 SSH Key를 등록해 봅시다 터미널을 실행하여 아래 명령어를 실행하여 백그라운드에서 ssh-agent를 시작12eval \"$(ssh-agent -s)\"> Agent pid 59566 ssh의 config 파일에 아래 text를 입력1vi ~/.ssh/config Host * AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_rsa 아래 명령어를 입력하여 SSH Key 값을 ssh-agent에 추가1ssh-add -K ~/.ssh/id_rsa SSH Key를 Github 계정에 추가Github 로그인후 우측상단 메뉴에서 Setting을 클릭 좌측의 Personal settings 메뉴 중에 SSH and GPG keys 클릭 New SSH Key를 눌러서 Title과 Key를 입력후 Add SSH Key 버튼을 눌러준다. Key 에는 아래명령어를 사용해서 .pub 의 공개키를 입력해 준다. 1cat ~/.ssh/id_rsa.pub id_rsa.pub 예시ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@agadorlaptop.local Github SSH key 생성 및 적용하기를 해보았다. Github 연결시 계정정보를 입력해야 하는 번거로움에서 해방돠었다. SSH 연결 테스트SSH 를 연결하고 나서 직접 커밋하기 전에 테스트를 해보는 방법을 알아보았다. 연결테스트를 하기 전에 아래 작업들을 모두 완료해야한다. SSH 공개키 생성 SSH Key 등록 SSH Key를 Github 계정에 추가 먼저 터미널을 엽니다. 그리고 아래 문구를 입력해 줍니다. 1$ ssh -T git@github.com 그러면 아래와 같은 경고가 경고문구를 보실 수 있습니다. 123The authenticity of host 'github.com (IP ADDRESS)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 또는 123The authenticity of host 'github.com (IP ADDRESS)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 위의 같은 메시지중 하나와 일치하는지 확인 후 yes 를 입력해 줍니다. 아래와 같은 멘트가 나오면 성공입니다. 12Hi username! You've successfully authenticated, but GitHub does notprovide shell access. 자세한 내용은 아래 링크를 통해 확인 하실 수 있습니다.https://help.github.com/en/github/authenticating-to-github/testing-your-ssh-connection","link":"/2019/10/18/ssh-setting/"},{"title":"Hexo 블로그 Github를 이용해 만들어보기","text":"블로그를 만들고 꾸미다 보니 나같은 사탐들이 많을 거라는 생각에서Hexo를 이용해 Github 블로그 세팅 하는 방법들을 처음부터 하나씩 보고자 한다. Hexo우선 Hexo는 Node.js 기반의 정적 사이트 생성기(Static site generator)이다. 포스트의 경우 md파일로 작성이 가능하고 github를 이용하면 무료로블로그 운영이 가능하다. md로 작성하기 때문에 대부분에 IDE에서 작성하면서 미리보기를 할 수 있으며 node를 이용하면 로컬에서 확인 가능하다.공식 사이트에서는 빠르고 간단하고 파워풀한 블로그 프레임워크라고 소개하고 있다.npm을 통해 쉽게 설치가 가능하고 배포역시 쉽게 가능한 것이 장점이다.한글문서로도 잘 정리가 되어있어 참고하기 좋다. Hexo 한글 튜토리얼 설치 전 준비저는 Github를 이용하여 Hexo 블로그를 세팅 하려고 하기때문에 git, github, node 설치가 선행되어야 합니다. Git Node.js(npm) Github 계정 각각의 설치 방법들은 간단하고 잘 쓰여진 글들이 많으니 참고하시기 바랍니다. Hexo 설치하기node.js를 설치하면 사용 할 수 있는 npm을 이용해서 간편히 설치 할 수 있습니다. Hexo 전역에 설치1npm install hexo-cli -g 블로그 Setup아래 명령을 실행하여 간단하게 hexo를 초기화 할수 있습니다. bash123hexo init cd npm install 초기화가 완료되면 아래와 같은 구조로 세팅됩니다. 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 블로그 설정_config.yml이 root경로에 생성되는데 해당 파일을 통해서 블로그에 대한 설정을 세팅할 수 있습니다.자세한 설명은 Hexo의 Cofiguration을 통해 확인해 볼수 있다. Cofiguration : https://hexo.io/ko/docs/configuration 로컬테스트간단한 설정을 하고 나서 바로 로컬 서버에서 띄워 확인해 볼 수 있습니다. bash12hexo serverhexo s #단축명령어 서버가 구동되면 아래와 같은 문구가 출력되며 http://localhost:4000에서 확인 할 수 있습니다. 1Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. Github 블로그 호스팅Github에서 새로운 repository를 생성합니다.Repository name을 username.github.io의 형식으로 기재하고 public으로 만들어 줍니다. 설정하기_config.yml 에서 Deployment 항목을 설정해 준다. 12345# Deploymentdeploy: type: git repo: repository 주소 branch: master Github에 배포하기로컬에서 정상적으로 작동되었다면 hexo cli를 통해 Github에 쉽게 배포를 해보자. 정적리소스 생성bash12hexo generate hexo g #단축 명령어 public 폴더가 생성되어 배포가 가능하다. 배포하기bash12hexo deployhexo d #단축 명령어 배포 중 오류가 발생 하면 아래 이슈체크를 확인 Generate와 Deploy 동시실행아래와 같이 Generate와 Deploy를 동시실행 할 수도 있다. bash12345hexo deploy --generate #Deploy 전에 Generate를 해준다.hexo d -g #단축 명령어hexo generate --deploy #Generate 후에 Deploy를 해준다.hexo g -d #단축 명령어 https://username.github.io 로 접속하면 deploy된 사이트가 확인 가능하다. 이슈체크배포시 아래와 같은 에러가 발생하면1ERROR Deployer not found: git hexo-deployer-git 플러그인을 설치해준다. bash1npm install hexo-deployer-git --save 업데이트 시간혹 업데이트가 바로 이루어 지지 않을 경우에는 아래와 같이 public을 clean시켜준 후 배포를 하면 된다. bash12hexo cleanhexo d -g 글쓰기bash1hexo new post \\source_post 폴더에 포스트이름.md 으로 새로운 마크다운 파일이 생성됩니다.포스트내용을 작성한후에 다시한번 clean과 generate 그리고 deploy를 해주면 정상 반영된다. 이상으로 Hexo 블로그 만들기에 대한 포스팅을 마친다.잘못된 사항이나 궁금한 점은 댓글로 남겨주시면 감사하겠습니다.","link":"/2019/06/09/hexo-blog/"},{"title":"마크다운(Markdown) 사용법을 알아보자","text":"블로그를 hexo로 옮기게 되면서 가장 처음 접한 문제는 github 그리고 마크다운이었다.세팅은 여차저차 했지만 글 작성에서부터 막히기 시작했다.나와 같은 사람들을 위해 쉽게 마크다운 사용법을 정리해 보았다. 먼저 간단하게 마크다운에 대해 알아보고 넘아가겠습니다. 마크다운(Markdown) 마크다운(Markdown)은 일반 텍스트 문서의 양식을 편집하는 문법이다.README 파일이나 온라인 문서, 혹은 일반 텍스트 편집기로 문서 양식을 편집할 때 쓰인다.마크다운을 이용해 작성된 문서는 쉽게 HTML 등 다른 문서 형태로 변환이 가능하다.위키백과 마크다운의 장점과 단점 장점 문법이 쉽고 간결합니다. 별도의 도구가 필요없다. 지원하는 플랫폼과 프로그램이 다양하다. 다양한 형태로 변환이 가능하다. 단점 표준이 없고 그로인해 사용자마다 문법이 다르다. 모든 HTML 마크업을 대신 할 수 없다. 마크다운 문법(Syntax) 제목 (Header)HTML의 부터 으로 변환되며 제목을 표현할 때 사용합니다. .md123456# 제목1## 제목2### 제목3#### 제목4##### 제목5###### 제목6 수평선 (Horizontal rule)HTML의 태그로 변환됩니다.수평선을 표시하는 방법은 여러가지가 있다.각 기호를 3번 이상 입력하는 방법으로 사용한다. .md123--- (Hyphens)*** (Asterisks)___ (Underscores) 인용문구 (Blockquote)HTML의 태그로 변환됩니다.중첩해서 사용이 가능합니다.인용안에서 마크다운 문법을 사용할 수 있습니다. .md123> 안용문구를 나타낼때 사용합니다.>> 중첩해서 사용이 가능합니다.>>> ## 인용의 인용 인용구문을 나타낼때 사용합니다. 중첩해서 사용이 가능합니다. 인용의 인용 목록 (List)HTML의 ,, 태그로 변환됩니다. 순서있는 목록 (ol)순서있는 목록은 숫자와 점을 사용합니다. .md1231. 첫번째2. 두번째3. 세번째 *특이한 점은 어떤 번호를 입력해도 순서는 내림차순으로 정의가 된다. 순서없는 목록 (ul).md123- 대쉬 (hyphen)* 별표 (asterisks)+ 더하기 (plus sign) 강조 (Emphasis)HTML의 , , 태그로 변환됩니다.밑줄 은 태그를 사용하시면 됩니다. 1234이텔릭체: *텍스트* 또는 _텍스트_ 를 사용두껍게: **텍스트** 또는 __텍스트__ 를 사용취소선: ~~텍스트~~ 를 사용밑줄 은 태그를 사용 링크 (Link)HTML의 태그로 변환됩니다. .md123456[링크](링크주소)[링크](링크주소 \"링크설명- 생략가능\")문서안에서 [참조링크] 사용가능합니다.[참조링크노출설명][참조링크] 의 형태로 사용[참조링크]: 참조링크주소 \"링크설명 - 생략가능\" 이미지HTML의 태그로 변환됩니다.링크와 비슷하지만 앞에 !가 붙습니다. .md1![대체텍스트](링크 \"링크설명\") 이미지에 링크마크다운 이미지코드를 링크 코드로 묶어 줍니다. .md1[![대체텍스트](링크 \"링크설명\")](링크주소) HTML 코드 마크다운 문법 뿐 아니라 원시 HTML문법을 사용할 수 있습니다. 이상으로 마크다운 문법에 대해서 알아보았는데요 쉬운 면이 있으면서도처음 접하는 거라 그런지 낯선부분들도 있습니다.쓰다 보면 차차 익숙해지겠죠 ㅎㅎ 궁금하신 점이나 잘못된점은 언제든 댓글로 남겨주시면 감사하겠습니다.","link":"/2019/05/28/markdown/"},{"title":"Hexo 포스팅 방법","text":"이전 포스팅 에서 Hexo 블로그의 세팅 방법과 간단한 글쓰는 방법에 대해 다뤄보았는데요 Hexo는 간단한 포스팅 외에도다양한 기능의 포스팅 방법을 제공해 줍니다. Hexo에서 지원하는 것들은 무엇이 있는지 한번 살펴보겠습니다. 글쓰기(Writing) 일단 기본적인 명령어 부터 하나씩 살펴보겠습니다.hexo 명령어를 사용하여 새로운 포스팅의 마크다운 파일을 생성해 줍니다. 레이아웃은 생략해도 됩니다. bash 12hexo new hexo new # layout을 지정하지 않으면 기본으로 post을 생성합니다. 위 명령어를 실행하면 \\source_posts 폴더에 포스트이름.md 으로 새로운 마크다운 파일이 생성됩니다.파일명에 띄어쓰기가 있다면 하이픈(-)으로 표시됩니다. layout 에는 3종류가 있습니다. -post-draft-page 각기 다른 경로에 보관 됩니다. layout 경로 특징 post source/_posts 기본 레이아웃 draft source/_drafts 게시되지 않는 초안 page source 새로운 페이지를 작성 Post (포스트)기본 레이아웃으로 레이아웃 종류를 입력하지 않으면 자동으로 포스트로 인식합니다.기본 레이아웃의 변경은 _config.yml 의 default_layout 항목에서 변경 할 수 있습니다. bash 1hexo new post page (페이지)새글을 추가하는 것이아니라 별도의 페이지를 생성합니다. bash 1hexo new page draft (초안)포스트를 바로 발행 하는 것이 아닌 초안 형태로 저장한다. bash 1hexo new draft 기본 레이아웃 변경을 _config.yml 의 default_layout 항목에서 draft로 변경하면,hexo new 명령어 실행시 post가 아닌 draft로 생성됩니다. 초안으로 작성된 글은 로컬서버에서만 확인 할 수 있다. bash 1hexo server --draft 초안으로 작성된 글을 post로 변경할려면 수동으로 _posts폴더로 옮길 수도 있지만아래와 같은 hexo 명령어로 publish가 가능하다. bash 1hexo publish 스캐폴드 (Scaffolds) 포스트의 구조를 설정할때 사용합니다. Scaffolds폴더 안에 각 md파일을 수정하여 설정을 변경할 수 있습니다. /scaffolds/post.md12345---title: {{ title }}date: {{ date }}tags:--- 기본적인 구조는 위와 같이 되어있고 각 항목들을 추가하여 기본값을 설정해 줍니다.저 같은 경우에는 태그, 카테고리, 썸네일 등을 추가로 작성해 놓았습니다. /scaffolds/post.md1234567---title: {{ title }}date: {{ date }}categories:tags: [ ]thumbnail: /img/ --- 머리말 (Front matter) 머리말(Front matter)은 포스트 생성시 포스트 최상단에 자동으로 생성되며 해당 파일의 정보를 입력하는 곳입니다. 형태는 ---로 구분되어 있습니다. 항목사용하는 항목들을 스캐폴더에 미리 지정해 놓으면 편리하게 사용 할 수 있습니다.Docs : https://hexo.io/ko/docs/front-matter.html 설정 설명 기본값 layout 레이아웃 title 타이틀 date 발행일 파일이 생성된 날짜 updated 갱신일 파일이 업로드된 날짜 comments 포스트에서 comment 기능을 사용할지 여부 true tags 태그 (page에서는 사용 불가능) categories 카테고리 (page에서는 사용 불가능) permalink 포스트의 기본 permalink를 override합니다. 카테고리와 태그 (categories,tags)카테고리와 태그는 Post와 Draft에서만 사용 가능합니다. 카테고리를 여러가지 지정할 경우 분류와 하위 분류의 계층적인 관계를 가집니다. 즉 위에 있는게메인카테고리 아래에 있는게 서브카테고리가 됩니다. 태그는 순서와 상관없이 모두 같은 계층입니다. 여러개를 작성할 경우 아래와 같이 사용 할 수 있습니다. post.md1234567891011categories:- 카테고리이름- 서브카테고리이름tags:- 태그- 태그- 태그#또는 아래와 같이도 사용 할 수 있습니다.categories: [카테고리이름, 서브카테고리이름]tags:[태그, 태그, 태그] 머리말(Front matter)의 항목은 기본적으로 제공하는 것 외에 각 테마들마다 다양한 옵션들을 가지고 있습니다.자신에게 맞는 항목들을 찾아서 사용하시면 됩니다. 요약글기본적으로 요약글 형태로 보여줄수 있는 기능을 제공합니다. 을 사용해서 요약글을 만들수 있습니다. 테마에 따라 첫페이지에서 자동으로 요약글 형태로 만들어 주는 테마도 있지만 없는 경우에는 기능을 사용합니다.사용방법은 포스트 본문에 첫페이지에서 보여줄 부분 밑에 을 추가하면 read more 버튼이 생성되고 아래의 내용은 보여지지 않습니다. 포스트의 작성이 끝나면 Generate와 Deploy 실행하여 업데이트 해주면 된다.포스트의 적용이 바로 되지 않을 경우에는 Clean을 같이 실행 해준다. bash12hexo cleanhexo d -g","link":"/2019/06/10/hexo-writing/"},{"title":"[VScode] VScode Extension - 확장프로그램 추천 및 설치방법","text":"VScode는 비교적 가벼운 에디터 입니다. 기본적으로는 필수적인 기능들만을 제공 하고 있습니다.대신 마켓플레이스(Marketplace)를 통해서 많은 확장프로그램(Extension)들을 설치하여 즉시 사용 할수 있습니다.확장프로그램을 통해 보다 편리하게 코드를 작성 할 수 있습니다.그 중에서 많이 사용하는 것들을 한번 알아보겠습니다. 확장프로그램 찾아보기VScode 내에서 확장기능을 찾아서 설치할 수 있습니다. VScode를 실행하면 왼쪽에 여러가지 아이콘들이 있습니다.그 중에 가장 아래에 있는 네모모양의 아이콘 또는 명령어(Ctrl+Shift+X)를 실행하여 확장프로그램들을 확인할 수 있습니다. * 검색창의 검색을 통해서 간단하게 설치 할수 있습니다. 확장프로그램 리스트 (Extension List)Korean Language Pack for Visual Studio CodeKorean Language Pack for Visual Studio Code는 VScode의 언어의 한국어 팩입니다. VScode의 언어를 한국어로 변경해 줍니다. Git HistoryGit history는 Git으로 관리되는 프로젝트의 Git log. file History, branch, commit 등을 편리하게 확인 할수 있는 확장프로그램입니다.파일을 열고 F1키를 누르고 Git: View History, Git: View File History, Git: View Line History를 입력하여 사용합니다. Active File In StatusBarActive File In StatusBar는 Vscode 상태 표시 줄에 현재 활성 파일의 전체 경로를 표시하는 확장 프로그램입니다.현재 활성 파일의 경로를 하단 상태 막대에 표시합니다. 이 경로를 클릭하면 클립보드에 복사하여 사용 할수 있습니다. Auto Rename TagAuto Rename Tag는 HTML/XML 태그의 이름을 자동으로 바꿉니다. GuidesGuides은 안내선을 표시해 주는 확장프로그램입니다. indent-rainbowindent-rainbow는 텍스트 앞의 들여쓰기를 각 단계에서 네가지 색상으로 번갈아 보여주어 들여쓰기를 보다 쉽게 읽을 수 있게 해주는 확장프로그램입니다. Rainbow BracketsRainbow Brackets은 괄호(bracket)마다 다른 컬러를 제공합니다. Settings SyncSettings Sync는 Github Gist를 사용하여 VScode의 설정(확장플러그인 포함)을 동기화 시켜주는 도구 입니다. Waka TimeWaka Time은 VScode에서 어떤 프로젝트에서 어떤 언어로 작성했는지 그에 따른 비율 시간을 측정하여 줍니다.별도의 회원가입이 필요합니다. VScode 플러그인에 API kye를 입력해서 사용합니다. 위의 확장프로그램들은 제가 사용하는것 위주로 정리하였습니다. 추천 프로그램 있으면 댓글로 남겨주세요^^","link":"/2019/06/24/vscode-extension/"},{"title":"[VScode] Visual Studio Code에서 터미널을 git bash 기본으로 설정하기","text":"Visual Studio Code(이하 VScode)에서 터미널을 같이 사용 할수 있습니다. 별도의 창으로 작업을 하면 비효율 적이기도 하고 탭을 계속해서 눌러주어야 하는 불편함을 감수해야 합니다.VScode의 기본 터미널 사용값은 powershell입니다. 설정변경을 통해서 gitbash를 사용 할 수 있습니다. git bash로 변경하는 방법VScode를 실행해서 ctrl + , 를 눌러 설정에 들어갑니다. 설정 검색칸에 terminal.integrated.shell.windows를 입력합니다. 위와 같이 검색결과가 뜹니다.settings.json에서 편집을 누릅니다. settings.json 편집아래와 같이 문구를 추가해 줍니다. settings.json12345678910{ \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\", \"workbench.startupEditor\": \"newUntitledFile\", \"editor.renderIndentGuides\": false, \"editor.minimap.enabled\": false, \"editor.renderWhitespace\": \"boundary\", \"window.zoomLevel\": 0, \"workbench.iconTheme\": \"vscode-icons\", \"files.autoGuessEncoding\": true} \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\"에는 설치경로가 다르다면 자신의 git 설치경로를 입력해 줍니다. 저장을 해주고 ctrl+shift+` 을 눌러서 새 터미널을 열어 확인합니다.바로 반영이 안되면 VScode를 한번 껏다가 켜줍니다. 터미널 단축키 바꾸기터미널 단축키를 편하기 변경 할 수 있습니다.ctrl + k , ctrl + s 눌러서 바로 가기 키 설정에 들어갑니다. 검색창에 터미널을 검색합니다.더블클릭하면 새로운 단축키를 설정할 수 있습니다.","link":"/2019/06/24/vscode-gitbash/"},{"title":"webstorm에서 gitflow 사용하기","text":"vscode 에서 webstorm으로 갈아타면서 플러그인으로 사용하던 몇가지 기능들을 webstorm 에서도 사용해 보고 싶었습니다.그중에 git 을 사용하다 보면 대부분의 경우 git-flow 를 따라서 작업을 진행하게 됩니다. 물론 cli 를 이용해서정책만을 따라 가며 작업할 수 있지만 번거로운 작업들도 있고 급할때는 까먹기도 하기 때문에 편하게 사용하는 방법을 찾아보았습니다.IntelliJ Git Flow Integration를 이용한 방법입니다. gitflow 설치그전에 gitflow 를 사용할때는 별도로 gitflow 를 설치하지 않았었는데 webstorm에서 gitflow 를 사용하려면 avh 버전으로 설치가 필요하다.mac OS의 경우 homebrew 를 통해 gitflow 를 설치해줍니다. 1brew install git-flow-avh 다른 OS 환경에서의 설치 방법은 링크를 참고하세요 gitflow 를 설치하고 나면 preferences > plugins > marketplace 에서 Git Flow Integration 를 검색하여 설치해 줍니다. Webstorm을 재시작하면 설치가 완료됩니다. 사용플러그인 설치 후 webstorm 우측 하단을 보시면 아래그림과 같이 No Gitflow 를 보이시면 정상적으로 설치가 완료된것입니다. No Gitflow 를 클릭하셔셔 init Repo 를 선택하면 아래와 같은 설정화면이 나옵니다. 기본 옵션이 git-flow 규칙을 따라 설정되어있어서 똑같은 규칙으로 사용하시다면 별도의 수정없이 OK 눌러 주시면됩니다. 기본 옵션을 설정하고 나면 No gitflow 에서 gitflow 로 변경되고 gitflow 를 클릭하면 원하시는 동작을 할 수 있습니다. Start Feature를 눌러 feature 브런치를 생성하고 finish feature를 하면 자동으로 develop 브런치에 merge 가 이루어집니다.Git flow 전략에 따라 버튼만 선택해주면 모든 이벤트가 자동으로 진행됩니다. 별도로 브랜치를 체크아웃하면서 merge, remove, tag 등을 할 필요가 없어서 반복작업의 시간을 줄일 수 있습니다. merge의 기본옵션은 fast-forward 입니다. 이를 변경하여 merge도 하나의 커밋으로 취급하고 싶으신 분들은 prefereces > Other Settings >gitflow 에서 Do not fast-forward when merging, always create commit(–no-ff) 옵션에 체크 하시면됩니다. ReferenceGit Flow Integration으로 Git Flow 심플하게 운영하기Git Flow IntegrationGitflow로 branch를 관리하자!!","link":"/2020/03/30/webstorm-gitflow/"},{"title":"webstorm 과 jira 연동해서 사용하기","text":"webstorm을 사용하고 업무를 진행할 때 jira를 사용하다보니 jira를 별도의 창으로 띄워놓고 이슈를 생성하고, webstorm에서 작업하다가 커밋하면서jira 티켓번호 생성하고 푸시한 다음에 티켓을 이동시켜주고 하는 반복작업이 많아졌습니다. 어떻게 보면 별거아닌 작업일 수 있지만 까먹게 되는 일이많고 바쁠때는 모아서 하기도 하다보니 이슈 트레킹 하는데 문제가 있어보여 찾아보다가 연동하는 방법을 찾아 정리해 보았습니다. 단축키는 Mac OS를 기준으로 정리하였습니다. 설정webstorm에서 preferences > Tasks > Servers 로 이동합니다. 화면에서 + 버튼을 클릭해서 JIRA를 선택합니다. JIRA 외에 다른 이슈 트레커들도 연동해서 사용할 수 있습니다. JIRA 버튼을 누르면 설정창이 뜨는데 설정창에서 Server URL 에는 JIRA 주소를 입력합니다. 그리고 계정/비밀번호를 입력해 줍니다.저는 회사계정으로 입력했더니 비밀번호 입력하는 칸이 API Token 을 입력하는 칸으로 변경되더라구요. API 토큰 생성 방법은 atlassian 사이트를 참고 하셔서 발급 받으시면됩니다. -사이트 링크API token은 한번 발급 받으면 다시 볼수 없으니 계속해서 사용하고 싶으시면 개인저장소에 저장해놓거나 잃어버리면 새로 발급 받아야합니다. Search 입력란은 Task 목록을 방식을 설정하는 방식을 이야기하는데 기본값으로 최신정렬순으로 되어있으니 필요하신분만 수정하시면 됩니다. 설정이 끝나면 우측 하단에 있는 Test 버튼을 클릭하여 테스트를 해볼수 있습니다. Connection is successful 이라는 메세지가 나오면 됩니다.그리고 나서 Apply > OK 눌러주시면 설정은 끝났습니다. 사용사용해본 결과 현재(2020.03.30일 기준 2019.3 버전) webstorm에서는 JIRA 티켓 생성은 지원하고 있지 않았습니다.기존에 되어있는 티켓을 Task 가져오는게 아니라면 티켓 생성은 JIRA 사이트에서 해주어야 합니다. Tools > Tasks & contexts > Open Task 로 본인에게 할당된 티켓 목록을 볼 수 있습니다. 단축키는 option+shift+n 입니다. 테스트를 위해 티켓을 별도로 하나 생성했습니다. FE-66 티켓을 선택해 주면 아래와 같은 창이 열립니다.update issue state는 티켓의 state를 원하는 상태로 변경할 수 있습니다. clear current context는 현재 편집기에 열려있는 모든 탭을 닫습니다.create branch 를 하면 원하는 브런치를 생성 할수도 있고, gitflow 메뉴를 이용하면 gitflow 정책대로 브런치를 생성 할 수도 있습니다.gitflow 정책에 대해서는 지난 블로그 내용을 참고 바랍니다. webstorm에서 gitflow 사용하기 개발이 완료되면 커밋을 해줍니다. 단축키는 command+k 입니다. 커밋 메세지는 자동생성되는데 기본 옵션으로 티켓ID + 제목 으로 되어있고 설정을 변경할 수 있습니다.Preferences > Tasks > Servers Commit Message 탭을 클릭해서 원하는 규칙으로 수정 할 수 있습니다. 티켓 상태도 상황에 맞게 변경 할 수 있습니다. 단축키는 option+shift+w 입니다. 추가 설정기본적으로 Task에서 생성해주는 브랜치 명은 티켓ID 로 자동할당됩니다. 생성 템플릿을 변경하려면Preferences > Tasks에서 Feature branch name format을 원하는 규칙으로 수정하면됩니다. ReferenceIntelliJ를 JIRA와 연동해서 사용하기IntelliJ IDEAAPI tokens","link":"/2020/03/30/webstorm-jira/"},{"title":"Mac os에 zsh 세팅하기","text":"이번에 직장을 옮기면서 맥북 유저로 돌아왔다. 퍼블리싱작업을 할때는 별로 신경쓰지 않았던 작업환경들이 개발을 하게되고 맥북을 가지면서 조금더 편한 것들을 찾게 되었다. 그중에 하나로 zsh을 적용해 보았다. ZSH 란? Z 셸(Z shell, zsh)은 상호작용 로그인 셸이자 셸 스크립트를 위한 강력한 명령 줄 인터프리터로 사용할 수 있는 유닉스 셸이다.Zsh는 bash, ksh, tcsh의 일부 기능을 포함하여 수많은 개선 사항이 갖추어진 확장형 본 셸이다. 위키백과 ZSH 기능 살펴보기 경로 자동 추론 타이핑 교정 명령어 추천 다양한 플러그인 이쁜 디자인이 핵심이다 ㅋㅋㅋ 개발속도를 올려줄 수 있는 간편한 기능들이 많이 있다. ZSH 설치본격적으로 ZSH를 설치 해보자먼저 macOS 용 패키지 관리자인 Homebrew를 설치한다.설치방법은 Homebrew 사이트에 자세히 나와있으니 이번 포스팅에서는 생략한다. 먼저 아래 명령으로 zsh 가 설치되어있나 확인작업을 해준다. 12zsh --versionzsh 5.7.1 설치되어 있지 않다면 아래의 명령으로 설치를 해준다. 1brew install zsh 설치가 끝났다면 기본 쉘을 chsh을 사용하여 변경해준다. 1chsh -s `which zsh` Oh My ZshOh My Zsh는 ZSH 구성 관리를 위한 오픈 소스 커뮤니티 중심 프레임 워크 입니다. 여기에는 수천가지의 유용한 기능, 도우미, 플러그인, 테마 및 몇가지 소리가 제공됩니다. curl1$ sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" wget1sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" ZSH 설치가 완료되었다. 이렇게만 설치하고 사용하여도 상관없지만 이왕 설치한 김에 몇가지 편리한 기능들을 추가로 세팅해보기로 했다. iTerm2 설치iTerm2는 터미널의 부족한 기능들을 보안해주는 터미널 에뮬레이터이다. iTerm2에서 제공하는 많은 기능들 중에 유용한 기능들은 아래와 같다. 자동완성 기능 (Cmd + ;) 터미널 분할 창 기능 (Split Panes) 터미널 내에서 찾기 기능 마우스 없이 복사와 붙여넣기 더 많은 기능 살펴보기 : https://www.iterm2.com/features.html iTerm2 설치는 iTerm2홈페이지에서 다운로드 받은 후에 프로그램을 어플리케이션으로 옮겨주기만 하면된다. iTerm2 테마설치(선택)iTerm Color Schemes에 접속하여 컬러 스킨을 다운로드 받는다.다운을 받으면 iTerm2를 실행하여 cmd + ,를 눌러서 환경설정 창을 띄워준다. Profile > colors 메뉴에 들어가서 Color Presets를 눌러서 하단의 imports를 누른다. 다운로드 받은 폴더 schemes의 테마 중 원하는 테마를 선택한다.(취향존중) ZSH 테마 설치많은 테마들 중에 필자는 Spaceship ZSH 테마를 설치해 보았다. 아래 명령어를 사용해서 설치를 진행한다. 1234# 복사git clone https://github.com/denysdovhan/spaceship-prompt.git \"$ZSH_CUSTOM/themes/spaceship-prompt\"# 심볼릭링크(심볼릭 링크는 원본파일을 가리키도록 링크만 시켜둔 것 - 윈도우의 바로가기)ln -s \"$ZSH_CUSTOM/themes/spaceship-prompt/spaceship.zsh-theme\" \"$ZSH_CUSTOM/themes/spaceship.zsh-theme\" .zshrc 파일에서 ZSH_THEME 내용을 변경해준다. 12vi ~/.zshrc또는 open ~/.zshrc 해당 내용을 실행 1source ~/.zshrc 이렇게 테마 적용시 폰트가 깨져서 원하던 모습을 볼수 없을 경우 폰트 설치를 진행하여 준다. Powerline fonts 설치자세한 설치 방법은 Powerline fonts을 참고 하기 바라며 간단한 설치 방법을 공유 합니다. 12345678# 복사git clone https://github.com/powerline/fonts.git --depth=1# 설치cd fonts./install.sh# 지우기cd ..rm -rf fonts 설치가 완료되면 아까와 같이 iTerm2 에서 설정을 cmd + ,를 눌러 환경설정에서 Profiles > Text 에서 Powerline폰트를 선택주면된다.ZSH로 터미널과 조금 더 친해져 보자~!!","link":"/2019/09/27/zsh-setting/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 14. 비동기적 프로그래밍","text":"사용자의 행동은 전적으로 비동기적이다. 사용자가 언제 클릭할지, 터치할지, 또는 타이핑 할지 프로그래머는 전혀 알수 없기 때문이다. 하지만 비동기적 실행이 사용자입력 하나 때문에 필요한 것은 아니다. 자바스크립트 애플리케이션은 단일 스레드에서 동작한다.즉 자바스크립트는 한 번에 한가지 일만 할 수 있다. 이러한 자바스크립트의 본질 때문에 비동기적 프로그램밍이 필요하다. 자바스크립트에는 매우 일찍부터 비동기적 실행 메커니즘이 존재 했지만, 자바스크립트의 인기가 높아지고 소프트웨어가 복잡해짐에 따라 비동기적 프로그래밍에 필요한 장치들이 추가 되었다. 자바스크립트의 비동기적 프로그래밍에는 뚜렷이 구분되는 세가지 패러다임이 있습니다.처음에는 콜백 그 뒤로 프라미스 마지막은 제너레이터 입니다. 제너레이터 자체는 비동기적 프로그래밍을 전혀 지원하지 않는다.제너레이터를 비동기적으로 사용하려면 프라미스나 특수한 콜백과 함께 사용해야 한다. 사용자 입력 외에, 비동기적 테크닉을 사용해야 하는 경우는 크게 세가지가 있다. Ajax 호출을 비롯한 네트워크 요청파일을 읽고 쓰는 등의 파일시스템 작업의도적으로 시간 지연을 사용하는 기능(알람 등) 비유어떤 음식점은 당신이 줄을 서서 기다리지 않도록, 당신의 전화번호를 받아서 자리가 나면 전화를 해줍니다. 이런 음심적은 콜백과 비슷하다. 자리가 나면 당신이 알 수 있도록 하는 수단을 당신이 음식점 주인에게 넘겨준다. 음식점은 다른 손님을 대접하면 되고 당신은 다른 일을 하면된다. 어느쪽도 서로를 기다리지 않는다. 다른 음식점은 자리가 났을 때 진동하는 호출기를 당신에게 넘겨준다. 이런 음식점은 프라미스와 비슷하다.자리가 나면 당신이 알수 있도록 하는 수단을 음식점에서 당신에게 넘겨준다. 콜백콜백은 자바스크립트에서 가장 오래된 비동기적 메커니즘이다. 콜백은 간단히 말해 나중에 호출할 함수이다.콜백 함수 자체에는 특별할 것이 전혀 없다. 콜백 함수도 일반적인 자바스크립트 함수일 뿐이다.콜백함수는 일반적으로 다른 함수에 넘기거나 객체의 프로퍼티로 사용한다. 드물게는 배열에 넣어서 쓸 때도 있다.항상 그런건 아니지만 콜백은 보통 익명 함수로 사용한다. 비동기적 실행의 가장 큰 목적이자 중요한 요점은 어떤 것도 차단하지 않는다는 것이다.자바스크립트는 싱글 스레드를 사용하기 때문에 우리가 컴퓨터에 60초동안 대기한 후 코드를 실행하라고 지시한다면 그 실행이 동기적으로 이루어 진다면 프로그램이 멈추고 사용자 입력을 받아들이지도 않고 화면도 업데이트 하지 않을것이다.비동기적 테크닉은 프로그램이 이런 식으로 멈추는 일을 막아준다. 오류 우선 콜백콜백을 사용하면 예외 처리가 어려워지므로 콜백과 관련된 에러를 처리할 방법의 표준이 필요했다.이에 따라 나타난 패턴이 콜백의 첫 번째 매개변수에 에러 객체를 쓰자는 것이었다.에러가 null이나 undefined이면 에러가 없는 것입니다.오류 우선 콜백을 다룰 때 가장 먼저 생각할 것은 에러 매개변수를 체크하고 그에 맞게 반응하는 겁니다. 노드에는 파일 콘텐츠를 읽는다고 할 때 오류 우선 콜백을 사용한다면 다음과 같다. 1234567const fs = require('fs');const fname = 'may_or_may_nor_exist.txt';fs.readFile(fname, function(err, data){ if(err) return console.error(`error reading file $(fname): ${err.message}`); console.log(`$(fname) contents: $(data)`);}) 콜백에서 가장 먼저 하는 일은 err이 참 같은 값인지 확인 하는 것이다.err이 참 같은 값이라면 파일을 읽는 데 문제가 있다는 뜻이므로 콘솔에 오류를 보고하고 즉시 빠져나온다.오류 우선 콜백을 사용할 때는 에러 객체를 체크해야 하고, 빠져 나와야 한다는 사실을 기억해야 한다.콜백을 사용하는 함수는 대개 콜백이 성공적이라고 가정하고 만들어 진다. 그런데 콜백이 실패 했으니 빠져나가지 않으면 오류를 예약하는 것이나 다름 없다.물론, 콜백을 만들 때 실패하는 경우도 염두에 두고 만들었다면 에러를 기록 하기만 하고 계속 진행해도 된다.프라미스를 사용하지 않으면 오류우선 콜백은 노드 개발의 표준이나 다름 없다. 콜백 헬콜백을 사용해 비동기적으로 실행할 수 있긴 하지만 현실적인 단점이 있다. 한 번에 여러가지를 기다려야 한다면 콜백을 관리하기가 상당히 어려워진다. 중괄호에 둘러싸여 끝없이 중청된 삼각형의 코드 블록들을 프로그래머들은 콜백 헬이라고 부른다. 가장 골치 아픈것은 에러 처리이다. 비동기적 코드가 늘어나면 늘어날수록 버그가 없고 관리하기 쉬운 코드를 작성하기는 매우 어렵다 그래서 프라미스가 등장했다. 프라미스프라미스는 콜백의 단점을 해결하려는 시도 속에서 만들어졌다.프라미스가 콜백을 대체하는 것은 아니다. 사실 프라미스에서도 콜백을 사용한다.프라미스는 콜백을 예측 가능한 패턴으로 사용 할수 있게 하며, 프라미스 없이 콜백만 사용했을 때 나타날수 있는 엉뚱한 현상이나 찾기 힘든 버그를 상당수 해결한다. 프라미스의 기본 개념은 프라미스 기반 함수를 호출하면 그 함수는 Promise 인스턴스를 반환한다.프라미스는 성공(resolve)하거나 실패(reject)하거나 단 두가지 뿐이다.프라미스는 성공 혹은 실패 둘 중 하나만 일어난다고 확신할 수 있다.성공한 프라미스가 나중에 실패하는 일 같은건 절대 없다. 또한 성공이든 실패든 단 한번만 일어난다.프라미스가 성공하거나 실패하면 그 프라미스를 결정 됐다고 한다. 프라미스는 객체이므로 어디든 전달할 수 있다는 점도 콜백에 비해 간편한 장점이다.비동기적 처리를 여기서 하지 않고 다른 함수에서 처리하게 하고 싶다면 프라미스를 넘기기만 하면 된다. 프라미스 만들기프라미스는 쉽게 만들 수 있다.resolve와 reject 콜백이 있는 함수로 새 Promise 인스턴스를 만들기만 하면 된다. 프라미스 사용프라미스는 비동기적 작업이 성공 또는 실패하도록 확정하는 매우 안전하고 잘 정의된 매커니즘을 제공하지만 현재는 진행 상황을 전혀 알려주지 않는다. 즉 프라미스는 완료되거나 파기 될뿐 ‘50% 진행됐다’ 라는 개념은 아예 없다.Q 같은 프라미스 라이브러리에는 진행 상황을 보고하는 기능이 있고 나중에 언젠가는 도입될 수도 있지만 지금 당장은 없다. 이벤트이벤트는 자바스크립트에서 자주 사용된다. 이벤트의 개념은 간단하다.이벤트가 일어나면 이벤트 발생을 담당하는 객체에서 이벤트가 일어났음을 알린다,필요한 이벤트는 모두 주시 할수 있다.(콜백을 통해서) 프라미스 체인프라미스에는 체인으로 연결 할수 있다는 장점이 있다. 즉, 프라미스가 완료되면 다른 프라미스를 반환하는 함수를 즉시 호출 할수 있다. 프라미스 체인을 사용하면 모든 단계에서 에러를 캐치할 필요는 없다. 체인 어디에서든 에러가 생기면 체인 전체가 멈추고 catch핸들러가 동작한다. 결정되지 않는 프라미스 방지하기프라미스는 비동기적 코드를 단순화하고 콜백이 두 번 이상 실행되는 문제를 방지한다.하지만 resolve나 reject를 호출하는 걸 잊어서 프라미스가 결정되지 않는 문제까지 자동으로 해결하지는 못한다.에러가 일어나지 않으므로 찾기 매우 어렵다. 복잡한 시스템에서 결정되지 않은 프라미스는 그냥 잊혀질 수 있다. 결정되지 않는 프라미스를 방지하는 한 가지 방법은 타임아웃을 거는 것이다.출분한 시간이 지났는데도 프라미스가 결정되지 않으며 자동으로 실패하게 만들 수 있다. 프라미스에 타임아웃을 거는 함수123456789101112131415161718function addTimeout(fn, timeout){ if(timeout === undefined) timeout = 1000; //타임아웃 기본값 return function(...args){ return new Promise(function(resolve, reject){ const tid = setTimeout(reject, timeout, new Error(\"promise timed out\")); fn(...args) .then(function(...args){ clearTimeout(tid); resolve(...args); }) .catch(function(...args){ clearTimeout(tid); reject(...args) }); }); }} 프라미스를 반환하는 함수를 호출하는 프라미스를 반환하는 함수를 반환하는 함수 ??프라미스에 타임아웃을 걸기 위해서는 함수를 반환하는 함수가 필요하다. 제너레이터제너레이터는 원래 동기적인 성격을 가졌지만 프라미스와 결합하면 비동기 코드를 효율적으로 관리 할 수 있다.비동기 코드에서 가장 어려운 부분은 동기적인 코드에 비해 만들기가 어렵다는 점이다. 프로그램에서 어떤 부분을 동시에 실행할 수 있고 또 어떤 부분은 동시에 실행 할수 없는지 판단하는 것이 중요하다. 제너레이터 실행기와 예외처리제너레이터 실행기를 쓰면 try/catch를 써서 예외 처리를 할수 있다는 것도 중요한 장점이다.콜백이나 프라미스를 사용하면 예외 처리가 쉽지 않다. 콜백에서 일으킨 예외는 그 콜백 밖에서 캐치할 수 없다.제너레이터 실행기는 비동기적으로 실행하면서도 동기적인 동작 방식을 유지하므로 try/catch문과 함께 쓸수 있다. 요약 자바스크립트의 비동기적 실행은 콜백을 통해 이루어진다.프라미스를 콜백 대신 사용할수 잇는건 아니다. 프라미스 역시 콜백을 사용한다.프라미스는 콜백이 여러번 호출되는 문제를 해결했다.콜백을 여러번 호출해야 한다면 이벤트와 결합하는 방법을 생각 할수 있다.(프라미스도 함께 쓸 수 있다.)프라미스는 반드시 결정된다는 보장은 없다. 프라미스의 타임아웃을 걸어 이문제를 해결 할수 있다.프라미스는 체인으로 연결할 수 있다.프라미스와 제너레이터 실행기를 결합하면 비동기적 실행의 장점을 그대로 유지하면서도 동기적인 사고방식으로 문제를 해결할 수 있다,제너레이터를 써서 동기적인 사고방식으로 문제를 해결할 때는 프로그래의 어느 부분을 동시에 실행 할수 있는지 잘 살펴야 한다. 동시에 실행 할수 있는 부분은 Promise.all을 써서 실행해라제너레이터 실행기를 직점 만드는 고생을 하지말고 co나 Koa를 써라노드 스타일 콜백을 프라미스로 바꾸는 고생도 필요없다 Q를 써라제너레이터 실행기를 쓰면 예외 처리도 익숙한 방식으로 할 수 있다.","link":"/2019/08/03/Learning-JavaScript-chapter14/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 5. 표현식과 연산자","text":"이번 챕터에서는 표현식과 연산자에 대해 알아보는 챕터였다. 실습보다는 이론적인 부분들이 많았다. 표현식값으로 평가될 수 있는 문 즉 결과가 값인 문과, 표현식이 아닌 문의 차이를 이해한다.표현식이 아닌 문은 일종의 지시라고 생각 할 수있고, 표현식은 무언가를 요청하는 것이라고 생각 할 수 있다. 표현식은 값이 된다. 그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있다. 그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있다. 표현식이 아닌 문은 이런 식의 결합을 할 수 있다. 표현식은 값이 되므로 할당에 쓸 수 있다. 즉 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다. 연산자표현식이 값이 되는 것이라면 연산자는 값을 만드는 행동이라는 뜻이다.연산자는 하나 이상의 피연산자가 있어야 결과를 낼 수 있다. 피연산자를 매개변수라 부르는 경우도 있다. 산술 연산자 연산자 설명 예제 + 덧셈(문자열 병합에도 쓰임) 3 + 2 5 - 뺄셈 3 - 2 1 / 나눗셈 3/2 1.5 * 곱셈 3*2 6 % 나머지 3%2 1 - 단항 부정 -x x의 부호를 바꿉니다. x가 5이면 -x는 -5입니다. + 단항 플러스 +x x가 숫자가 아니면 숫자로 변환을 시도합니다. ++ 전위 증가 ++x x에 1을 더한 다음 평가합니다. ++ 후위 증가 x++ x를 평가한 다음 1을 더합니다. – 전위 감소 –x x에서 1을 뺀 다름 평가합니다. – 후위 감소 x– x의 값을 평가한 다음 1을 뺍니다. 뺄셈과 단항 부정은 같은 -기호를 사용단항 부정이 먼저 이루어지고 그 다음에 뺄셈을 한다.나머지 연산자는 나눗셈을 한 나머지를 반환 증가연산자(++),감소연산자(–) 할당 연산자와 덧셈연산자,뺄셈 연산자를 하나로 합친거나 다름없다.전위와 후위의 차이의 이해가 필요하다. 전위 연산자는 먼저 변수의 값을 바꾼 다음에 평가, 후위 연산자는 값을 바꾸기 전에 평가한다. 연산자 우선 순위현재 자바스크립트에는 56개의 연산자가 있고, 우선순위를 기준으로 19개의 그룹으로 묶을 수 있다.우선순위가 같은 연산자들은 오른쪽에서 왼쪽으로 또는 왼쪽에서 오른쪽으로 평가한다. 비교연산자비교연산자는 이름처럼 두 개의 값을 비교한다.일치함(===), 동등함(==), 관계연산자 이렇게 세가지 타입으로 나뉜다. 두 값이 같은 개체를 가리키거나, 같은 타입이고 값(원시타입)도 같다면 이 값을 일치한다고 한다.두 값이 같은 개체를 가리키거나, 같은 값을 갖도록 변환할 수 있다면 두 값을 동등하다고 한다.관계연산자에는 작다(=) 네가지가 있다. 숫자비교 특별한 숫자형 값 NAN은 그 자신을 포함하여 무엇과도 같지 않다.숫자가 NAN인지 알아보려면 내장된 isNAN 함수를 사용해야한다.자바스크립트의 숫자는 모두 더블 형식이다. 문자열 병합 +연산자는 덧셈과 문자열 병합에 모두 사용자바스크립트는 피연산자의 타입을 보고 덧셈을 할지 문자열 병합을 할지 판단덧셈과 문자열병합은 모두 왼쪽에서 오른쪽으로 평가합니다.평가후 피연산자 중 하나라도 문자열이면 문자열 병합을 수행두 값이 모두 숫자형이면 덧셈을 수행 논리연산자불리언 값만 다룰 수 있다. - true, false참 같은 값과 거짓 같은 값 - truthy, falsy 자바스크립트의 거짓 같은 값undefinednullfalse0 NAN‘’(빈문자열) 위의 6가지 외에는 모두 참 같은 값이다. 참 같은 값 몇 가지 예시모든 객체, valueOf() 메서드를 호출했을때 false를 반환하는 객체배열,빈 배열 - 공백만 있는 문자열문자열 “false” AND, OR, NOTAND(&&) 연산의 진위표 x y x && y false false false false true false true false flase true true true AND 연산은 피연산자가 모두 true일때만 true OR(||) 연산의 진위표 x y x II y false false false false true true true false true true true true OR 연산은 피연산자가 모두 false일때만 false NOT(!) 연산의 진위표 x !x false true true false NOT연산은 피연산자를 반대로 바꿈 단축평가x && y 에서 x가 거짓 같은 값이면 y의 값을 평가할 필요없이 false이다.x || y 에서 x가 참 같은 갑이면 y를 평가할 필요없이 true이다.이러한 방식으로 동작하며 이를 단축평가 라고 한다. 단축평가가 중요한 이유는 두번째 피연산자에 부수효과가 있다 하더라고단축평가를 거치면 그 효과는 일어나지 않기 때문이다. 피연산자가 불리언이 아닐때 논리 연산자가 동작하는 방법불리언 피연산자를 사용하면 논리 연산자는 항상 불리언을 반환한다.피연산자가 불리언이 아니라면 결과를 결정한 값이 반환된다. 불리언이 아닌 피연산자에 대한 AND(&&)의 진위표 x y x && y 거짓 같은 값 거짓 같은 값 x (거짓 같은 값) 거짓 같은 값 참 같은 값 x (거짓 같은 값) 참 같은 값 거짓 같은 값 y (거짓 같은 값) 참 같은 값 참 같은 값 y (참 같은 값) 불리언이 아닌 피연산자에 대한 AND(&&)의 진위표 x y x II y 거짓 같은 값 거짓 같은 값 y (거짓 같은 값) 거짓 같은 값 참 같은 값 y (참 같은 값) 참 같은 값 거짓 같은 값 x (참 같은 값) 참 같은 값 참 같은 값 x (참 같은 값) 결과를 불리언으로 변환하면 불리언 값을 제공했을 때의 진위표와 같은 결과가 된다. 조건연산자자바스크립트의 유일한 3항 연산자피연산자 세개를 받습니다. 1조건식 ? 조건식이 ture일때 반환할 값 : 조건식이 false일때 반환할 값 쉼표연산자쉼표연산자는 표현식을 결합하여 두 표현식을 평가하 후, 두 번째 표현식의 결과를 반환한다.표현식을 하나 이상 실행해야 하지만 값으로 필요 것은 마지막 표현식의 결과 뿐일 때 쉼표 연산자를 유용하게 쓸 수 있다. 그룹연산자그룹연산자()에는 아무 효과도 없지만 연산자 우선 순위를 높이거나 명확히 표현하는데 쓸 수 있다.연산 순서만 바꿀 뿐 다른 부작용은 없다. 비트연산자typeof연산자typeof연산자는 피연산자의 타입을 나타내는 문자열을 반환한다.자바스크립트의 일곱가지 데이터 타입을 정확히 나타내지 못한다. (null을 “object”로 판단) void연산자피연산자를 평가한 후 undefined를 반환한다. 할당연산자변수에 값을 할당한다.등호에 왼쪽에 잇는 것은 반드시 변수나 프로퍼티, 배열 요소 중 하나여야 한다.(상수에 값을 할당 하는 것은 엄밀히 말하면 선언이다.)즉 표현식의 왼쪽에 있는 것은 반드시 값을 저장 할 수 있는 것이어야 한다. 간편할당연산자연산과 할당을 한꺼번에 수행한다. 연산자 동등한 표현 x += y x = x + y x -= y x = x - y x *= y x = x * y x /= y x = x / y x %= y x = x % y x > y x >>>= y x = x >>> y x &= y x = x & y x I= y x = x I y x ^= y x = x ^ y 해체할당ES6에 새로 도입객체나 배열을 변수로 해체 할 수 있다. 해체할당123456789//객체선언cosnt obj = { b:2, c:3, d:4 }//해체할당const {a,b,c} = obj;a; //undefined : obj에는 \"a\" 프로퍼티가 없습니다.b; // 2c; // 3d; // ReferenceError: \"d\"는 정의되지 않았습니다. 객체를 해체할 때는 반드시 변수 이름과 객체의 프로퍼티 이름이 일치해야 한다. 프로퍼티 이름이 유효한 식별자인 프로퍼티만 해체 후 할당 된다. 객체 해체는 할당만으로 이뤄질 수도 있지만 그렇게 하려면 반드시 괄호를 써야한다. 배열을 해체할 때는 배열 요소에 대응할 변수 이름을 마음대로 쓸 수 있으며 이들은 배열 순서대로 대응한다. 확산 연산자를 사용하면 남은 요소를 새 배열에 할당 할 수 있다. - 배열 해체는 꼭 배열에만 사용 할수 있는 것은 아니다, 이터러블 객체에는 모두 사용 할 수있다.","link":"/2019/07/05/Learning-JavaScript-chapter5/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 6. 함수","text":"함수(function)는 하나의 단위로 실행되는 문의 집합, 일종의 부속프로그램으로 볼 수도 있다.함수를 호출 할 때는 이름 다음에 괄호를 쓴다. 반환값 함수 바디 안에 return키워드를 사용하면 함수를 즉시 종료하고 값을 반환한다.return을 명시적으로 호출하지 안으면 반환값은 undefined가 됩니다.함수는 어떤 타입의 값이라도 반환 할 수 있습니다. 호출과 참조자바스크립트에서는 함수도 객체 따라서 다른개체와 마찬가지로 넘기거나 할당 할 수 있다. 함수 식별자 뒤에 괄호를 쓰면 자바스크립트는 함수를 호출한다. 그리고 함수를 호출한 표현식은 반환값이 된다. 괄호를 쓰지않으면 다른 값과 마찬가지로 함수를 참조하는 것이며, 그 함수 는 실행되지 않는다. 함수를 변수에 할당하면 다른 이름으로 함수를 호출 할 수 있다.함수를 객체 프로퍼티에 할당 할 수도 있다. 배열 요소로 할당 할 수도 있다. 함수와 매개변수함수를 호출하면서 정보를 전달 할때는 함수 매겨변수를 이용한다.매개변수는 함수가 호출되기 전에는 존재하지 않는다는 점을 제외하면 일반적인 변수나 마찬가지이다. 123function avg(a,b){ return(a+b)/2} 이 함수 선언에서 a와b를 정해진 매개변수를 한 개 전달하든 같은 함수를 호출 하는 것이다.다시 말해 어떤 함수를 그 함수에서 정해진 매개변수 숫자와 관계없이 몇 개의 매개 변수를 전달해도 됩니다.정해진 매개변수에 값을 제공하지 않으면 암묵적을 undefined가 할당됩니다. 매개변수 해체매개변수도 해체 할 수 있다. 해체 할당과 마찬가지로 프로퍼티 이름은 반드시 유효한 식별자여야 하고,들어오는 객체에 해당 프로퍼티가 없는 변수는 undefined를 할당받습니다.확산 연산자를 써서 남는 매개변수를 이용 할 수 있습니다.함수를 선언 할 때 확산 연산자는 반드시 마지막 매개변수여야 합니다.확산 연산자 뒤에 다른 매개변수가 있으면 값 중 어디까지를 확산 매개변수에 할당 해야 하는지 판단 할 수 없어 에러를 일으킨다. 매개변수 기본값ES6에서 추가, 일반적으로 매개변수에 값을 제공하지 않으면 undefined가 값으로 할당됩니다. 12345678function f(a,b= \"default\", c=3){ return `${a} - ${b} - ${c}`;}f(5,6,7); // \"5 - 6 - 7\"f(5,6); // \"5 - 6 - 3\"f(5); // \"5 -default -3\"f(); // \"undefined - default - 3\" 객체의 프로퍼티인 함수객체의 프로퍼티인 함수를 메서드라고 불러서 일반적인 함수와 구별합니다.ES6에서는 간편하게 메서드를 추가 할 수 있는 문법이 생겼다. 12345678910const o = { name: 'Wallace', // 원시 값 프로퍼티 bark: function() { return 'Woof!'; } // 함수 프로퍼티(메서드)}// ES6const o = { name: 'Wallace', // 원시 값 프로퍼티 bark() { return 'Woof!'; } // 함수 프로퍼티(메서드)} this키워드함수 바디 안에는 특별한 읽기 전용값이 this가 있다.일반적으로 this는 객체의 프로퍼티인 함수에서 의미가 있다.this는 함수를 어떻게 선언했느냐가 아니라 어떻게 호촐했느냐에 따라 달라진다는 것을 이해해야 한다.중첩된 함수 안에서 this를 사용하려다 보면 혼랑을 야기한다. 이러한 문제해결을 위해 다른 변수에 this를 할당해서 사용한다.ES6에서는 화살표함수를 써도 이 문제를 해결 할 수 있다. 함수 표현식과 익명함수익명 함수에서는 함수에 식별자가 주어지지 않습니다.함수 표현식은 함수를 선언하는 한 가지 방법일 뿐이며, 그 함수가 익명이 될 수도 있을 뿐이다.함수 표현식은 식별자에 할당 할 수도 있고 즉시 호출 할 수도 있다. 함수 표현식은 함수 이름을 생략 할 수 있다는 점을 제외하면 함수 선언과 문법적으로 완전히 같다. 함수 표현식12345678// 기명함수const f = function name(){ // ...}// 익명함수const f = function(){ // ...} 일반적인 함수 선언과 마찬가지로 f()로 함수를 호출 할 수 있다.차이점은 먼저 함수 표현식으로 익명함수를 만들고 그 함수를 변수에 할당했다는 것이다. 익명함수는 어디든 쓸 수 있다.다른 함수나 메서드의 매개변수로 넘길 수도 있고, 객체의 함수 프로퍼티가 될 수도 있다.-재귀함수 컨택스트의 차이함수선언이 표현식으로 사용됐다면 그건 함수 표현식, 표현식으로 사용되지 않았다면 함수 선언 화살표 표기법funtion이라는 단어와 중괄호 숫자를 줄이려고 고안된 단축문법 화살표 함수의 세가지 단축문법 function을 생략해도 됩니다. 함수에 매개변수가 단 하나 뿐이라면 괄호()도 생략 할 수 있습니다. 함수 바디가 표현식 하나라면 중괄호와 return문도 생략 할 수 있습니다. 화살표 함수는 항상 익명입니다. 변수에 할당 할수는 있지만 이름 붙은 함수를 만들 수는 없다. 1234567891011const f1 = function() { return \"hello!\"; }// 또는const f1 = () => \"hello!\";const f2 = function(name) { return `Hello, ${name}!`; }// 또는const f2 = name => `Hello, $(name)!`;const f3 = function(a,b) { return a + b; }// 또는const f3 = (a,b) => a + b; 화살표표기법은 단순한 단축문법에 그치는 것이 아니라 함수형 프로그래밍을 자바스크립트에 도입하는 중요한 열쇠이다.또 다른 차이는 객체 생성자로 사용 할 수 없고, arguments 변수도 사용 할 수 없다. call, apply, bind자바스크립트에서는 일반적인 방법 외에도, 함수를 어디서, 어떻게 호출 했느냐와 상관없이this가 무엇인지 지정 할 수 있습니다.call 메서드는 모든 함수에서 사용 할 수 있으며, this를 특정 값으로 지정할 수 있습니다. 1234567891011const bruce = { name: \"Bruce\" };const madeline = { name : \"Madeline\" };// 이 함수는 어떤 객체에도 연결되지 않았지만 this를 사용합니다.function greet(){ return `Hello, I'm ${this.name}!`;}greet(); // \"Hello, I'm undefined!\" - this는 어디에도 묶이지 않았습니다.greet.call(bruce); // \"Hello, I'm Bruce!\" - this는 bruce 입니다.greet.call(madeline); // \"Hello, I'm Madeline!\" - this는 madeline 입니다. 함수를 호출하면서 call를 사용하고 this로 사용할 객체를 넘기면 해당 함수가 주어진 객체의 메서드인 것처럼 사용 할 수 있다.call의 첫번째 매개변수는 this로 사용할 값이고, 매개변수가 더 있으면 그 매개변수는 호출하는 함수로 전달된다. apply는 함수 매개변수처리 방법만 제외하고 call과 같습니다.call은 함수와 마찬가지로 매개변수를 직접 받지만 apply는 매개변수를 배열로 받습니다. apply는 배열 요소를 함수 매개변수로 사용해야 할 때 유용하다.ES6의 확장연산자(…)를 사용해도 apply와 같은 결과를 얻을 수 있다. bind를 사용하면 함수의 함수의 this값을 영구히 바꿀 수 있다. bind에 매개변수를 넘기면 항상 그 매개변수를 받으면서 호출되는 새 함수를 만드는 효과가 있다.","link":"/2019/07/05/Learning-JavaScript-chapter6/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 8. 배열과 배열처리","text":"배열의 기초 배열은 객체와 달리 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다. 자바스크립트의 배열은 비균질적입니다. 즉 한 배열의 요소가 모두 같은 데이터 타입일 필요는 없습니다. 배열은 다른 배열이나 객체도 포함 할 수 있습니다. 배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근 할 때도 대괄호를 사용합니다. 모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다. 배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하며 배열을 자동으로 그 인덱스에 맞게 늘어나며, 빈자리는 undefined로 채워집니다. Array 생성자를 써서 배열을 만들수도 있습니다. 배열요소 조작배열 메서드 중 일부는 ‘배열자체를 수정’하며, 다른 일부는 ‘새 배열’을 반환합니다.예) push는 배열자체를 수정하며, concat은 새 배열을 반환합니다. push, pop, shift, unshift 메서드배열의 처음은 첫 번째 요소, 즉 인덱스가 0인 요소배열의 끝은 인덱스가 가장 큰 요소, 즉 배열이 arr이라면 arr.length -1 인 요소push 와 pop은 각각 배열의 끝에 요소를 추가하거나 제거합니다. (수정)shift와 unshift는 각각 배열의 처음에 요소를 제거하거나 추가합니다. (수정) concat 메서드concat메서드는 배열의 끝에 여러요소를 추가한 사본을 반환concat은 제공받은 배열을 한 번만 분해합니다.배열안에 있는 배열을 다시 분해 하지는 않습니다. - 이해가 잘 안감 slice 메서드배열의 일부만을 가져올때 사용합니다.slice 메서드는 매개변수 두 개를 받습니다.첫 번째 매개변수는 어디서부터 가져올지를 두 번째 매개변수는 어디까지 가져올지를(바로 앞 인덱스까지 가져옵니다.) 지정합니다.두 번째 매개변수를 생략하면 배열의 마지막 까지 반환합니다.음수인덱스를 사용하면 배열의 끝에서부터 요소를 셉니다. 123456const arr = [1, 2, 3, 4, 5];arr.slice(3); // [4,5] arr은 바뀌지 않았습니다.arr.slice(2,4); // [3,4] arr은 바뀌지 않았습니다.arr.slice(-2); // [4,5] arr은 바뀌지 않았습니다.arr.slice(1,-2); // [2,4] arr은 바뀌지 않았습니다.arr.slice(-2,-1); // [4] arr은 바뀌지 않았습니다. splice 메서드배열을 자유롭게 수정할 수 있습니다.첫 번째 매개변수는 수정을 시작할 인덱스 이고, 두 번째 매개변수는 제거할 요소 숫자입니다.아무요소도 제거하지 않을 때는 0을 넘깁니다. 나머지 매개변수는 배열에 추가될 요소입니다. 12345const arr = [1, 5, 7];arr.splice(1,0,2,3,4); // [] arr은 이제 [1,2,3,4,5,7]입니다.arr.splice(5,0,6); // [] arr은 이제 [1,2,3,4,5,6,7]입니다.arr.splice(1,2); // [2,3] arr은 이제 [1,4,5,6,7]입니다.arr.splice(2,1,'a','b') // [5] arr은 이제 [1,4,'a','b',6,7]입니다. copyWithin 메서드ES6에서 도입, 배열요소를 복사해서 다른 위치에 붙여넣고, 기존 요소를 덮어 씁니다.첫 번째 매개변수는 복사한 요소를 붙여넣을 위치이고, 두 번째 매개변수는 복사를 시작할 위치, 세 번째 매개변수는 복사를 끝낼 위치입니다.(생략가능)음수를 사용하면 배열의 끝에서부터 셉니다. 1234const arr = [1,2,3,4];arr.copyWithin(1, 2); // arr은 이제 [1,3,4,4]입니다.arr.copyWithin(2, 0, 2); // arr은 이제 [1,3,1,3]입니다.arr.copyWithin(0, -3, -1); // arr은 이제 [3,1,1,3]입니다. fill 메서드ES6에서 도입, 정해진 값으로 배열을 채웁니다.크기를 지정해서 배열을 생성하는 Array 생성자와 잘 어울립니다.배열의 일부만 채우려 할때는 시작인덱스와 끝인덱스를 지정하면 된다.음수인덱스도 사용 할 수 있다. 123456const arr = new Array(5).fill(1); // arr이 [1,1,1,1,1]로 초기화 뙵니다.arr.fill(\"a\"); // arr은 이제 [\"a\",\"a\",\"a\",\"a\",\"a\"]입니다.arr.fill(\"b\",1); // arr은 이제 [\"a\",\"b\",\"b\",\"b\",\"b\"]입니다.arr.fill(\"c\",2,4); // arr은 이제 [\"a\",\"b\",\"c\",\"c\",\"b\"]입니다.arr.fill(5.5, -4); // arr은 이제 [\"a\",5.5,5.5,5.5,5.5]입니다.arr.fill(0,-3,-1); // arr은 이제 [\"a\",5.5,0,0,5.5]입니다. reverse 메서드배열의 요소의 순서를 반대로 바꿉니다. sort 메서드배열 요소의 순서를 정렬합니다. sort는 정렬 함수를 받을 수 있습니다.일반적으로는 객체가 들어있는 배열을 정렬 할 수 없지만 정렬 함수를 사용하면 가능하다. 배열검색indexOf,lastIndexOf 메서드,indecOf 메서드는 찾고자 하는 것과 정확히 일치(===)하는 첫 번째 요소의 인덱스를 반환lastIndexOf 메서드는 배열의 끝에서부터 검색배열의 일부분만 검색하려면 시작 인덱스를 지정할 수 있다.indexOf 와 lastIndexOf는 일치하는 것을 찾지 못하면 -1 을 반환한다. findindex 메서드findindex는 메서드는 보조함수를 써서 검색조건을 지정할 수 있다.indexOf와 lastindexOf 처럼 일치하는 것을 찾지 못하면 -1을 반환검색 시작할 인덱스를 지정 할 수 없고, 뒤에서 부터 찾을 수도 없다. find 메서드조건에 맞는 요소의 인덱스가 아니라 요소 자체를 검색할 때 사용검색 조건을 함수로 전달 할 수 있다.조건에 맞는 요소가 없을 때는 undefined를 반환 some 메서드조건에 맞는 요소를 찾으면 즉시 검색을 멈추고 true를 반환조건에 맞는 요소를 찾지 못하면 false를 반환 every 메서드배열의 모든 요소가 조건에 맞아야 true를 반환 그렇지 않다면 false를 반환조건에 맞지 않는 요소를 찾아야만 검색을 멈추고 false를 반환조건에 맞지 않는 요소를 찾지 못하면 배열 전체를 검색 map 과 filter 메서드map은 배열 요소를 변형합니다.map 과 filter 는 사본을 반환하며 원래 배열을 바뀌지 않습니다.콜백함수는 각 요소에서 호출 될 때 요소 자체와 요소인덱스, 배열전체를 매개변수로 받습니다. fliter 는 필요한 것들만 남깁니다.map과 마찬가지로 사본을 반환하며 새 배열에는 필요한 요소만 남습니다.어떤 요소를 남길지 함수로 넘깁니다. reduce 메서드map이 배열의 각 요소를 변형한다면 reduce는 배열 자체를 변형합니다.reduce는 map과 filter를 비롯해 앞의 설명한 배열 메서드의 동작 대부분을 대신 할 수 있다.reduce가 받는 첫번째 매개변수는 배열이 줄어드는 대상인 어큐뮬레이터 입니다.두 번째 매개변수부터는 여태까지 설명한 콜백의 순서대로 현재배열요소, 현재인덱스, 배열 자체 입니다. reduce는 초기값도 옵션으로 받을 수 있습니다. 12const arr = [5,7,2,4];const sum = arr.reduce((a,x => a += x,0)); reduce의 콜백 함수는 매개변수로 누적값 a와 현재 배열요소 x를 받았습니다. 이 예제에서 누적값은 0으로 시작합니다. 진행순서 첫 번째 배열 요소 5에서 익명 함수를 호출합니다. a의 초깃값은 0이고 x의 값은 5입니다. 함수는 a와 x(5)의 합을 반환합니다. 이 값은 다음 단계에서 a의 값이 됩니다. 두 번째 배열 요소 7에서 함수를 호출합니다. a의 초깃값은 이전 단계에서 전달한 5이고, x의 값은 7입니다. 함수는 a와 x의 합 12를 반환합니다. 이 값은 다음 단계에서 a의 값이 됩니다. 세 번째 배열 요소 2에서 함수를 호출합니다. 이 단계에서 a는 12이고 x는 2 입니다. 함수는 a와 x의 합인 14를 반환합니다. 네 번째이자 마지막 배열 요소인 4에서 함수를 호출합니다 a는 14이고 x는 4입니다. 함수는 a와 x의 합인 18을 반환하며 이 값은 reduce의 값이고 sum에 할당 되는 값입니다.누적값이 어떻게 변하는 지 생각하는 습관을 기르는게 좋다. 누적값이 undefined로 시작된다면 어떻게 될까? 누적갑이 제공되지 않으면 reduce는 첫 번째 배열요소를 초기값으로 보고 두 번째 요소에서부터 함수를 호출합니다.배열의 첫 번재 요소가 그대로 초깃값이 될 수 있을때는 초깃값을 생략해도 됩니다. reduce는 보통 숫자나 문자열 같은 원시값을 누적값으로 사용하지만 객체 또한 누적 값이 될 수 있고 이를 통해 아주 다양하게 활용할수 있다.","link":"/2019/07/13/Learning-JavaScript-chapter8/"},{"title":"지난 1년6개월의 회고","text":"이번에 정들었던 (주)라이프스타일프로젝트(이하 LSP) 를 떠나면서 그동안의 회사생활 및 1년6개월 동안의 생활을 회고해보고 달라진 점들을 정리해본다. 사실 지금 글을 쓰고있는 오늘(8월29일)이 마지막 출근날이다. 뜻밖의 연락현재 다니고있고 곧 퇴사(8월31일부)하게 되는 LSP와의 인연은 2018년 2월에 시작됐다.그 당시 이직을 준비하고 있는 상태였던 필자는 취업사이트에 이력서를 올려놓고 여러군데에 면접을 보고 있는 상황이었다.그러던중 지금의 회사 인사팀에서 먼저 필자의 이력서를 보고 연락이 왔다. 그당시 회사명은 (주)유앤김파트너스 였다. 그때까지만 해도 이력서를 넣지 않은 곳에서 직접적으로 연락이 온적은 없어서 있단 신기했고 또 그 당시 회사 주력브랜드였던 미프(미남프로젝트)의 제품을 우연히 정글의 법칙에서 김병만이 사용하는 것을 본 후라 그런지 더욱 신기했었다. 그렇게 면접제의를 받고 면접을 보게 되엇는데 1:3의 면접이었다. 면접관으로는 지금 같이 일하고 있는 팀장님, 인사담당자, 부사장님 이렇게 세분이 들어오셨었다. 몇가지 기술적인 질문이 있었으나 크게 어려운 질문은 없었고 상당히 즐거운 분위기에서 면접은 마무리되었다. 기억나는게 한가지 있는데 면접 마지막에 언제 연락을 줄 수 있냐는 필자의 질문에 회사측에서 필자가 첫번째 면접자라고 시간이 조금 걸릴것 같다고 했는데 그 대답을 듣고 필자가 호기롭게 \"첫번째가 가장좋은거 아시죠??\"하며 너스레를 떨었던 것이 기억이 난다. ㅎㅎㅎ 지금 생각해도 참….. 그 덕분인지는 모르겠지만 면접 다음날 바로 연락이 왔는데 다른 사람을 추가면접보지 않고 바로 필자를 합격자로 정했다는 연락이었다. 연봉제안도 필자가 제시했던 금액보다 좋은 조건을 제시해주어서 여러가지 망설임이 있었지만 입사를 결정하게 되었다. 두근두근 첫 출근입사는 설이 지나고였다. 명절을 보내고 새로운 마음으로 회사에 첫 출근을 하였다. 부서는 크리에이티브팀이었고, 필자를 제외한 모든 부서원들은 디자이너들이었다. 필자의 업무는 기존에 계시던 분이 인수인계를 해주셨는데, 회사가 원래는 판교에서 지금의 역삼역근터로 이사를 오면서 거리도 멀어지고 건강도 안좋아지셔서 어쩔수 없이 퇴사를 하게 되었다고 하셨다. 그렇게 인수인계 받은 기존의 사이트는 카페24 쇼핑몰 솔루션을 통해 작업이 되어있었고 대부분이 이미지로 코딩이 되어있는 상태였다. 기존에 계시던분이 원래 디자이너 출신이어서 간단하게 코딩이 이루어져 있었다. 추후에 대대적인 리뉴얼이 이루어졌다.그때까지만 해도 필자는 카페25 쇼핑몰 솔루션은 로그인만 해서 보았던게 전부였고 그 전에 하드코딩을 했었어서 카페25를 통한 코딩에 막연한 두려움을 약간을 가지고 있었으나 기존에 하던것에서 약간의 환경의 변화만 있었을 뿐 어려움 없이 적응 할 수 있었다.또한 인수인계를 해주고 떠나시는 분을 제외하고는 회사에서 코딩 및 개방을 할 수 있는 사람이 한 사람도 없어서 막막하기도 하였다. 하면된다.짧은 인수인계 기간이 끝나고 본격적으로 홀로 업무가 시작되었다.그때 급한 업무를 처음으로 처리했던 기억이 나는데 기존에 계시던 분도 처음하는 일이었도 필자도 처음 듣는 업무여서 약간 당황했덨던 기억이난다. 업무내용은 그 때 당시 미프 모바일 사이트를 패키징하여 어플출시를 앞두고 있었는데 그 어플 출시를 위해서 애플 개발자 등록을 해야하고 결재를 해야되는데 그 단계에서 애플과 메일을 주고받고 전화를 받고 거기에서 받은 인증번호를 다시 입력하고 하는 등의 복잡한 프로세스가 있었는데 전에 계신던 분도 몇번 시도를 하다가 중간에 문제가 생겨서 해결을 못하시고 퇴사를 하시면서 필자에게 넘어왔던 업무였다. 중간에 무엇을 잘못했는지 중간 프로세스에서 막혀있는 상태였고 그렇게 상당한 시간이 흘러서 앱스토어 어플 출시 자체가 기약없이 미뤄지고 있는 상황이었다. 필자도 처음 겪는 업무여서 현재의 상황과 구글링 그리고 앱스토어의 문의를 통해 예상보다 빠르고 쉽게 앱스토어 어플 출시를 이루어낼 수 있었다. 오랜기간 멈춰져있던 업무를 필자가 잘 마무리 해서 입사한 후에 업무에 적응하는데 큰 도움이 되었던 사건이었다. 일을 하면서1년6개월 동안 LSP를 다니면서 많은 것들을 배우고 성장하는 시간이었다. 회사의 기초가 화장품제조 및 판매이다보니 쇼핑몰 사이트의 개발과 운영에 대해 많은 것들을 배우게 되었고 쇼핑몰의 기초가 되는 카페24 쇼핑몰 솔루션에 대한 깊은 이해를 가질수 있었다. 그와 더불어 기존에 다니넌 에이전시와는 다르게 여유시간들을 갖게되어 아무래도 별도의 클라이언트가 있는것이 아니라 자사의 제품들만 다루기 때문에 일정과 같은 부분에서 회사 내부에 사정에 맞게 조율이 가능한 부분이 있었다. 많은 커뮤니티활동과 더불어 학원에도 다닐수 있는 기회가 있었고 스터디에도 참여해서 많은 것들을 배우는 시간을 가질 수 있었다. 필자는 크리에이티브팀에 소속되어있었다. 암묵적으로 디자인팀으로 불리운다 그 이유는 앞에서 잠깐 언급했듯이 필자를 제외한 모든 팀원이 디자이너로 구성되어있기 때문이었다. 필자도 퍼블려서로 전향하기 이전에는 무대디자인을 하였기에 디자이너들과의 소통 및 협업에는 큰 문제가 없었다. 그리고 화장품회사의 특성(?)상 남자직원들보다는 여자직원들의 비중이 더 높았었는데, 이전 무대일을 할때에도 디자인 관련 부서에서 일했기에 여자직원들이 더 많은 환경이었다보니 자연스레 섞여서 생활을 했었고 그러다보니 커뮤니케이션 같은 부분에서는 전혀 어려움이 없었으나 코딩 및 개발 업무를 알고 있는 사람은 전혀 없어서 어떤한 문제가 생겼을 때 혼자서 해쳐나가야하는 어려움은 늘 존재했었고 같이 문제에 대해 고민해 줄 사람의 필요가 느껴졌었다. 당시 회사 사정상 여러 개발자를 두는것은 무리가 있었고 그러다 보니 배움과 공유에 대한 갈증이 생겼고 자연스럽게 커뮤니티활동과 스터디로 그 갈증을 푸는 계기가 되었다. 공부, 스터디처음부터 스터디를 시작한 것은 아니었다. 스터디에 대한 정보도 없었고 그러한 것들이 활발히 진행되고 있는 것도 모르는 상황이었다. 그래서 처음에는 익숙한 컴퓨터학원을 통해 부족하다고 생각했던 개발에 대한 부분들의 수업을 듣기 시작했다. 그렇게 몇가지 수업들을 들었으나 만족할 만한 실력향상은 나타나지 않았던것 같다. 그러던중 우연히 '하코사'라는 커뮤니티를 접하게 되었고 스터디들이 활발히 진행되고 있는 것을 알게 되었다. 필자와 같은 고민을 하는 분들이 많이 있었으며 자신의 어려움을 질문하고 답을 얻어가고 함께 공부하는 커뮤니티였다. 그렇게 여러가지 정보를 얻어가던 중에 한 살롱에 참여하게 되었고 그곳에서 들은 이야기들은 지금까지 내가 알고 있던 내용들과는 많이 다른 내용들이었다. ‘프론트엔드개발자가 되어야지’, ‘지금 하고 있는 업무에서 추가적인 것들을 배우면서 커리어를 쌓으면 할 수 있는 걸 거야’ 와 같은 막연한 계획들이 있었는데 그 계획들을 처음부터 다시 생각하게 되는 살롱이었다. 살롱 : 18세기 중반 프랑스에서 지성인과 예술가가 모여 토론을 펼치고 지식을 나누던 사교 모임 살롱에 참여하기 전까지는 프론트엔드 개발자로 전향을 하려면 지금 하던 퍼블리셔 업무에서 추가적으로 약간의 자바스크립트를 배우고 동적인 UI개발을 더 익히면 되겠지 라는 수준이었는데 참여하고 난 후에는 생각이 완전히 바뀌었다. 우선 퍼블리셔와 프론트엔드개발자는 겹치는 부분도 물론 있었지만 근본적으로 다른 직군에 속해 있는 것이라서 추구하는 방향도 다르고 그렇기에 공부해야 하는 방향 자체도 다르다는 것이었다. 대략적으로 퍼블리셔거 보여지는 뷰단에서 UI적인 개발을 주로 한다면 프로트엔드개발자는 프로든단에서 DATA를 다루어 보여지는 뷰단을 선계해 가는 느낌이다. 그렇다보니 접근하는 방식에서부터 차이가 있고 생각하는 방법도 다르게 해야 올바르게 개발자로 거듭날 수 있다는 생각이 들었다. 책 집필스터디에 참여그렇게 살롱다녀와서 거기서 알게된 인연으로 정말 좋은 기회인 책집필을 위한 스터디에 참여하는 기회가 찾아왔다.Vue.js에 관한 책을 집할 하면서 그 내용들을 가지고 구현해 보고 스터디였는데 피자는 당시 Vue.js는 당연히 처음접하였고 프레임워크언어자체가 대한 개념 및 개발을 처음 시작하는 단계였다. 그래서인지 스터디에서 배우는 하나하나가 너무나 값진 경험이었다. 처음 배우는 내용들이다보니 질문도 많았고 이것저것 안되는 것들도 그리고 모르는 것들도 많았는데 집필하시는 분들에게는 이부분이 오히려 도움이 많이 되었다고 하셨다. 서로에게 여러가지를 주고 받을수 있는 윈윈이었으니 잘 마무리 되었다. ㅎㅎㅎ 스터디가 끝나고 간단한 메모어플과 게시판어플을 구현해볼수 있었다. 현재는 책은 무시히 출판되었고 필자는 간단하게나마 추천사로 책 한부분에 남을수 있어서 좋았다. 궁금해 하실 분들을 위해 책제목을 남겨본다. 책 제목은 \"커피한잔 마시며 끝내는 Vue.js\" 이다. 그렇게 Vue.js 스터디를 끝나마치고 더 배워야 한다는 생각에 git스터디, javajscript스터디에 참여하게 되었고 그러다보니 필자에게 맞는 새로운 스터디를 기획해서 스터디를 진행하게 되었다. 현재는 JS ES6를 중점적으로 스터디를 하고 잇으며 8월 31일에 마지막 스터디 모임을 앞두고 있는 상황이다. 이번 스터디에 함께한 스터디원분들 중 많은 분들이 다음 스터디로 함께 했으면 좋겠다는 의사를 밝혀주셔서 현재는 함께 기획하고 있는 중에 있다. 이렇게 회사 생활을 하면서 커뮤니티와 많은 스터디들을 통해서 부족한 것들을 채우고 발전해나가는 시간들을 가실 수 있었던 것에 대해서는 긍적적으로 생각한다. 마치며지난 1년 6개월 동안 LSP에 지내면서 함께한 모든 분들에게 감사의 인사를 전하고 싶다.비록 더 많은 시간들을 함께 하지는 못하지만 어디에서든지 각자의 몫을 하며 빛나고 있기를 소망한다.","link":"/2019/08/29/Retrospective-20190829/"},{"title":"TypeScript? 타입스크립트 소개 및 개발환경 구축","text":"타입스크립트(TypeScript)타입스크립트(TypeScript)는 오픈소스 프로그래밍 언어입니다. 마이크로소프트가 개발했고 유지 관리하고 있습니다.독자적인 표준을 가지고 있지 않고 ECMA스크립트 표준을 따르기 때문에 자바스크립트의 특성을 침범하지 않고 최신 ECMA 표준을 지원합니다.그래서 타입스크립트는 자바스크립트의 상위 집합(superset)언어라고 합니다.타입스크립트가 ECMA 스크립트를 따르므로 자바스크립트 문법을 타입스크립트에서 이용 할수 있으며, 최신 ECMA 표준을 지원함으로써 하위 ECMA 표준에 대한 컴파일도 지원합니다. ECMA 스크립트의 역사ECMA는 유럽 컴퓨터 제조사 연합(European Computer Manufacturers Association)의 약자로 스크립트의 표준을 만들고 관리하는 단체입니다.이 단체는 자바스크립트 뿐아니라 C#, 다트(Dart) 같은 언어의 표준과 JSON, XML과 같은 데이터 교환 형식의 표준도 관리하고 있습니다.간단하게 역사를 살펴보면 ECMA 스크립트 표준은 1997년에 처음 등장한 스크립트 표준이고, 첫번째 판이라는 의미로 ‘Ed.1’이라는 버전 형식을 추가해‘ECMA-262 Ed.1’ 이라고 명명됐습니다. 이를 줄여서 ES1 이라고 부릅니다.ES2 버전은 1998년도에 나왔습니다. 새로운 특징이 추가된 것은 아니고 국제 표준화 국제 전기 전자 표준 위원회의 표준인 ISO/IEC 16262에 부합하도록 재편집 됐습니다.ES3부터는 ECMA 스크립트가 본격적으로 브라우저 지원을 위한 표준으로 발돋움 했고, 이때 추가된 특징으로 try/catch 예외 처리 구문 등이 있습니다.ES4는 스크립트 버전 중 예외적으로 불완전한 표준이 되어 표준으로 채택되지 못했습니다.ES5는 2009에 나왔고 브라우저에서 가장 안정적으로 동작하는 표준입니다. 이때 ES5표준을 기반으로 한 Node.js 플랫폼도 등장했습니다.이로써 자바스크립트가 서버프로그래밍이 가능한 언어로서 영역을 확장했습니다.ES6는 2015년에 확정되었고 모듈 시스템, 화살표함수, 클래스, 개선된 객체 리터널, 템플릿 문자열, 심볼, 프로미스, 제너레이터, for of, 디스트럭처링, 프락시, let, const 등 많은 특징이 추가됐습니다.ES7은 2016년에 확정되었고, 비동기 함수를 동기화 할 수 있는 Async/Await 에 대한 특징 등이 추가됐습니다.ES8은 2017년에 확정되었고, 문자열패딩, Object, values 메서드, Object.entries 메서드 등 많은 특징이 추가됐습니다.ES9은 2018년에 확정되었고, Rest/Spread Properties, for await of, Promise.prototype.finally 메서드 등이 추가되었습니다. 타입스크립트의 특징타입스크립트를 자바스스크립트와 비교할때 가장 두드러진 특징은 ‘타입’입니다. 타입은 꽤 사소해 보이지만 타입스크립트에서 중요한 특징입니다.타입이 있음으로써 개별 변수나 함수에 타입 안정성을 더할 뿐 아니라, 대규모 프로젝트를 구성할 수 있는 밑바탕이 됩니다. 타입스크립트의 공식 홈페이지에 나와있는 슬로건은 'JavaScript that scales' 입니다.타입스크립트는 대규모 애플리케이션 개발을 위해 다음과 같은 특징을 지원합니다. 모듈 시스템- ES6 모듈과 네임스페이스 지원 클래스와 인터페이스 지원 타입시스템 지원 타입스크립트의 모듈 시스템은 크게 ES6 모듈과 네임스페이스로 나뉩니다.ES6 모듈은 기존 ES5에서 어려웠던 모듈 분활과 결합 기능을 향상 네임스페이스는 ES6에 없는 타입스크립트에 추가된 특징으로 분리된 이름 공간을 제공해 복잡도를 낮춥니다. 또한 ES6의 클래스뿐 아니라 인터페이스를 추가로 지원해 객체지향 프로그래밍을 더욱 완전하게 지원하고,타입시스템을 기반으로 대규모 애플리케이션을 개발 할 수 있게 합니다. 모듈 시스템ES6에서 제공하는 모듈 선언과 모듈 호출 방식을 지원합니다. export 키워드로 외부 모듈을 선언하거나 import 키워드를 이용해 외부 모듈을 호출 할수 있습니다. 네임스페이스는 라이브러리 단위의 모듈 구성에 유리하며 규모있는 모듈 구성에 필요한 특징입니다.각 네임스페이스에는 인터페이스를 비롯해 클래스나 함수 등의 모듈을 선언할 수 있습니다. 클래스와 인터페이스 지원ES6와 동일한 키워드를 이용해 클래스를 정의 할수 있고, 특히 인터페이스를 지원함으로써(interface, extends) 객체지향 언어의 특징을 더욱 풍부하게 지원합니다. 타입 시스템 지원타입스크립트에는 강력한 타입 시스템(type system)이 있습니다 타입시스템은 자바스크립트의 타입을 확장하고 타입 어노테이션(type annotation)을 이용해 변수에 타입을 선언할 수 있게 합니다.변수에 타입을 선언하는 것을 타입 지정(typing) 이라고 합니다. 타입 지정이 이뤄지면 변수는 엄격한 타이핑(strong typing)이 적용돼 타입 안전성(type safety)을 확보합니다.예를 들어 변수에 string을 타입 어노테이션으로 선언하면 지정한 string 타입 외에 다른 타입의 값을 할당할 수 없습니다. 12// 타입 어노테이션val myVal:string 타입스크립트에서 변수는 함수의 매개변수 등에 선언한 타입 어노테이션은 컴파일할 때 타입 검사를 위한 목적으로 사용합니다.타입 검사를 통해 타입 안정성이 확보되면 타입스크립트 컴파일러가 타입 어노테이션을 제거하고 최종적으로 자바스크립트 코드를 생성합니다. 정적타입123456funxtion sum(a: number, b: number){ return a + b;}sum('x','y');// error TS2345: Argument of type '\"x\"' is not assignable to parameter of type 'number'. TypeScript는 정적 타입을 지원하므로 컴파일 단계에서 오류를 포착 할수 있다는 장점이 있다.명시적인 정적 타입 지적은 개발자의 의도를 명확하게 코드로 기술 할 수 있다. 가독성을 높이고 디버깅을 쉽게 한다. 타입스크립트의 역사타입스크립트는 대규모 애플리케이션을 개발하는 데 있어 자바스크립트는 어렵고 불편하다는 고객사의 불만에 대응하기 위한 목적으로 개발됐습니다.메인 개발자는 앤더스 헤일스버그(Anders Hejlsberg)입니다. C# 언어의 설계를 이끌고 있으며, 델파이의 창시자이기도 합니다.C# 를 설계하고 개발을 주도한 아키텍트가 타입스크립트 개발을 이끌면서 타입스크립트에 많은 영향을 끼쳤습니다. 버전별 특징출시 당시에는 많은 관심을 받지 못함, 여러가지 불편사항들이 있었는데 그 중 IDE 지원이 원할하지 못하다는 것에 대응으로 이후 마이크로소프트는 비주얼 스튜디오를 통해 타입스크립트를 지원하게 됐습니다. 이 후 여러가지 개발도구들에서 타입스크립트를 지원하게 됐습니다. 2012년 10월 1일에 첫번째 버전(0.8)이 출시 됐습니다. 이후에 ECMA 스크립트가 발표될 때마다 곧바로 버전이 업데이트 되었습니다. 타입스크립트 두 번째 버전(0.9)은 2013년 6월 18일에 발표 됐습니다. 0.9 버전의 가장 큰 특징은 제네릭(generics) 지원입니다. 2014년 4월 2일에 타입스크립트 버전1.0 을 발표 2014년 7월에 타입스크립트만을 위한 새로운 컴파일러를 발표 2016년 8월 26일에 타입스크립트 2.0 이 발표 주요 특징은 Non-Nullable 타입, .d.ts 파일을 패키지로 가져올 수 있음 버전 2.1 에서는 프로미스에 대한 폴리필이나 Async/Await 의 하위표준(ES3, ES5)으로의 컴파일을 지원 2.5 에서는 함수추출, 메서드 리팩토리, 퀵 픽스 기능 추가 2.7 에서는 컴파일러의 타입검사 기능 향상 대표적 특징으로는 엄격한 클래스 초기화(Strict Class Initialization)와 고정 길이 튜플(Fixed Length Tuples)이 있습니다. 타입스크립트의 아키텍처 에디터 독립서버 언어 서비스 / 독립 TS 컴퍼일러 코어 타입스크립트 컴파일러 컴파일러타입스크립트의 아키텍처는 언어 변환 기능을 수행하는 코어 타입스크립트 컴파일러(core typescript compiler)를 기반으로 합니다.코어 타입스크립트 컴파일러는 파서, 바인더, 타입체커, 에미터, 전처리기로 구성돼 있습니다. 파서(parser) : 읽어 들인 소스코드를 해석해 구문 트리를 만들고, 구문 트리를 다시 해석해 추상 구분 트리(AST: Abstract Syntax Tree)를 생성한다. 바인더(binder) : 인터페이스나 모듈 혹은 함수와 같은 모듈에 선언이 있을 때 이러한 선언을 심벌로 보고 심벌 간의 규칙을 정의한다. 타입 시스템은 바인더를 통해 명명된 선언을 추론 할 수 있게 된다. 타입 체커(type checker) : 타입이 선언된 구문을 분석하고 타입이 적절한지 체크한다. 에미터(emitter) : 입력된 *.ts 같은 타입스크립트 파일을 *.js, *.d.ts, *.js.map 유형의 파일로 생성하는 기능을 수행한다. 전처리기(pre-processor) : 타입스크립트 파일에 선언된 import문이나 “/// ” 같은 외부 호출 선언이 있을 때 참조 할 수 있는 파일을 가져와 정렬된 파일 목록을 생성한다. 언어 서비스언어 서비스는 코드를 컴파일해 도움말이나 코드의 포매팅, 코드 생상 지정 같은 편집기에 필요한 기능을 제공합니다. 언어 서비스는 편집기에서 코드 어시스트를 제공하는 근간입니다. 독립서버(standalone server)독립서버는 컴파일러와 언어 서비스 같은 하위 레이어를 래핑해 JSON 형식을 통해 외부에 정보를 노출할 수 있게 합니다. 독립서버의 다른 이름은 tsserver 입니다.IDE 나 편집기 개발에 필요한 기능을 명령어 형식으로 제공, 서버 형식에 맞게 JSON으로 요청하면 결과를 응답합니다.독립서버는 타입스크립트의 개발 환경이므로 타입스크립트를 이용한 응용 개발에서 직접 다룰 일은 없습니다. 편집기타입스크립트코드에 구문 오류나 타입 오류가 있는지 실시간으로 파악 할 수 있도록 코드 어시스트를 지원합니다. 개발환경 구축타입스크립트는 npm을 통해 설치 할수 있다. npm의 사용을 위해 Node.js 를 설치한다.https://nodejs.org/ko/ Node.js 가 재대로 설치됐다면 npm 명령어를 사용해 타입스크립트를 설치한다. 1$ npm install -g typescript 아래 명령어를 사용하여 타입스크립트 버전을 확인 할수 있다. 1$ tsc -v 타입스크립트 컴파일러TypeScript 컴파일러(tsc)는 TypeScript 파일(.ts)을 입력받아 ECMA 스크립트(자바스크립트)의 특정 버전으로로 반환합니다. 컴파일링 : 한 언어의 소스코드를 다른 언어로 바꾸는 것트랜스파일링: 한 언어의 소스코드를 비슷한 추상화 수준의 다른 언어로 바꾸는 것 관점에 따라 타입스크립트는 다른 언어인 자바스크립트로 바꾸므로 컴파일링 한다고 볼수 있지만 비슷한 추상화 수준의 다른 언어로 트랜스파일링 한다고 볼수도 있다. 간단한 코드를 작성해서 타입스크립트 코드를 자바스크립트 코드로 컴파일하고 이를 실행 해보자. hello.ts12let hello: string = \"hello TypeScript\";console.log(hello); tsc 명령어로 컴파일 할 수 있다. tsc 명령어 뒤에 컴파일 대상 파일명을 작성하다. 이때 확장자 .ts 는 생략이 가능합니다. 1tsc hello 변환 결과 hello 변수 타입인 string 이 삭제되고 hello.js 파일이 생성 됩니다. hello.js12var hello = \"hello typeScript\";console.log(hello); Reference타입스크립트 퀵스타트 - 루비페이퍼TypeScript의 소개와 개발 환경 구축 - Poiemaweb","link":"/2020/03/11/TypeScript-1/"},{"title":"타입스크립트 - 비동기 처리","text":"HTTP 요청은 비동기이므로 콜백 헬과 같은 중첩 스코프를 만들어 냅니다. 타입스크립트는 ES6에서 제안된 프로미스를 이용해 콜백 헬이 되지 않도록제어 흐름을 개선할 수 있습니다.자바스크립트는 비동기 요청 후 응답 결과를 콜백 함수로 처리합니다. 이렇게 콜백 함수로 처리하는 상황은 대체로 응답 시점을 예측할 수 없을 때입니다.이와 같은 상황의 예로 HTTP 요청에 대한 응답 처리나 파일 I/O 작업 등이 있습니다. 비동기 요청 후 응답 결과는 콜백 함수의 매개변수를 통해 전달됩니다. 스코프가 깊어지게 되면 콜백 함수와 제어문 사용으로 스코프가 중첩돼 가독성이 안좋습니다. 프로미스 소개와 동작 과정프로미스(promise)는 중첩 스코프 문제를 해결하기 위해 ES6에서 제한된 객체입니다. 프로미스는 스코프가 깊어지지 않도록 나열식 패턴 방식으로 입력 데이터를 처리할 수 있게 합니다. 프로미스는 다음과 같은 세가지 상태가 존재합니다. 대기 상태 (pending) 충족 상태 (fulfilled) 거부 상태 (rejected) 대기 상태는 프로미스가 실행되고 값이 결정되지 않은 상태를 말합니다. 충족 상태는 대기 상태가 끝난 뒤 값이 결정된 상태이며 resolve 함수를 통해 값을 전달합니다.거부 상태는 프로미스가 제대로 처리되지 않고 거부된 상태로 catch 메서드를 통해 예외 처리해 주어야 합니다. 프로미스는 최초 실행 함수(executor)를 통해 실행됩니다. 실행 함수가 시작되고 마치기전까지 대기 상태를 유지합니다.프로미스는 익명 함수 형태로 작성 할수 있습니다. 123const promise = new Promise((resolve, rejects) => { // 처리할 프로미스 작업 로직}) 프로미스가 정상으로 수행됐다면 충족 상태가 되어 resolve 함수를 호출, 반대로 실패했다면 거부 상태가 되어 reject 함수를 호출해 예외 처리를 진행 합니다. 1234567const promise = new Promise((resolve, rejects) => { if(충족 상태){ resolve(result); } else { rejects('거절사유'); }}) 첫번째 매개변수로 전달된 resolve 함수를 호출하면 then 메서드가 호출됩니다. then 메서드는 결정된 값에 대해 후속 처리를 담당합니다.reject 함수에 거절된 사유를 전달하며 catch 메서드는 전달된 이유를 표시해주고 예외 처리를 진행합니다. 프로미스를 사용한 중첩 스코프 개선then 메서드를 이용해 중첩 코드 개선then 메서드는 하나의 처리 작업에 해당하며 작업 개수에 따라 체이닝 형태로 여러 개를 동시에 선언할 수 있습니다.오류가 있다면 reject 를 호출 할 때 거부 이유를 함께 전달함으로써 catch 메서드를 통해 예외 상황을 처리할 수 있도록 합니다.then 메서드를 체이닝 형태로 선언하고 then 메서드에서 발생한 예외 상황을 처리하려면 catch 메서드를 마지막에 선언해야 합니다. 임의 시간만큼의 지연이 있는 비동기 함수 여러 개를 동시에 호출하면 호출 순서와 응답 결과의 순서가 일치되지 않는 문제가 있습니다.Promise.all() 메서드는 비동기 응답을 호출 순서에 따라 처리할 수 있는 인터페이스를 제공합니다.이 때 Promise.all()는 작업 완료 시점이 일정치 않아 뒤바뀐 결정 갑의 순서를 호출 순서에 따라 출력해주는 역할을 합니다. 반응형 프로그래밍반응형 프로그래밍 모델은 웹 페이지에 들어오는 스트림 형태의 입력 이벤트를 감지해 반응을 처리할 수 있는 모델입니다.이와 관련한 예로 입력에 반응하는 검색어 제안 기능이 있습니다. 검색어 제안 기능은 사용자가 어떠한 단어를 입력하면 단어에 연관된 키워드를 보이는 기능입니다. 발행 구독 패턴시스템은 기본적으로 사용자의 입력에 대해 반응하고 적절한 처리를 해 줄 수 있어야 합니다. 이벤트는 특정 시간에 발생하지 않고 사용자가 의도한 시점에 발생합니다.반응형 프로그래밍은 입력 이벤트를 감지하고 처리하는 데 발행 구독 패턴을 이용합니다.발행 구독 패턴에서 옵저버는 옵저버블을 관찰하고, 옵저버블은 상태가 변경됐을 때 옵저버에게 상태가 변경됐음을 통지해 줍니다.여기서 관측 대상인 옵저버블은 사용자가 입력한 데이터 스트림입니다. 사용자 입력 이벤트는 옵저버가 감시하고 처리해야 할 대상입니다.옵저버는 옵저버블을 구독하고 있다가 옵저버블의 상태가 변경되면 옵저버블로부터 상태가 변경됐음을 통지받습니다. RxJSRxJS는 데이터 스트림에 대한 연산을 연산자 메서드를 이용해 연쇄적으로 처리할 수 있게 관련 인터페이스를 제공합니다.RxJS에서는 사용자가 키를 입력할 대마다 데이터가 생성되고 생성된 데이터는 연산자에 의해 데이터가 처리되고 나서 구독될지 말지를 결정합니다.RxJS에서 스트림 데이터를 처리하기 위해 세 단계를 거칩니다.데이터 생성단계에서는 데이터 생성자가 스트림 데이터를 생성합니다. 데이터 처리 단계에서는 스트림 데이터가 파이프 형태로 연결된 연산자를 통과하면서 차례대로 처리됩니다.데이터 소비 단계에서는 구독자가 데이터 스트림을 받아 최종적인 처리를 수행함으로써 데이터를 소비합니다. 동시성(concurrency)과 동기화(synchronous) 작업동시성란 멀티 스레드와 같이 여러 개의 단위 작업이 동시에 실행되는 성질을 말합니다. 자바스크립트에서 동시성은 작업을 동시에 처리하는 것을 의미합니다. 비동기 프로그래밍 모델 멀티 스레드 프로그래밍 비동기 프로그래밍 모델은 HTTP 요청과 같은 비동기 요청상황에 해당하는 모델입니다. 비동기 프로그래밍 모델은 동기 프로그래밍 모델과 달리,단위 작업을 하나의 스레드내에서 번갈아 가며 실행합니다. 여기서 스레드는 프로세스보다 작은 단위로 프로세스 내에 존재하는 작은 작업 단위를 의미합니다. 멀티 스레드 프로그래밍은 멀티 코어 기기상에서 여러 스레드에서 작업을 동시에 실행하는 방식입니다. 여러 작업을 동시에 실행하기 때문에 병렬성의 특정이 있습니다.멑티 스레드는 자바스크립트에서 지원하지 않습니다. 지원하지 않는 이류는 싱글 스레드만으로 실행 해야 페이지를 로딩할 때 보다 더 빠른 속도로 실행할 수 있게 때문입니다. 더 근본적인 이유로는 브라우저의 인터프리터가 단일 스레드여서 멀티 스레드를 지원하지 않기 때문, 때론 setTimeout 함수를 통한 타이머 호출은 마치 멀티 스레드 처럼동작하는 것처럼 보이지만 실은 멀티 스레드가 아닌 싱글 스레드에서 실행됩니다.비동기 프로그래밍은 작업을 수차적으로 실행 하지 않고 응답 시간을 고려해 실행 순서가 결정됩니다. 동기화 실행이 되면 중간에 비동기 작업이 있더라고 호출순서에 따라 작업이 실행 됩니다. Async/AwaitAsync/Await 는 ES2015애 제안됐고 타입스크립트에서는 1.7에서 추가됐습니다.Async/Await 를 이용하며 비동기 함수를 동기화 할 수 있습니다. 비동기 호출 코드비동기 호출은 응답 시간이 저마다 다를 수 있으므로 차례대로 실행되지 않고 호출 시간과 응답 시간을 고려해 동작을 수행합니다.반대로 동기화 코드는 순서가 보장되며 순서대로 실행됩니다. 비동키 코드를 동기화한다면 비동기 코드를 여럿 사용하는 경우 코드 제어가 간소화 됩니다. 123async function hello() { await run(); } 호출 하는 함수는 프로미스 구문을 포함해 비동기 처리를 수행해야 합니다 .","link":"/2020/06/17/TypeScript-async/"},{"title":"타입스크립트 - 제어문 과 연산자","text":"조건문타입스크립트는 자바스크립트에서 사용했던 조건문을 사용할 수 있습니다. 대표적으로 if 문과 switch 문이 있습니다.if 문은 조건의 참과 거짓에 따라 분기를 수행하는 조건문, switch 문은 입력값에 따라 분기를 결정하는 조건문입니다. if 문if 문은 조건이 참인지 거짓인지 판단하고 분기를 수행합니다. if 문 형식123if (조건) { 명령문;} 이때 if 문에 지정하는 조건은 참과 거짓을 판단할 수 있는 불리언(boolean) 타입이어야 합니다. 이때 if 문에 사용할 변수도 다음과 같이 명시적으로 불리언 타입으로 선언해야 합니다. 1var idEnable: boolean = true; if 문의 조건이 만족하면 if 블록을 실행합니다. if문 뒤에 바로 if 문이 오는 경우 중첩이 가능하고 괄호를 생략할 수 있습니다. 123if (10>1) if (0, =,","link":"/2020/03/25/TypeScript-4/"},{"title":"타입스크립트 - 클래스와 인터페이스","text":"객체지향 프로그래밍과 클래스 기초객체지향 프로그래밍(Object Oriented Programming, OOP)은 커다란 문제를 클래스 단위로 나누고 클래스 간의 관계를 추가하면서 코드 중복을최소화 하는 개발방식이다. 클래스 간의 관계를 추가할 때는 상속이나 포함 관계를 고려하여 추가한다. OOP를 통해 어플리케이션을 개발하면 코드 중복을상당히 줄일 수 있다. 타입스크립트는 자바스크립트(ES6)에 비해서 OOP를 지원하는 부분이 훨씬 더 많다. 클래스는 멤버 변수와 멤버 메서드 등으로 구성된 ‘틀’이며 클래스를 실제로 사용하려면 객체로 생성해야 한다.생성된 객체는 실제 메모리에 위치하고 객체의 참조가 객체 참조변수에 할당되는 과정을 인스턴스화(instantiate)라고 한다. OOP에서 클래스 간의 관계는 크게 두 가지로 나누어 볼 수 있다. 하나는 상속 관계(IS-A)이며, 다른 하나는 포함 관계(HAS-A)이다. 상속 관계 : 상속은 클래스 계층을 만들어 코드 중복을 줄이는 객체지향 프로그래밍 방법이다.타입스크립트는 클래스에 대해 단일 상속만 지원하므로 자식 클래스는 하나의 부모 클래스만 상속받을 수 있다.자식 클래스가 부모 클래스를 상속받을 때는 자식 클래스의 생성자에서 super() 메서드를 호출해 부모 클래스의 생성자를 호출해 주어야 한다. 포함 관계 : 포함 관계는 클래스가 다른 클래스를 포함하는 HAS-A 관계이다. 클래스 내부에 다른 클래스를 포함하는 관계는합성(composition) 관계와 집합(aggregation) 관계로 나뉜다. 합성 관계는 강한 관계인 반면, 집합 관계는 약한 관계이다. 추상 클래스(abstract class)는 구현 메서드와 추상 메서드(abstract method)가 동시에 존재할 수 있다. 여기에서 구현 메서드는 실제 구현 내용을 포함한 메서드이고, 추상 메서드는 선언만 된 메서드이다. 이와 같이 추상 클래스는 구현 내용이 없는 추상 메서드를 포함하기 때문에 불완전한 클래스이다.따라서 추상 클래스는 단독으로 객체를 생성할 수 없고 추상 클래스를 상속하고 구현 내용을 추가하는 자식 클래스를 통해 객체를 생성해야 한다. 구현하지 않은 추상 메서드가 선언되었으므로 자식 클래스에서는 추상 메서드를 오버라이딩(overriding)하여 반드시 구현해 주어야 한다.또한 추상 클래스에 추상 멤버 변수가 선언되어 있으면 자식 클래스에서도 선언해야 한다. 추상 클래스를 작성할 때 abstract 키워드는static 이나 private(public, protected는 가능)과 함께 선언할 수 없음에 주의해야 한다. 인터페이스에 대한 이해인터페이스(interface)는 클래스에서 구현 부분이 빠진 타입으로 이해하면 된다. 인터페이스는 컴파일 후에 사라지게 된다.인터페이스는 선언만 존재하며, 멤버 변수와 멤버 메서드를 선언할 수 있지만 접근 제한자는 설정할 수 없다. 자식 인터페이스의 경우 부모 인터페이스를 상속해서 확장할 수 있는데, 타입스크립트는 다중 상속이 가능하다. 만약 다중 상속을 받을 때같은 이름의 메서드를 상속받으면, 상속받는 인터페이스에서 같은 이름의 메서드를 모두 재정의 해야 한다. 인터페이스는 타입 선언이 많아도 컴파일(ES6) 후에는 모두 사라지므로 런타임 성능에 영향을 끼치지 않는다. 오버라이딩(Overriding)오버라이딩은 부모 클래스에 정의된 메서드를 자식 클래스에서 새로 구현하는 것을 일컫는 개념이다.부모 클래스에서 오버라이딩을 당하는(?) 메서드를 오버라이든 메서드 라고 하고, 자식 클래스에서 오버라이딩된 메서드를 오버라이딩 메서드라고 했을 때,오버라이딩이 이루어지기 위해서는 다음 두 가지의 조건을 만족해야 한다. 조건 1. 오버라이든 메서드의 매개변수 타입은 오버라이딩 메서드의 매개변수 타입과 같거나 상위 타입이어야 한다.(단, 오버라이딩 메서드의 매개변수 타입이 Any 이면 예외) 조건2. 오버라이든 메서드의 매개변수 갯수가 오버라이딩 메서드의 매개변수 갯수와 같거나 많아야 한다.(단, 조건 1이 성립하는 전제가 있어야 함) 오버로딩(Overloading)메서드 오버로딩은 메서드의 이름이 같지만 매개변수의 타입과 개수를 다르게 정의하는 방법이다.클래스의 상속을 고려해 오버로딩을 구현하려면 부모 클래스에 상위 타입을 가지는 오버라이든 메서드를 선언해 두고 파생 클래스에서 오버라이딩 메서드를선언해 구현할 수 있다. 이 때 오버라이딩 메서드가 오버로딩을 수행하려면 오버라이딩 메서드 위에 오버로드를 추가하면 된다.인터페이스를 이용해서 오버로딩을 구현할 수도 있다. 인터페이스를 이용해 오버로딩을 하려면 인터페이스에 오버로딩할 기본 메서드를 선언해 준다.그리고 인터페이스를 구현할 클래스에서 기본 메서드를 구현해 준다. 인터페이스를 사용하면 선언과 구현을 분리할 수 있고 구현부의 구조를 강제할 수 있다.이 점에서 로직과 구조가 섞여 있는 클래스를 상속해 오버로딩하는 것 보다 구조만을 포함하고 있는 인터페이스를 이용하는 것이 복잡도가 낮다. 다형성(polymorphism)다형성은 ‘여러 모양’을 의미하는 그리스 단어이고, 다형성에서 형은 타입을 의미한다. 프로그래밍 언어에서 다형성이란,여러 타입을 받아들임으로써 여러 형태를 가지는 것을 의미한다. 타입스크립트에서 살펴볼 수 있는 다형성의 예로는 다음 세 가지가 있다. 클레스의 다형성 인터페이스의 다형성 매개변수의 다형성 클래스의 다형성부모 클래스 A를 자식 클래스 B가 상속할 때 부모 클래스 A가 변수의 타입으로 지정되면 자식 클래스의 객체에 할당될 수 있다.이 때 부모 클래스 A는 부모 클래스 A를 상속하는 어떤 자식 클래스의 타입이라도 받아들일 수 있는 다형 타입이 되고, 다형성을 띠게 한다.런타임 시에 호출될 메서드가 결정되는 특성을 런타임 다형성이라고 한다. 런타임 다형성의 대표적인 예로 덕 타이핑(duck typing)이 있다. 인터페이스의 다형성인터페이스 A가 있고 인터페이스 A를 구현한 클래스 B가 있을 때 클래스 B가 인터페이스 A 타입으로 지정된 변수에 할당될 때 생기는 다형성을 의미한다.인터페이스를 구현한 클래스를 가지고 객체를 생성하면, 해당 객체 참조변수는 인터페이스에 정의된 멤버 변수, 메서드 등에 접근할 수는 있지만, 구현 클래스에 추가된 멤버 변수나 클래스에는 접근할 수가 없다. 매개변수의 다형성메서드의 매개변수가 여러 타입을 받아들이면서(유니언 타입, 인터페이스 타입 등) 생기는 다형성을 말한다.매개변수의 타입이 여러 서브 타입을 받아들아면 해당 매개변수의 타입이 서브 타입 다형성이 된다. 반대로 자바스크립트의 매개변수처럼 타입을 지정하지 않고 여러 타입을 받아들이면 매개변수 다형성이 된다. Getter와 Setter자바스크립트에서는 객체의 멤버에 접근할 수 있는 방법으로 ES6의 getter와 setter를 지원한다. getter는 일반적으로 접근자(accessor)라 하고,setter는 설정자(mutation)라 한다. 타입스크립트에서는 클래스 내에 get과 set 키워드를 통해 getter와 setter를 선언할 수 있다.값을 설정하거나 읽을 때 로직을 추가하고 싶다면 get/set 키워드로 접근자와 설정자를 추가해 줄 수 있다. 정적 변수와 정적 메서드타입스크립트에서는 static 키워드를 지원한다. static 키워드는 클래스에 정적 멤버 변수나 정적 메서드 등을 선언할 때 사용할 수 있는데객체 생성 없이 바로 접근이 가능하므로 메모리 절약 효과가 있다. static 키워드는 클래스에 선언된 멤버 변수를 객체 생성 없이 접근할 수 있게 해주는 장점이 있다.이 경우 단일 상태를 관리하지만 외부에 변수를 둘 수 없는 문제점이 있다. 반드시 클래스를 통해 정적 멤버에 접근해야 하기 때문이다.외부에 변수를 두면서 프로그램 단위에서 유일한 객체를 유지할 수 있게 하려면 싱글턴 패턴(Singleton Pattern)을 도입해야 한다.싱글턴 패턴은 유일한 객체를 생성해 공유해서 사용하는 방식이다. 싱글턴 패턴에는 크게 두 가지가 있다. 부지런한 초기화(eager initialization) 게으른 초기화(lazy initialization). 부지런한 초기화부지런한 초기화는 프로그램이 구동될 때 초기화가 일어나고 공개된 정적 메서드를 통해 생성된 객체를 얻는다.싱글턴 객체는 사용자가 정의한 임의의 변수에 할당돼 접근할 수 있다. 게으른 초기화게으른 초기화는 프로그램이 구동될 때 초기화되지 않지만 공개된 정적 메서드를 호출하는 시점에 객체를 생성한다. 싱글턴 객체는 변수에 할당될 수 있다. readonly 제한자readonly는 타입스크립트 2.0부터 지원하는 제한자이다. readonly가 선언된 변수는 초기화되면 재할당이 불가능하다.const와 readonly의 공통점은 상수 선언이 가능하다는 점이다. 차이점은 다음과 같다. const는 초기화가 필수이지만, readonly는 초기화가 선택이다. const는 값 재할당이 불가능하지만, readonly는 가능하다. const는 선언 가능한 대상이 전역 변수, 클래스 메서드의 변수, 함수의 변수 등이 있고 readonly는 선언 가능한 대상이 인터페이스의 멤버 변수,클래스의 멤버 변수, 객체 리터럴의 속성, 새롭게 정의하는 타입 등이 있다. const는 상수로 사용하고, readonly는 읽기 전용 속성을 가지고 있다. const는 ES6인 경우 컴파일 후 선언이 유지되고, readonly는 컴파일 후 사라진다.","link":"/2020/04/29/TypeScript-class-Interface/"},{"title":"타입스크립트 - 함수","text":"함수는 애플리케이션의 코드를 구성하는 기본 요소입니다. 타입스크립트에서 함수는 클래스나 네이스페이스 내에 선언할 수 있고 때론 모듈로서 사용됩니다. 자바스크립트에서 함수를 선언했던 것과 동일한 방식으로 선언해 사용자가 원하는 단위 기능을 수행 할 수 있습니다. 다른 점이 있다면 함수의 매개변수나 반환값에 타입을 지정해 타입 안전성을 강화할 수 있습니다. 자바스크립트 함수기명 함수와 익명 함수의 선언함수의 이름을 명시해 선언하는 기명 함수(named function)와 함수의 이름을 명시하지 않고 사용하는 익명 함수(anonymous function)로 나뉩니다. 기명 함수는 호출될 때 호이스팅이 발생합니다. 따라서 함수를 선언하기 전에도, 함수를 선언한 후에도 호출 할 수 있습니다. 반면 익명 함수는 함수를 할당한뒤에만 호출 할 수 있도록 제한 할 수 있습니다. 자바스크립트 함수의 불안전성자바스크립트는 느슨한 타입언어 입니다. 매개변수의 타입이나 반환 타입은 없지만, 프로그램이 실행될 때 동적으로 타입을 할당해 추론된 타입이 지정됩니다. 타입이 없기 때문에 런타임 때 의도하지 않은 타입 변환이 일어날수 있다는 문제가 있습니다. 타입을 고정할 수 없어 때로는 타입 안정성을 갖추기 위해타입 검사와 타입 캐스팅과 같은 불필요한 코드를 추가할 수밖에 없습니다. 타입스크립트 함수타입스크립트는 함수의 매개변수나 반환 타입을 추가해 타입 안전성을 강화합니다. 매개변수에 타입을 지정해 숫자 값만 받을 수 있도록 타입을 제한할 수있고, 함수의 반환 타입을 지정해 잘못된 타입의 값이 반환되지 않도록 합니다. 1function ex(x: number, y: number): number { ... } 위와 같이 함수에 매개변수 타입이나 반환 타입을 추가하는 과정을 함수에 대한 타입지정(typing)이라 합니다. 매개변수의 활용기본 초기와 매개변수기본 초기화 매개변수는 함수의 특정 매개변수에 인수가 전달되지 않으면 매개변수에 설정된 초깃값으로 값을 초기화하는 기능입니다. 1x: number = 2 매개변수 목록에는 일반 매개변수와 기본 초기화 매개변수를 함께 선언할 수 있습니다. 1function ex2(x: number, y: number = 2): number 나머지 매개변수나머지 매개변수는 ES6에서 제안된 특징으로 개수가 정해지지 않은 인수를 배열로 받을 수 있는 기능입니다. 개수가 정해지지 않은 만큼 순서가 크게중요하지 않은 여러 요소를 전달하는 데 유용합니다. 나머지 매개변수는 “…”형태로 선언합니다. 1234function rest(...restParams) {...}// 나머지 매개변수에 타입 지정function rest(...restParams: string[]) {...} 나머지 매개변수는 0개 이상의 요소를 받을 수 있습니다. 나머지 매개변수에 타입을 추가하면 지정한 타입의 인수만 받을 수 있습니다. 선택 매개변수함수 호출 시 매개변수를 선언한 만큼 인수를 전달해야 합니다. 나머지 매개변수는 0개 이상의 인수를 받으므로 매개변수에 나머지 매개변수만 선언돼 있다면 인수 전달을 생략해도 됩니다. 선택 매개변수는 변수명 뒤에 물음표를 붙이는 식으로 선언합니다. 선택 매개변수를 이용하면 선택 매개변수로 지정한 매개변수는 생략이 가능합니다. 1function select(a: number, b?: number): number {...} 함수 호출 시 함수에 선언된 매개변수는 2개지만, 두 번째 매개변수는 선택 매개변수를 사용함으로써 인수 하나를 생략해 호출하더라고 에러가 발생하지않습니다. 앞에서 사용한 매개변수 초깃값을 설정하는 방법은 선택 매개변수와 결합해서 사용할 수 없습니다. 함수 오버로드함수 오버로드는 함수명은 같지만, 매개변수와 반환 타입이 다른 함수를 여러 개 선언할 수 잇는 특징을 말합니다. 12345function add(a: string, b:string): string;function add(a: number, b:number): number;function add(a: any, b:any): any { return a + b;} 가장 일반적인 함수의 시그니처를 가장 아래에 선언하고 그 위로 구체적인 타입을 명시한 함수의 시그니처를 쌓는 방식으로 선언해야 합니다.이때 매개변수의 개수가 다른 오버로드를 지정할 때는 선택 매개변수를 둬 매개변수 개수에 변화를 줄 수 있도록 허용할 수 있습니다. 익명 함수익명 함수와 화살표 함수화살표 함수(arrow function)는 ES6 표준에 포함된 익명 함수를 좀 더 간략하게 표현 할 수 있는 방법입니다. 파이선, C++, 자바 8에서는화살표 함수를 ‘람다 함수(lambda function)’ 라고도 부릅니다. 123() => {};let x = () => {};let y = x => { return x; }; 매개변수가 1개일 때는 화살표 함수의 매개변수 목록에 있는 소괄호를 생략할 수 있습니다. 변수에 할당하지 않고 화살표 함수를 사용하려면 즉시 호출 함수를 이용해야 합니다. 12(x => { x; })(1);let iif = (x => { return x; })(1); 즉시 호출 함수가 반환값을 가져 변수에 할당해야 한다면 중괄호 내부에서 return 키워드를 사용, 실행하면 변수 iif에 즉시 호출 함수가 반환한값이 할당 됩니다. 필터 메서드필터 메서드는 배열에서 조건에 맞는 요소를 추출 하는데 사용합니다. 123456let numbers = [1, 2, 3, 4, 5];numbers = numbers.filter(n => { return n % 2 === 0;})console.log(numbers);// 결과 [ 2, 4 ] 리듀스 메서드배열 값의 합을 손쉽게 구할 때는 리듀스 메서드를 이용할 수 있습니다. 리듀스 메서드는 누산기의 원리처럼 배열의 요소를 왼쪽에서 오른쪽으로 더해나가면서 누산된 값을 처리 할 수 있는 함수입니다. 1[1, 2, 3, 4, 5].reduce((a,b) => { return a + b; }) 리듀스 메서드의 첫 번째 매개변수는 누적된 값이고 두 번째 매개변수는 현재 카운터의 값입니다. 객체 리터러릥 선언과 객체 리터럴 타입의 선언객테 리터럴은 여러 속성과 값을 한 단위로 묶어서 표현할 수 있는 객체입니다. 속성은 키(key)가 되고 값(value)은 숫자나 문자열뿐만 아니라사용자가 정의한 객체도 할당 할 수 있습니다. 정의한 객체 리터럴 내부에서 다른 프로퍼티를 참조할 일이 많다면 객체 리터럴의 타입을 선언해 내부참조를 함으로써 코드 어시스트가 동작하게 할 수 있습니다. 인터페이스를 이용해 객체 리터럴 타입을 선언1234interface PersonType { name: string; hello(this: PersonType, name2: string): string;} 유의할 점은 this 는 반드시 첫 번째 매개변수로 선언해야 합니다. 익명 함수의 함수 타입익명 함수의 타입 선언익명 함수는 변수에 할당할 수 있습니다. 함수 자체에 대한 타입을 함수 타입(function type)이라고 합니다. 1let exFunc = function(str1: string, str2: string): string { return str1 + str2}; 익명 함수의 매개변수나 반환값에 타입을 지정할 수 있지만 익명 함수가 구현체이므로 타입을 선언하면 형태가 복잡해집니다. 이러한 점을 개선하기 위해익명함수에 선언된 타입을 별도로 분리해 함수 타입으로 선언하면, 쉽게 파악할 수 있습니다. 1let exFunc: (str1: string, str2: string) => string = (str1, str2) => { return str1 + str2; }; 함수 타입을 type 앨리어스 를 이용해 별도로 분리하면 반복적으로 사용할 수 있습니다. 123type exType = (a: number, b: number) => number;let addValue: exType = (a, b) => a + b;let minusValue: exType = (a, b) => a - b; 각 변수에 함수 타입을 선언 했으므로 익명 함수의 매개변수 타입이나 반환 타입을 선언하지 않더라도 타입 안정성을 확보할 수 있습니다.","link":"/2020/04/01/TypeScript-function/"},{"title":"1. 프로그레시브 프레임워크 Vue.js - part 2","text":"Vue.js 의 특징Vue.js는 그 자체로는 뷰만을 다루는 단순한 라이브러리다. Vue.js 본체 뿐만 아니라 관련 라이브러리도 Vue.js 공식 프로젝트의 일부로서 개발 및 관리 된다. 이 때문에 몇가지 라이브러리를 조합하면 마치 종합적인 프레임워크처럼 사용 할 수 있다. 낮은 학습 비용Vue.js 가 제공하는 API는 매운 단순하다. UI를 구성하는 데는 HTML을 기반으로 하는 평범한 템플릿을 사용한다. HTML이나 자바스크립트에 이미 익숙하면 Vue.js 에 대해 특별히 더 배우지 않고서도 라이브러리를 사용할 수 있다. 기본적인 사용만 한다면 빌드 도구나 패키징, EC2015 이후 문법에 대한 지식이 없어도 바로 동작하는 코드를 작성할 수 있다. Vue.js 는 앞서 언급한 모던 웹 프런트 엔드 개발의 어려움을 잘 극복했다. HTML5 이후 고도화된 개발 스타일에 부응하면서도 개발 환경 구축이 쉬워서 개발을 바로 시작할 수 있으며 자바스크립트에 대한 사전지식과 라이브러리 고유의 문법을 학습하지 않아도 라이브러리를 사용할 수 있다. 컴포넌트 지향을 통한 UI 구조화Vue.js 는 구조화해 컴포넌트로 재사용할 수 있다. UI 구성 요소를 컴포넌트로 만들면 시스템 전체를 컴포넌트의 집합 형태로 개발 할 수 있다. 개발에 컴포넌트를 적용하면 컴포넌트 분리에서 오는 유지보수성 개선 및 컴포넌트 재사용 등 여러 장점이 있다. 리액티브 데이터 바인딩Vue.js 는 DOM요소와 리액티브 데이터 바인딩을 통해 자바스크립트 데이터를 연결해 준다. 리액티브 데이터 바인딩이란 HTML 템플릿 안에서 대상 DOM 요소에 바인딩 을 지정해 Vue.js 가 해당 데이터의 변화를 감지할 때마다 바인딩된 DOM 요소에 표시되는 내용도 함께 업데이트하는 것을 말한다. 값은 자바스크립트에서 DOM요소로 일방적으로 전달된다. 이것을 단방향 바인딩이라고 한다. 자바스크립트쪽에서 위치한 데이터 값이 변경되면 변경된 값이 웹 페이지에도 자동으로 반영되는 기능이다. input 요소등 사용자의 입력을 받는 DOM요소는 요소에서 받아온 데이터와 자바스크립트 데이터를 서로동기화하는 바인딩을 지정한다. 이런 경우 자바스크립트의 데이터 값이 변경될때마다 DOM요소의 표시 내용이 수정되며, 사용자의 입력이 감지될때마다 자바스크립트 데이터가 수정된다. 이런 방법으로 자바스크립트 데이터와 DOM요소 데이터의 동기화 상태를 유지한다. 이 방법은 자바스크립트와 DOM요소가 서로 최신 데이터를 주고받으므로 양방향 바인딩이라고 한다. 바인딩을 이용함으로써 귀찮은 표시 내용 업데이트 처리와 DOM 요소와 자바스크립트 간 데이터 동기화 상태 유지로부터 해당됐으며 데이터 중심 웹 애플리케이션 설계 및 구현이 가능해졌다. Vue.js의 설계사상Vue.js는 사용성 면에서도 뛰어난 라이브러리지만, 성능적인 측면을 비롯해 다른 장점도 많은 라이브러리다. 그러나 이와 비슷한 장점이 많은 라이브러리도 있다. Vue.js 가 이런 다른 라이브러리와 분명이 차별화 되는 점이 있다. 바로 밑바탕이 되는 설계사상이다. Vue.js의 설계 밑 바탕에는 프로그래시브 프레임워크(Progressive framework) 라는 아이디어가 깔려있다.‘프레임워크는 어떤 경우든지 규모와 상관없이 단계적으로 유연하게 사용할 수 있어야 한다.’ 라고 Vue.js를 만든 에반유가 처음 주창했다. 프레임워크의 복잡성웹 프런트 엔트 분야에는 React와 Angular 등 라이브러리와 프레임워크가 여러 가지 있다. 프레임워크는 애플리케이션 개발의 복잡성을 해소해주는 도구다. 그러나 애플리케이션과 마찬가지로 프레임워크에도 프레임워크 자체의 복잡성이 있다. 프레임워크라는 도구를 사용하려면 도구 자체의 복잡성에서 오는 비용과 애플리케이션 개발의 복잡성에서 오는 비용이 균형을 이루도록 적합한 프레임워크를 선택하는 것이 중요하다. 요구 사항의 변화를 수용할수 있는 프레임워크사이트 및 애플리케이션의 요규사항은 끊임없이 변화한다. 프레임워크도 이렇게 변화하는 요구사항에 맞춰 가치를 제공하려면 그만큼 유연하지 않으면 안 된다. 애플리케이션이 최초 완성되고 나면 변화하는 요구사항에 대응하기 위해 애플리케이션의 규모가 지족해서 커지게 마련이다. 대부분 애플리케이션 개발을 지원하는 라이브러리나 도구를 추가로 도입해 새로운 비즈니스 요구사항을 만족시키게 된다. 그러나 이렇게 새로운 요소를 덧붙이는 방법은 생각대로 되지 않는 경우가 많다. 웹 프런트엔드 생태계는 최근 끊임없이 변화하고 있기 때문에 애플리케이션에 도입한 프레임워크나 개발 환경이 얼마 지나지 않아 시대에 뒤떨어지게 되고 다시 어떤 프레임워크로 갈아타야 하는지조차 알 수 없는 상황에 직면하게 된다. 이런 상황에 대처하려면 요구 사항 변과에 단계적으로 대응해야 한다. 이러한 아이디어를 반영한 것이 바로 프로그래시브 프레임워크다. 프로그래시브 프레임워크는 무제를 해결할 수 있는 적합한 라이브러리를 적시에 도입해 문제를 해결한다. Vue.js는 뷰 계층에 초점을 맞춘 라이브러리다. Vue.js 프로젝트가 제공하는 부가적인 라이브러리와 개발환경 도구를 사용하면 프로그래시브 프레임워크가 된다. 프로그레시브 프레임워크가 제공하는 단계적 영역선언적 렌더링이 영역은 선언적 DOM 렌더링과 관련된 영역이다. HTML 템플릿에 렌더링 대상을 선언적으로 기술해 데이터가 변경될 때마다 DOM을 반응적으로 렌더링하고 사용자 입력 데이터를 동기화 할 수 있다,Vue.js 본체가 제공하는 기능이다. 컴포넌트 시스템UI를 모듈화해 재사용할수 있게 해주는 영역 이 영역 역시 UI 를 컴포넌트로 만들어주는 Vue.js 본체가 제공하는 기능이다. 클라이언트 사이드 라우팅단일 페이지 애플리케이션이 동작하기 위해 필요한 영역이다. 라우팅이란 간단히 말해 애플리케이션의 URL 설계, 지시와 같은 것이다. Vue.js의 공식 라우팅 라이브러리인 Vue Router를 사용하면 기존에 개발한 컴포넌트로 당일 페이지 애플리케이션을 만들 수 있다. 대규모 상태관리컴포넌트 간에 상태를 고유하는 방법을 필요로 하는 영역이다. Vue.js의 공식 데이터플로 아키텍처를 따라 만든 상태관리 라이브러리인 VUEX 를 사용하면 이 영역의 문제를 해결할 수 있다, 기존 컴포넌트를 확장하는 형태로 상태를 중앙에서 관리 할 수 있다. 빌드시스템웹 애플리케이션을 구성하는 컴포넌트 관리, 운영환경배포, 프로젝트 구성등과 관련된 영역이다. Vue.js의 공식 개발지원 도구를 이용해 이 영역의 문제를 해결할 수 있다, 프로젝트의 환경구축, 구성관리에 수고를 들이는 대신 개발에 집중할 수 있다. (Vue Cli) 클라이언트-서버데이터 퍼시스턴스웹애프리케이션의 복잡한 데이터는 클라이언트 사이드와 서버사이트 양쪽 모두에서 퍼시스턴스 데이터로 유지돼야 한다. 이 책을 쓰는 시점에는 이러한 분야의 문제를 해결해 주는 Vue.js공식 라이브러리가 아직 없으며 서드파티 라이브러리 사용자들이 직접 작성한 라이브러리를 사용해 구현한다. Vue.js의 기반 기술컴포넌트 시스템Vue.js는 컴포넌트를 쉽게 다루기 위한 라이브러리다. 컴포넌트 시스템에서 특기할 만한 기능은 단일 파일 컴포넌트다. Vue.js는 단일 파일에 HTML과 유사한 방식으로 컴포넌트를 작성할 수 있다. 이 파일은 .vue라는 독자적인 확장자를 사용한다. Vue.js 컴포넌트는 기존 웹 표준을 구성하는 기술과 유사한 형태로 정의되기 때문에 학습비용이 매우 낮은것이 특정이다. 파일하나에 컴포넌트의 모든 요소를 함께 담을 수 있다는 점은 큰 장점이다. 컴포넌트의 요점은 언어의 역할과는 별도로 기능이나 관심사를 기준으로 코드를 분리하는 것이기 때문이다. 하나의 관심사만을 같은 GUI 컴포넌트를 분리하려고 할때 HTML/CSS/JavaScript 3가지 요소를 하나의 파일로 합쳐 컴포넌트로 분리 할 수 있으므로 이해하기 쉽다. 리액티브 시스템Vue.js의 리액티브 시스템은 옵저버 패턴을 기반으로 구현 좀더 쉽게 셜명하면 상태의 변화를 Vue.js가 감지해 자동으로 그 변화를 DOM에 반영하는 구조라고 할 수 있다. DOM 을 더욱 정교하고 잦은 비도로 조작해야 하는 애플리케이션에서는 데이터 바인딩이 매우 유용하다. 라이브러리에 이러한 기능이 없다면 값의 변화에 따라 변화해야 하는 곳을 직접 변경하거나 갑의 변경에 따른 사이드 이펙트를 완전히 파악하지 못하고 임시변통으로 틀어막게 되기 쉽다. 뒤에 설명할 계산 프로퍼티는 이러한 리액티브 시스템 덕을 가장 크게보는 사례다. 계산 프로퍼티란 값의 변화를 탐지해 자동으로 업데이트 되는 프로퍼티를 말한다. Vue.js 템플릿에서 빼놓을 수 없는 기능이다. 리액티브 시트템은 리액티브 프로퍼티와 와처가 한 쌍을 이뤄 구현된다. 리액티브 시스템의 내부계산프로퍼티에서는 와처 내부의 게터가 계산 프로터티로 정의하는 함수 역할을 한다. 계산프로퍼티를 처음 참조하면 와처내부에 잇는 게터를 거쳐 리액티브 프ㄹ퍼티의 계산 결과가 와처에 캐싱되며 이와 함께 리액티브 프로퍼티의 의존관계 추적도 완료된다. 그 다음 이 계산 프로퍼티가 다시 참조될 때는 캐싱된 값을 반환해 계산 비용을 절약할 수 있다, 이후에 계산 프로퍼티에서 이 값이 의존하는 리액티브 프로퍼티의 일부가 대입 등의 이유로 변경되면 후크 처리를 통해 와처에 이 변경이 통지되면 내부 게터가 이 통지를 전달받아 프로퍼티 값을 다시 계산해 그 결과가 와처에 새로 캐싱된다. 반면 컴포넌트 렌더링에서는 와처 내부의 게터가 컴포넌트를 렌더링하는 함수 역할을 한다. 모든 컴포넌트가 와처를 갖고 있기 때문에 컴포넌트의 모든 데이터를 래액티브 프로퍼티로 모니터링 한다. 컴포넌트 렌더링은 모니터링 대상 중 어떤 리액티브 프로퍼티가 값이 변경됐다는 통지를 보내면 그때마다 와처의 게터가 실행돼 컴포넌트가 렌더링되는 구조다. 렌더링시스템Vue.js는 가장 DOM을 이용해 DOM을 고속으로 렌더링한다. 가상 DOM은 DOM을 간편하고 빠르게 제어하기 위한 기술이다. 더 편리하고 빠르게 다룰 수 있는 DOM 구조의 대체물을 만든 다음 이 대체물을 조작하고 그 결과를 실제 DOM에 반영한다. 다른라이브러리와 다른 점은 템플릿이 HTML과 유사해 개발이 쉽고 최적화가 잘 돼 있어 빠른 렌더링이 가능하다는 점이다. Vue.js의 생태계Vue.js는 뷰 계층에 초점을 맞춘 라이브러리이므로 엄밀히 말해 프레임워크는 아니다. 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능처럼 UI외적인 기능을 이용하는 웹애플리케이션을 개발하려면 추가 라이브러리가 필요하다. 웹애플리케이션 테스트 및 빌드, 개발 환경역시 직접 구축하지 않으면 안 된다. Vue Router : 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능을 제공하는 플러그인 Vuex : 대규모 웹 애플리케이션을 구축하기 위한 상태 관리 플러그인 Vue Loader : 컴포넌트의 고급 기능을 이용하기 위한 webpack 용 로더 라이브러리 Vue CLI : 웹 애플리케이션을 구축하기 위한 템플릿 프로젝트 생성 및 프로토타입을 추가 설정없이 빌드하기 위한 명령해 Vue DevToolls : Vue.js 애플리케이션을 브라우저의 개발자 도구로 디버깅할 수 있게 해주는 도구 Nuxt.js : 단일 페이지 애플리케이션과 서버 사이드 렌더링을 지원하는 Vue.js 애플리케이션을 개발하기 위한 프레임워크 Weex : Vue.js 문법을 사용해 IOS 및 안드로이드 애플리케이션을 개발할 수 있는 프레임워크 Onsen UI : 모바일 웹 애플리케이션을 개발하기 위한 프레임워크 커뮤니티에서 추천 플러그인, 라이브러리, 도구 등의 정보를 얻을 수 있다. Awesome Vue : Vue.js와 관련된 오픈 소스 프로젝트나 Vue.js가 사용된 웹 사이트 및 애플리케이션 정보를 공유하는 사이트 Vue Curated : Vue.js 코어 팀에서 엄선한 플러그인, 라이브러리, 프레임워크 등을 검색 할수 있는 공식 사이트 Vue.js 첫걸음123456789101112 Vue.js 시작하기 new Vue({ template: ‘{{ msg }}’, data : { msg: ‘hello world!’ } }).$mount(‘app’) Vue.js 참조문서 - 공식사이트 참고(https://vuejs.org) Vue.js 사용자 커뮤니티 Vue.js 포럼 : Vue.js 를 사용하다가 발생하는 트러블이나 질문 사항을 논의하는 사이트 Vue Land : Vue.js 사용자와 코어 팀 멤버 및 컨트리뷰터가 채팅을 커뮤니케이션 하는 커뮤니티 Vue.js 밋업 : 한국 Vue.js 사용자들이 Vue.js 지식과 정보를 공유하는 밋업 이벤트","link":"/2019/11/08/Vue-study-1.1/"},{"title":"타입스크립트 - 변수 선언과 기본 타입","text":"var 의 특징 호이스팅 함수 레벨 스코프(블록 레벨 스코프 지원 되지 않음) var의 첫 번째 특징은 호이스팅 입니다. 호이스팅은 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상입니다.두 번째 특징은 함수 레벨 스코프(function level scope)를 지원하므로 함수 내에서 선언한 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없다는 것이다. var 는 블록 레벨 스코프(block level scope)를 지원하지 않는다. 블록 레벨 스코프란 블록{} 내에서만 유효하고 블록 외부에서는 참조 할 수 없는 것을 말한다. 블록 레벨 스코프를 지원하는 하는 대표적인 선언은 다음과 같다. let, const 클래스, 인터페이스, 타입 에일리어스(type alias), enum 선언 let 의 특징호이스팅 방지와 블록 레벨 스코프를 지원할 방법으로 ES6에서 let 선언자가 나왔고, 타입스크립트에서도 let 선언자를 지원합니다. 다음과 같은 특징을 가지고 있습니다. 블록 내에서 변수를 중복 선언 방지 호이스팅 방지 선언할 변수에 블록 레벨 스코프 적용 const 의 특징const는 ES6의 특징이며 타입스크립트에서도 지원한다. let과 같은 블록 레벨 스코프를 지원하며 호이스팅을 일으키지 않습니다.let과 다른 점은 const는 변수를 상수로 선언할 때 사용한다는 점이다. const를 이용해 변수를 상수로 선언하면 선언할 때 초기화는 가능하지만 재할당되지 않는 읽기전용(read only) 변수가 됩니다.예외적으로 const로 선언한 변수라도 객체 리터럴의 속성으로는 변경할 수 있습니다. 123456const profile = { name : \"happy\", month: 8,}// const profile = \"unhappy\"; 재할당 불가능profile.name = \"happy2\"; // 속성에 할당 가능 이는 타입스크립트가 값 자체를 재할당하는 것은 허용하지 않지만, 속성값의 변경을 허용하는 특성이 있기 때문이다. 타입 검사와 타입선언타입 검사의 종류언어에 따라 수행하는 타입 검사의 종류는 크게 ‘정적 타입 검사(statically type checking)’와 ‘동적 타입 검사(dynamically type checking)’로 나뉩니다. 정적 타입 검사는 자바, C++ 등의 언어에서 사용하고, 동적 타입 검사는 실행시간에 타입검사를 수행하며 대표적으로는 자바스크립트가 있습니다. 타입스크립트는 ‘점진적 타입 검사(gradually type checking)’를 수행합니다. 점진적 검사를 하는 대표적인 언어로는 타입스크립트와 파이썬등이 있습니다. 점진적 타입 검사는 컴파일 시간에 타입 검사를 수행하면서 필요에 따라 타입 선언의 생략을 허용합니다. 타입스크립트에서 점진적 타이핑을 성명할 때 적절한 타입으로 any가 있습니다.any 타입은 모든 타입의 최상위 타입이며, 동적 타입과 정적 타입의 경계선에 있는 타입으로 타입스크립트에서는 특별히 다뤄집니다.any 타입으로 선언된 변수는 어떤 타입의 변수도 받아들이면서 심지어 타입이 없는 변수도 받아들입니다. 자바스크립트의 동적 타이핑자바스크립트에는 기본타입과 객체타입이 있습니다. 기본 타입은 Number, Boolean, String 과 같은 타입을 말하고, 객체 타입으로는 객체 리터럴, 배열, 내장객체가 있습니다.자바스크립트에는 타입이 있지만 타입을 강제할 수는 없고 값을 할당할 때 타입이 추론됩니다. 값을 변수에 할당 할때 타입이 정해지는 것을 동적 타이핑(dynamic typing)이라 합니다. 타입을 명시하지 않고 값을 할당하면 입력값에 따라 타입이 동적으로 정해지므로 정해진 타입을 예측할 수 없습니다. 따라서 변수의 안전한 사용을 위해서는 타입을 검사하는 코드를 불가피하게 추가 해야 합나다. 타입 스크립트 계층도 기본 타입기본 타입은 보편적으로 많이 사용되는 내장 타입으로서 타입 스크립트에서 지원하는 기본 타입의 종류는 다음과 같습니다. String, number, boolean symbol(ECMA 2015에 추가) enum 문자열 리터럴 문자열 값을 표현할 때 역따옴표를 이용할수 있는데 역따옴표를 이용하면 줄 구분 없이 문장을 입력할 수 있습니다. 또한, 역따옴표 내에는 내장 표현식을 이용할 수 있습니다. 객체 타입객체 타입은 속성을 포함하고 있으며, 호출 시그니처, 생성자 시그니처 등으로 구성된 타입입니다. 타입스크립트에서 지원하는 객체 타입의 종류는 다음과 같습니다. Array Tuple Function Constructor Class Interface tuple은 배열 요소가 n개로 정해질 때 각 요소별로 타입을 지정한 타입입니다. 예를 들어 배열 요소가 문자열과 숫자라면 [string, number] 같은 형태로 타입을 정의합니다. 기타 타입 유니언(Union) 인터섹션(Intersection) 특수 타입 유니언 타입은 2개 이상의 타입을 하나의 타입으로 정의한 타입입니다. 특수 타입으로 타입 계층도의 가장 아래쪽에 위치한 void, null, undefined 있습니다. void는 빈 값을 나타내는 타입입니다.함수에 반환값이 없을 때 void 타입을 선언할 수 있는데 undefined 나 null 값을 받을 때 사용합니다. non-nullable은 null이나 undefined를 허용하지 않는 타입이고, 룩업(lookup) 타입은 인터페이스를 이용해 키값을 설정할 수 있는 타입입니다. 객체 타입의 상위 타입으로 any 추가 any 타입의 특수 타입으로 유니언 타입과 인터섹션 타입추가 객체 타임의 하위 타입으로 Array, Interface, Tuple 추가 Void 타입 추가 변수에 타입 지정 [형식]var : = ; 변수에 타입을 명시적으로 지정할 수 있습니다. 명시적 타입표기를 하면 변수에 어떤 값이 할당될지 직관적으로 알 수 있습니다. 자바스크립트의 타입타입을 지정할 수 있는 타입스크립트와 달리 자바스크립트에서는 별도로 타입을 지정하는 절차가 없고, 런타임 시 변수에 값이 할당되면 동적으로 타입이 결정됩니다. symbol 타입ES6에서 추가된 특징으로 객체 속성의 유일하고 불변적인 식별자로 사용된다. Symbol 타입은 Symbol 함수를 이용해 다음과 같은 형태로 선언한다. 1let hello = Symbol(\"hello\"); Symbol 함수는 심벌 객체를 반환, 이때 Symbol 함수가 유일한 식별자를 생성하는 팩토리 함수의 역할을 합니다. Symbol 함수를 호출할 때 “hello” 인수는 심벌의 설명을 의미한다.설명은 심벌에 접근할 때 사용할 수 있으며, 생략할 수 있다. enum 타입enum 타입은 ES6에 제안된 타입으로, 컴파일 시간에 평가된다. 타입 계층도로 보면 number 타입의 하위 타입으로 자바스크립트로 컴파일된 후에는 객체 리터럴이나 배열처럼 객체 타입이 됩니다.typeof를 통해 타입 이름을 표시하면 object로 표시됩니다. enum은 명명된 숫자 상수의 집합을 정의할 때 사용합니다. 명명된 숫자 상수는 enum의 속성에 대응하는 값으로서 속성은 열거해 선언할 수 있습니다. [형식]enum Day { 속성: 값, 속성: 값, 속성: 값, … }; 타입스크립트의 내장 타입any 타입any 타입은 제약이 없는 타입으로 어떤 타입의 값도 받아들일 수 있습니다. 자바스크립트가 최소한의 정적 타입 검사를 수행하는 것처럼 최소한의 타입 검사만 수행 합니다.임의의 값을 받아들일 때 any 타입은 any 키워드로 선언할 수 있습니다. 123var basket: any = 10;basket = true;basket = \"banana\"; any는 확정된 타입은 아니지만 어떤 값이든 할당받을 수 있습니다. 뿐만아니라 배열의 타입으로 사용하면 어떤 타입의 요소도 받아들일 수 있으므로 유연하게 활용할 수 있습니다. any 타입은 모든 타입의 가장 최상위 타입입니다. 다시 말해 모든 타입은 any 타입의 하위 타입입니다. 그래서 any 타입은 자바스크립트의 모든 값을 할당 받을 수 있습니다. object 타입은 any 타입처럼 타입 구분 없이 값을 할당할 수 있는 특성이 있어 any 타입과 비슷하지만 속성 유무를 검사하는 시점이 다릅니다.any 타입으로 선언한 변수는 속성의 유무를 런타임 시에 검사하지만, object 타입으로 선언한 변수는 컴파일 시간에 속성의 유무를 검사합니다.따라서 object 타입의 변수에 숫자를 할당하더라고 컴파일 시에 숫자 메서드를 인식하지 못하므로 컴파일 시간에 에러가 발생합니다. noImplicitAny 옵션any 타입의 사용을 강제할때 컴파일 옵션 중 noImplicitAny를 true 로 설정합니다. tsconfig.json12345{ \"compilerOptions\": { \"noImplicitAny\": true }} noImplicitAny 옵션은 false 가 기본값이므로 noImplicitAny 옵션을 생략한다면 any 타입을 생략해도 괜찮습니다. 배열 타입과 제네릭 배열 타입배열은 여러 개의 값을 하나의 변수에 담아 관리하는 자료구조이다. 여러 값을 모아 담기 때문에 컬렉션(collections) 이라 불리기도 합니다.타입스크립트에서 배열 타입은 두 가지 형태로 나뉩니다. 배열 타입 (array type) 제네릭 배열 타입 (generic array type) 배열배열 타입은 타입스크립트 0.9 버전 부터 지원 됐으며 다음 같이 선언합니다. 1let myVar: number[] = [1, 2, 3, 4, 5]; 배열 타입은 요소 타입에 []를 붙여 선언합니다. 요소 타입으로는 string, number, boolean 과 같은 내장 타입뿐 아니라 클래스나 인터페이스도 올 수 있습니다.베열 요소의 타입이 정해져 있지 않다면 any 타입으로 지정할 수 있습니다. 1let myVal: any[] = [1, \"hi\", true] any 타입으로 지정하면 어떤 요소든 배열의 요소로 추가할 수 있습니다. 타입이 느슨하므로 타입을 제약하려면 유니언 타입을 이용해 선언합니다. 1let myVal: (number | string | boolean)[] = [1, \"hi\", true] 제네릭 배열제네릭 배열 타입은 타입스크립트 0.9 버전부터 지원됐으며 제네릭 배열 타입은 Array형태로 선언합니다. 이때 T 는 타입을 의미합니다. 1let num:Array = [1, 2, 3]; 타입을 숫자나 문자열 타입으로 제약하려면 유니언 타입으로 선언 1let num:Array = [1, \"hello\"]; 제네릭 타입 인수로 사용된 T는 컴파일 시점에 타입을 검사합니다. 타입스크립트에서 선언한 배열,제네릭 배열타입은 컴파일시 타입 검사를 위해 필요하고, 컴파일 후에는 타입이 제거된 배열만 남습니다. 튜플 타입튜플 타입은 n 개의 요소로 이뤄진 배열에 대응하는 타입을 의미합니다. 튜플은 배열과 비슷한데, 배열은 배열 요소의 개수에 제한이 없고 string[]처럼 특정 타입으로 배열 요소의 타입을 강제할 수 있습니다. 12let x: string[] = [ \"tuple1\", \"tuple2\"];let x: [string, number] = [ \"tuple1\", 100]; 타입 스크립트2.7 이전에는 배열의 요소가 튜플타입에 선언된 개수를 초과하면 유니언 타입을 적용받았습니다. 그런데 2.7이 되면서 튜플 타입에 따라 할당 배열의 요소 수도 고정됐습니다. void, null, undefinedvoid는 함수의 반환값이 없을 때 지정하는 타입입니다. void 타입에는 null이나 undefiend만 할당할 수 있습니다.반환값이 없을 때 이를 명시적으로 나타내기 위해 void를 지정합니다.null 이든 undefined 이든 불필요한 선언이 되거나 초기화하지 않았을 때 불안정한 연산을 초래할 수 있으므로 컴파일러 옵션에서 사용하지 못하게 막을 필요가 있습니다. tsconfig.json12345{ \"compilerOptions\": { \"strincNullChecks\": true }} 그럼 기본적으로 변수에 할당되번 null 과 undefined는 더 이상 할당되지 못하고 컴파일 오류를 발생시킵니다. Reference타입스크립트 퀵스타트 - 루비페이퍼","link":"/2020/03/18/TypeSctipt-3-var/"},{"title":"타입스크립트 - 모듈","text":"모듈(modules)은 독립 가능한 기능의 단위 입니다. 프로그램은 여러 모듈로 구성돼 있고 모듈을 결합해 하나의 프로그램을 만듭니다.모듈을 사용하면 다음과 같은 장점이 있습니다. 유지보수의 용이성 전역 스코프 오염을 방지 재사용성 향상 첫 번째 장점은 모듈을 사용하면 유지보수가 쉬워집니다. 공통기능을 모듈로 정의해 사용하면 애플리케이션의 전체적인 수정 없 모듈의 수정이나교체만으로도 코드를 효과적으로 수정할 수 있습니다. 두 번째 장점은 모듈은 전역 스코프 오염(global scope pollution)을 방지합니다. 전역 스코프틑 전역 이름 공간을 가지므로 변수의 이름이나함수 이름을 중복해 선언 할 수 없습니다. 그런데 변수나 함수등을 파일 내부에 한정해 모듈로 선언하면 이름 공간이 파일 단위로 제한되며 전역 이름 공간을 침범하지 않습니다. 세 번째 장점은 모듈을 사용하면 재사용성이 향상 됩니다. 모듈화를 잘 해두면 현재의 프로젝트뿐 아니라 다른 프로젝트에도 공유해 재사용할 수 있습니다. 모듈러 프로그래밍을 위한 접근모듈러 프로그래밍은 프로그램의 설계 기술로 모듈의 분리와 모듈의 손쉬운 교체에 관심이 있습니다. 상호 교환 가능한 모듈을 정의할 수 있어야 합니다.모듈러 프로그래밍의 첫 번째 과정은 모듈을 식별, 두번째는 모듈을 분리, 세번째 과정을 모듈을 공개 하는 것입니다.모듈을 외부로 공개함으로써 프로젝트 내에 존재하는 특정 파일에서 호출해 사용할 수 있게 됩니다. 내부 모듈과 외부 모듈내부 모듈의 네임스페이스는 여러 파일에 걸쳐 하나의 이름 공간을 공유하지만, 외부 모듈은 파일 모듈 파일마다 이름 공간이 정해집니다. 내부 모듈내부 모듈인 네임스페이스는 전역 이름 공간과 분리된 네임스페이스 단위의 이름 공간입니다. 참조할 때는 별도의 참조문을 선언하지 않아도 됩니다.네임스페이스는 전역 스코프에 속하지만 전역 스코프와 독립된 이름공간이라는 점. 외부 모듈export로 선언한 모듈을 외부 모듈이라 합니다. 흔희 말하는 모듈은 외부 모듈을 가리킵니다.외부 모듈의 이름 공간은 파일 내로 제한되므로 파일이 다르다면 외부 모듈의 이름이 같아도 괜찮지만 export를 생략해 외부 모듈로 선언하지않으면 전역 스코프의 이름 공간을 공유해 이름 충돌이 발생합니다. 네임스페이스네임스페이스는 하나의 독립된 이름 공간을 만들고 여러 파일에 걸쳐 하나의 이름 공간을 공유 할 수 있습니다.namespace와 module은 키워드는 다르지만, 역할과 기능상 차이가 없습니다. 타입스크립트 1.5 버전 이후에 내부 모듈을 선언 할 때는 module 대신에 namespace로 선언해야 합니다. 내부 모듈은 자바스크립트로 컴파일 될때 즉시 실행 함수로 변환됩니다. .js123(function (hello) { /* 내부 모듈의 이름 공간 */})(Hello || (Hello = {})); 즉시 실행 함수에서 hello 매개변수는 함수 외부에서 함수 내부의 이름 공간에 접근 할수 있게 하는 역할을 합니다. 프로젝트 단위 컴파일을 수행하지 않고 특정 파일만을 컴파일할 때는 같은 네임스페이스라도 외부에 선언된 네임스페이스를 인식할 수 없습니다.그럴땐 명시적으로 참조 경로를 선언해 줘야 합니다. 네임스페이스 모듈네임스페이스는 export를 이용해 모듈로 선언할 수 있습니다. 모듈로 선언되 네임스페이스는 import 문을 이용해 JS로 컴파일된 뒤에도 명시적으로모듈 호출(import문, require 함수 등)을 할 수 있습니다. 네임스페이스의 이름 확장네임스페이스 이름은 알파벳의 소문자와 대문자를 사용해 다음처럼 선언합니다. 1namespace Animal{...} 네임스페이스 이름은 예외로 점(.)을 허용합니다. 점을 이용하면 네임스페이스 간의 이름 계층을 만드는 효과가 있습니다.논리적인 이름 순서상 상위 이름은 앞에 선언돼야 하고 하위 이름은 상대적으로 뒤에 선언돼야 합니다. 브라우저에서 네임스페이스의 모듈 호출여러 타입스크립트 파일을 컴파일할 때 런타임시에 타입스크립트 파일을 인식하려면 가장 단순한 방법으로 out옵션으로 타입스크립트 파일을 컴파일하며 됩니다.그런데 브라우저 상황은 다소 다릅니다. 파일을 하나로 합치지 않고 타입스크립트 파일을 개별적으로 컴파일하고 import문을 사용하지 않더라고 브라우저가호출된 것처럼 인식합니다. 모듈 선언과 모듈 임포트타입스크립트 1.5부터는 ES2015 모듈 시스템을 지원합니다.ES2015 모듈 시스템은 export나 import 제한자를 통해 모듈을 선언하고 호출 할 수 있습니다. 모듈은 export로 선언해야 외부로 노출됩니다.export 키워드와 모듈 이름을 함께 선언해 모듈을 노출하는 방식을 명명된 내보내기(named exports)라고 합니다. 외부로 노출된 모듈은 import 키워드를 이용해 가져올 수 있습니다. 12345export interface Information {...}export function add(a: number, b: number) {...}import * as m from './module';import { add, sub } from './calc'; 여러 모듈을 함께 export하기변수나 배열 등도 모듈로 선언할 수 있습니다. 모듈을 개벌적으로 선언해도 되지만 모듈을 선언할 때마다 export 키워드를 붙이는건 불편합니다.이러한 점을 개선하기 위해 여러 모듈을 함께 export 해주면 편리합니다.만약 모듈로 선언할 대상이 인터페이스를 사용하는 함수일 때는 함수가 인터페이스와 의존관계가 있으므로 함수와 인터페이스를 함께 export해야 합니다. 123456let ver = '1.0';let author: string = 'happy';let extension = ['jpg', 'bmp', 'png'];let display = () => 'hello world';export { ver, author, extension, display }; 가져온 모든 모듈을 재노출재노출할 모듈이 많아 구체적인 이름을 열거하기가 불편할 때는 “export * from …”문법을 이용합니다. *은 모든 모듈을 의미합니다.모듈 파일을 재노출할 때 모든 외부 모듈을 의미하는 *에 대한 별칭이 없으므로 임포트 할 때는 as 키워드를 이용해 별칭을 추가해야 합니다. 1234export * from './module1';export * from './module2';import * as m from './module'; 모듈 파일에서 재노출한 전체 모듈을 참조할 수 있도록 m이라는 별칭을 추가 별칭 m은 재노출된 모듈에 접근할 수 있는 식별자로 이용됩니다. 네임스페이스로 감싸서 재노출네임스페이스는 독립된 이름 공간이며 export를 이용해 모듈로 선언할 수 있습니다. 1export namespace CarInfo{...} export로 선언하며 다른 파일에서 임포트할 수 있는 모듈이 됩니다. 네임스페이스는 이름공간을 정의해 하위에 여러 모듈을 포함할 수 있는 특성이 있습니다.이 때문에 네임스페이스를 기존에 흩어졌던 모듈을 다시 용도에 맞게 감싸서 재노출할 용도로 사용할 수 있습니다. 디폴트 모듈타입스크립트 1.5가 발표되기 전에는 모듈을 선언할 때 export-equals 문으로 할당 했고, 모듈을 호출 할 때는 import-equals 문으로 임포트했습니다. 12export = validatorimport Validator = require(\"validator\"); 타입스크립트1.5에서는 import-equals 문과 export-equals 문 대신 다른 형태의 키워드를 이용합니다. 12export default {...}import Validator from './module'; 이외에도 모듈을 선언하는 방법은 여럿 있습니다. 익명 함수의 디폴트 모듈선언, 기명함수의 디폴트 함수선언, 클래스 선언 123export default function(x: number) {...}export default function add(x: number) {...}export default class Hello {...} 디폴트 모듈은 default 키워드를 사용해서 선언합니다. 디폴트 모듈의 특성은 모듈파일에 최대 1개 까지만 선언할 수 있습니다.default 키워드를 두 번 사용하면 컴파일 에러가 발생합니다.임포트할 디폴트 모듈은 {}에 선언하면 안 되고 {}가 없이 선언해야 합니다. 1import p, {hello} from './defaul'; 이처럼 디폴트 모듈과 일반 모듈을 함께 임포트할 때는 디폴트 모듈은 이름만 선언하고 일반 모듈은 {} 내부에 모듈 이름을 선언해야 합니다. 모듈 시스템모듈 로더는 모듈 파일에 선언된 모듈을 실행할수 있습니다. 브라우저에서 동작하는 모듈로더는 느린로딩의 방식으로 모듈 파일을 가져와 모듈을 실행합니다.타입스크립트에서는 모듈을 정의하거나 호출할 때 ES2015 모듈을 이용합니다. 타입스크립트는 자바스트립트로 컴파일돼 실행 합니다.이때 ES2015 모듈이 표준이지만 더 많은 브라우저에서 지원하게 하고자 ES5 표준으로 컴파일 하되 ES2015 모듈은 모듈 로더를 통해 호출 할 수 있습니다. 모듈 로더마다 지원하는 명세가 다소 다릅니다. 최근 나오는 모듈 로더는 대체로 CommonJS 와 AMD 모듈 형식을 기본으로 지원합니다.","link":"/2020/05/14/Typescript-Module/"},{"title":"1. 프로그레시브 프레임워크 Vue.js - part 1","text":"Vue.js 철저입문 책을 읽으면서 간단하게 정리해 보고자 한다. Vue.js는 뷰 레이어에 특화된 라이브러리이다. MVVM패턴의 영향을 받은 설계를 채택하고 있어서 대규모 애플리케이션 개발에도 사용할 수 있습니다. 이러한 특징은 애플리케이션의 규모와 상관없이 어떠한 경우에도 단계적으로 유연한 적용이 가능해지는 프로그래시브 프레임워크라는 Vue.js의 설계사상에서 기인한다고 한다. 이 설계사상으로 인해 프로젝트 초기에는 최소한의 학습비용만으로 시험 적용이 가능하며 대규모 시스템에서는 단계적으로 필요한 기능및 라이브러리를 조합해 덧붙여 가는 독특한 스타일의 개발이 가능하다. Vue.js의 역사Vue.js는 2013년 에반유(Evan You)가 시작한 개인 프로젝트로 출발 2014년 2월 V0.8이 정식발표 2015년 5월에 PHP웹 애플리케이션 프레임워크인 라라벨에 표준 탑재된 것을 계기로 라라벨 커뮤니티에서 화제 2015년 10월 V1.0이 출시 2016년 10월 1일 V2.0이 출시 복잡해진 모던 웹 프론트엔드 개발모던 웹 프로트엔드 개발은 크게 고도화 되고 단일 페이지 애플리케이션(SPA)을 중심으로 프런트엔드 에서 복잡한 처리를 맡는 경우가 늘었으며 애플리케이션 데이터플로 설계, 라우팅, 유효성 체크 등 기존에는 백 엔드에서 맡았던 역할을 프런트 엔드가 맡게 됐다. 자바스크립트 역시 최근 몇년 사이 용도가 급격히 늘어났다. 이와 함께 업무와 관련된 개념과 도구가 함께 복잡해지는 경향을 보였다. 웹 탄생과 웹 기반 시스템의 발전웹(World Wide Web)은 지금부터 20년도 더 전인 1991년에 인터넷상에 처음 등장. 탄생 초기에는 문서 열람만을 목적으로 했으므로 당연히 지금 사용하는 SNS나 스프레드시트 같은 인터렉티브한 콘텐츠 는 구현이 불가능 했다. 1990년 후반부터 CSS와 자바스크립트가 웹 브라우저에 탑재됐다. 당시의 자바스크립트는 매우 빈약해 CSS와 함께 문서를 꾸미는 용도에 주로 사용 됐다. 비록 제약은 많았지만. 이들의 등장으로 웹페이지를 GUI 애플리케이션처럼 꾸밀 수 있게 됐다. CGI(Common Gateway Interface)로 대표되는 웹에서 사용되는 서버 사이드 프로그래밍 기술이 등장 웹 브라우저를 프리젠테이션 계층으로 삼는 웹기반 3계층 아키텍처 시스템이 등장 루비 온 레이즈로 대표되는 MVC기반 웹애플리케이션 프레임워크도 등장 당시 프런트엔드가 담당했던 기능은 css등을 이용한 시작적효과와 자바스크립트를 이용한 알림창, 입력을 받는 기능 정도가 고작이었다. Ajax의 등장프런트엔드의 기능은 보여주는 것에만 한정된다는 것이 상식이었던 적이 있다. 그러나 2005년에 구글이 지도 서비스 구글맵스를 출시하면서 이러한 상식이 뒤집어졌다. 같은 페이지 안에서 콘텐츠를 빠르고 인터랙티브하게 변화시키는 경쾌한 사용자 경험이 Ajax를 통해 가능해졌다. Ajax 의 등장 이후 클라이언트 사이드에서는 Ajax및 이를 이용한 DOM을 정교하게 조작하는 기능이 필요해졌다. 필요에 따라 등장한 jQuery등이 인기를 얻었다. 서버사이드 분야는 웹서버가 HTML 렌더링을 넘어 RESTful 기반 웹API 를 제공하게 됐다. 2000년대 말에는 HTML5와 ECMAScript를 중심으로 웹이 다시 크게 진화 Node.js가 등장하면서 웹프런트엔드 개발이 한층 복잡해졌다. HTML5의 등장HTML5는 2014년에 권고안이 나온 표준규격이다.그중 중요한 것은 Histrory API 인데 덕분에 페이지이동을 웹브라우저대신 자바스크립트로 핸들링할 수 있게 됐다. 이를 통해 화면이동없이 URL과 히스토리를 관리하며 전환할 수 있는 단일 페이지 애플리케이션을 만들수 있게 됐다. 이러한 변화에 따라 프리젠테이션 레이어의 프로그램이 서버사이드 에서 클라이언트 사이드로 옮겨오게 된다. 기존에는 HTML렌더링을 서버에서 수행했지만, 웹 API로 데이터를 받아올수 있게 되면서 클라이언트에서도 HTML 렌더링이 가능해졌기 때문이다. 이런 방식이 화면이동이 적기 때문에 더 뛰어난 사용자 경험을 제공할 수 있다. Node.js 와 자바스크립트 생태계의 진화2009년 에는 Node.js 가 등장 첫번째 변화는 자바스크립트 실행환경이 브라우저를 벗어난 것이다. Node.js 는 프런트엔드 개발과 테스트에 매우 유용한 환경이다. 두번째 변화는 패키지 관리자이자 패키지 리포지토리인 npm의 보급이다. 이에 따라 모듈(패키지)을 사용할수 있게 됐고 개발된 산출물을 다시 모듈화해 npm을 통해 배포하는 문화가 정착했다. ES2015 와 프로그래밍 언어로서의 진화웹 프런트엔드 개발이 고도화되던 와중에 문제가 된것이 자바스크립트의 빈약한 언어 기능이었다. 그래서 대대적인 규격 업데이트가 필요 했고 이에 ES2015(ES6) 가 등장했다.ES2015 는 자바스크립트 역사상 가장 큰 규모의 업데이트였다. 문법이 확장되고 const나 let등이 널리 쓰이게 되는 등 작성스타일에도 대대적인 변화가 있었다. 표준규격이 제안 됐다고 해서 곧바로 모든 브라우저에 구현이 적용되지는 않는다. 그러나 새로운 규격에는 기존의 불만을 해소할수 잇는 매력적인 것들이 많았고 그래서 이러한 규격을 브라우저에 구현해 사용하려는 움직임이 있었다.Babel 은 이러한 수요에 대응해 자바스크립트를 자바스크립트로 번역하는 컴파일러다. 차세대 문법을 따른 자바스크립트 코드를 아직 해당 규격이 구현되지 않은 브라우저에서 사용할 수 있는 자바스크립트 코드로 변화하는 것이다. React등 프런트엔드 라이브러리의 출현애플리케이션 데이터플로를 프런트엔드로 가져오는 등 설계 단계부터 개발 난이도를 상승시키는 것이 많았다. DOM을 웹 API와 연동시키는 것도 생각 없이 할수 있는 일이 아니다.애플리케이션을 구조화 할수 없는 jQury등을 사용해서는 구현하기가 어렵다 그러므로 MVC와 같은 애플리케이션구조를 지원하는 프레임워크가 필요해졌다. 그에따라 Backbone.js, AngularJS등 새로운 웹 애플리케이션 프레임워크 및 라이브러리가 속속 나타났다. 이런 상황에서 나타난 것이 페이스북이 개발한 React와 Flux 다.React는 뷰 라이브러리이고, Flux는 애플리케이션 아키텍처다. React 중심의 개발 스타일은 가상 DOM을 이용해 DOM 조작을 빠르게 수행했고, Flux 는 혼란스러워지기 쉬운 아케텍처에 방향을 제시해 큰 인기를 모았다. 현재 당면과제와 Vue.js모던 프런트 엔드 개발은 현재에 이르기까지 다음과 같은 변화와 새로운 문제점을 낳았다. HTML5 이후 웹이 애플리케이션 플랫폼으로 기능하게 되면서 API가 고도화 됨 Node.js 생태계의 발전과 개발 환경 구축의 난이도 증가 ES2015 이후 문법이 보강되면서 학습할 내용이 증가 React 이후 프런트 엔드 개발이 프레임워크화되면서 그에 따른 학습비용증가 정리하다보니 모던 프론트엔드 개발의 역사와 같이 나와있어서 생각보다 정리해야될 내용이 많았다.그래서 2파트로 나누어서 정리하기로 했다.","link":"/2019/11/08/Vue-study-1/"},{"title":"클로저(closure)에 대하여","text":"클로저의 의미클로저(closure)라는 영어단어의 사전적 의미는 ‘닫혀있음’, ‘폐쇄성’, ‘완결성’ 정도의 의미를 가집니다.그렇다면 자바스크립트에서의 클로저는 무슨 의미를 가지고 있을까요? 클로저(closure)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특징입니다.자바스크립트에서만 사용하는 개념이 아니다 보니 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있다고 합니다.다양한 서적에서 클로저를 정의하고 있는 문장들을 한번 살펴보겠습니다. 자신을 내포하는 함수의 컨텍스트에 접근 할 수 있는 함수 - 더글라스 크록포드, ‘자바스크립트 핵심 가이드’(한빛 미디어) 함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의 하는 것 - 에단 브라운, ‘러닝 자바스크립트’(한빛 미디어) 함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출 할 수 있는 함수 - 존 레식, ‘자바스크립트 닌자 비급’(인사이트) 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수 - 송현주, 고현준, ‘인사이드 자바스크립트’(한빛 미디어) 자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합 - 에릭 프리먼, ‘Head First Javascript Programing’(한빛 미디어) 로컬 변수를 참조하고 있는 함수 내의 함수 - 야마다 요시히로, ‘자바스크립트 마스터 북’(제이펍) 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수 - 유인동, ‘함수형 자바스크립트 프로그래밍’(인사이트) MDN 에서는 클로저에 대해 “A closure is the combination of a function and the lexical environment within which that function was declared.”직역해 보면“클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상” 정도가 되겠습니다. A함수 내부에서 B함수를 선언 했을 경우에A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에서 선언한 변수에 접근 가능합니다.내부 함수 B가 A의 lexical enviroment를 언제나 사용하는 것은 아닙니다. 내부함수에서 외부 변수를 참조하는 경우에 한해서만 사용 가능합니다. 간단하게 한번 정리해 보자면 \"어떤 함수에서 선언한 변수를 참조하는 내부 함수에서만 발생하는 현상\"이라고 볼 수 있겠습니다. 예제 112345678910var outer = function() { var a = 1 var inner = function () { console.log(++a) } inner()}outer()outer()outer() 코드펜 링크 실행순서를 살펴보면 outer 함수에서 변수 a를 선언했고, outer의 내부함수인 inner 함수에서 a의 값을 1만큼 증가시킨 다음 출력합니다.inner 함수에서는 a를 선언하지 않았기 때문에 스코프체인을 타고 outer 함수에 접근해서 a를 찾습니다.그리고 4번째 줄에서 2가 출력됩니다. outer 함수가 종료되면 저장된 식별자들(a, inner)에 대한 참조를 지웁니다.그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 컬렉터의 수집 대상이 됩니다.그래서 2를 3번 출력하게 됩니다.` 예제 21234567891011var outer = function() { var a = 1 var inner = function () { return ++a } return inner}var outerFunc = outer()console.log(outerFunc())console.log(outerFunc())console.log(outerFunc()) 코드펜 링크 위 예제를 살펴보면 inner함수의 실행 시점에는 outer함수는 이미 실행이 종료된 상태인데 outer함수의 Lexical environment에 접근할 수 있는 걸까요?이는 가비지 컬렉터의 동작 방식 때문입니다. 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다.그래서 예제를 보면 outer 함수는 실행 종료 시점에 inner 함수를 반환합니다.외부 함수인 outer 의 실행이 종료되더라도 내부 함수인 inner 함수는 언젠가 outerFunc를 실행함으로써 호출될 가능성이 열린 겁니다.언젠가 inner 함수의 실행 컨텍스트가 활성화되면 outer함수 a 의 값을 필요로 할것이므로 수집대상에서 제외됩니다. 예제1과 2의 다른점은 변수가 가비지 컬렉터에 포함 되었느냐 제외 되었느근냐 입니다.함수의 실행 컨텍스트가 종료돈 후에도 lexical environment가 가비지 컬렉터의 수집대상에서 제외되는 경우는 지역변수를 참조하는 내부 함수가 외부로 전달된 경우가 유일합니다.위 현상을 토대로 클로저의 정의를 다시 고쳐보자면 “어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상”이라고 할 수 있습니다. 외부로 전달하는 방법으로는 return 외에도 Window의 메서드(setTimeout 또는 setInterval), DOM의 메서드(addEventListener) 같은 경우도지역변수를 참조하는 내부함수를 외부로 전달 했기 때문에 클로저라고 할 수 있습니다. 클로저의 메모리 관리클로저의 메모리 소모는 본질적인 특정일 뿐입니다. ‘메모리 누수’라는 표현은 개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC(Garbage Collector)의 수거 대상이 되지 않는 경우에는 맞는 표현이지만 개발자가 의도적으로 참조 카운트를 0이되지 않게 설계한 경우는 ‘누수’라고 할 수는 없습니다.클로저의 메모리 관리 방법은 간단합니다.클로저는 어떤 필요의 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다. 그러면 필요성이 사라진 시점에 메모리를 소모하지 않도록 해주면 됩니다. 참조 카운트를 0으로 만들면 GC가 수거 해가고 이때 소모됐던 메모리가 회수 됩니다.참조 카운트를 0으로 만드는 방법은 식별자의 참조형이 아닌 기본형 데이터(null 이나 undefined)를 할당하면 됩니다. 예제 3 메모리 관리123456789101112var outer = function() { var a = 1 var inner = function () { return ++a } return inner}var outerFunc = outer()console.log(outerFunc())console.log(outerFunc())console.log(outerFunc())outer = null // outer 식별자의 inner 함수 참조를 끊음 클로저 활용 사례콜백 함수와 클로저콜백 함수 내부에서 외부변수를 참조하기 위한 방법으로 세가지가 있습니다. 콜백 함수를 내부 함수로 선언해서 외부 변수를 직접 참조하는 방법으로 클로저를 사용하는 방법 bind 메서드로 값을 직접 넘겨줘서 클로저를 발생 시키지 않는 대신 여러가지 제약이 있는 방법 콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용한 방법 접근 권한 제어(정보은닉)정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나 입니다.흔희 접근 한에는 public, private, protected 의 세 종류가 있습니다. public은 외부에서 접근 가능한 것 private은 내부에서만 사용하며 외부에 노출되지 않는 것 protected는 상속받은 클래스 또는 같은 패키지에서만 접근이 가능한 것(java) 자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직업 부여하도록 설계되어 있지 않습니다.그렇다고 접근 제한이 불가능 한 것을 아닙니다. 클로저를 활용해서 함수차원에서 public한 값과 private 한 값을 구분하는 것이 가능합니다. 정보은닉123456789var outer = function () { var a = 1 var inner = function () { return ++a } return inner}var outerFunc = outer()console.log(outerFunc()) outer 함수를 종료할 때 inner 함수를 반환함으로써 outer 함수의 지역변수인 a의 값을 외부에서도 읽을 수 있게 됐습니다.외부에서는 outer라는 변수를 통해 outer함수를 실행 할 수는 있지만 outer함수 내부에는 어떤한 개입도 할 수 없습니다.외부에서는 오직 outer함수가 return한 정보에만 접 할수 있습니다.그러니까 외부에 제공하고자 하는 정보들을 모아서 return하고, 내부에서만 사용 할 정보들은 return 하지 않는 것으로 접근 권한 제어가 가능한것입니다.return한 변수들은 공개맴버(public member) 가 되고, 그렇지 않는 변수들은 비공개 멤버(private member)가 되는 것입니다. 부분 적용 함수 (partially applied function)부분 적용 함수란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가,나중에 (n-m) 개의 인자를 넘기면 비로소 원래 함수의 실행 결과를 얻을 수 있게끔 하는 함수 입니다. 커링 함수 (currying function)커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말합니다.부분 적용 함수와 다른 점은 커링은 한 번에 하나의 인자만 전달하는 것을 원칙으로 합니다. 또한 중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 할 뿐으로, 마지막 인자가 전달되기 전 까지는 원본 함수가 실행되지 않습니다(부분 적용 함수는 여러 개의 인자를 전달할 수 있고, 실행 결과를 재실행할때 원본 함수가 무조건 실행됩니다). Reference 코어 자바스크립트 (위키북스)","link":"/2020/01/04/closure/"}],"tags":[{"name":"맵","slug":"맵","link":"/tags/맵/"},{"name":"셋","slug":"셋","link":"/tags/셋/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"Learning-JavaScript","slug":"Learning-JavaScript","link":"/tags/Learning-JavaScript/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"편집기","slug":"편집기","link":"/tags/편집기/"},{"name":"주석","slug":"주석","link":"/tags/주석/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"예외","slug":"예외","link":"/tags/예외/"},{"name":"에러","slug":"에러","link":"/tags/에러/"},{"name":"ERROR","slug":"ERROR","link":"/tags/ERROR/"},{"name":"try","slug":"try","link":"/tags/try/"},{"name":"catch","slug":"catch","link":"/tags/catch/"},{"name":"finally","slug":"finally","link":"/tags/finally/"},{"name":"이터레이터","slug":"이터레이터","link":"/tags/이터레이터/"},{"name":"제너레이터","slug":"제너레이터","link":"/tags/제너레이터/"},{"name":"함수","slug":"함수","link":"/tags/함수/"},{"name":"추상적사고","slug":"추상적사고","link":"/tags/추상적사고/"},{"name":"추상화","slug":"추상화","link":"/tags/추상화/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"날짜","slug":"날짜","link":"/tags/날짜/"},{"name":"시간","slug":"시간","link":"/tags/시간/"},{"name":"date","slug":"date","link":"/tags/date/"},{"name":"time","slug":"time","link":"/tags/time/"},{"name":"timezone","slug":"timezone","link":"/tags/timezone/"},{"name":"moment","slug":"moment","link":"/tags/moment/"},{"name":"리터널","slug":"리터널","link":"/tags/리터널/"},{"name":"변수","slug":"변수","link":"/tags/변수/"},{"name":"상수","slug":"상수","link":"/tags/상수/"},{"name":"데이터타입","slug":"데이터타입","link":"/tags/데이터타입/"},{"name":"원시타입","slug":"원시타입","link":"/tags/원시타입/"},{"name":"템플릿문자열","slug":"템플릿문자열","link":"/tags/템플릿문자열/"},{"name":"개발도구","slug":"개발도구","link":"/tags/개발도구/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"babel","slug":"babel","link":"/tags/babel/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"제어문","slug":"제어문","link":"/tags/제어문/"},{"name":"if문","slug":"if문","link":"/tags/if문/"},{"name":"반복문","slug":"반복문","link":"/tags/반복문/"},{"name":"for문","slug":"for문","link":"/tags/for문/"},{"name":"스코프","slug":"스코프","link":"/tags/스코프/"},{"name":"호이스팅","slug":"호이스팅","link":"/tags/호이스팅/"},{"name":"scope","slug":"scope","link":"/tags/scope/"},{"name":"객체","slug":"객체","link":"/tags/객체/"},{"name":"객체지향프로그래밍","slug":"객체지향프로그래밍","link":"/tags/객체지향프로그래밍/"},{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","link":"/tags/타입스크립트/"},{"name":"고급","slug":"고급","link":"/tags/고급/"},{"name":"Type","slug":"Type","link":"/tags/Type/"},{"name":"Advanced","slug":"Advanced","link":"/tags/Advanced/"},{"name":"alias","slug":"alias","link":"/tags/alias/"},{"name":"제네릭","slug":"제네릭","link":"/tags/제네릭/"},{"name":"generic","slug":"generic","link":"/tags/generic/"},{"name":"backup","slug":"backup","link":"/tags/backup/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"백업","slug":"백업","link":"/tags/백업/"},{"name":"쿠팡","slug":"쿠팡","link":"/tags/쿠팡/"},{"name":"파트너스","slug":"파트너스","link":"/tags/파트너스/"},{"name":"쿠팡파트너스","slug":"쿠팡파트너스","link":"/tags/쿠팡파트너스/"},{"name":"블로그","slug":"블로그","link":"/tags/블로그/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"ad","slug":"ad","link":"/tags/ad/"},{"name":"명령어","slug":"명령어","link":"/tags/명령어/"},{"name":"commend","slug":"commend","link":"/tags/commend/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"사용법","slug":"사용법","link":"/tags/사용법/"},{"name":"Study","slug":"Study","link":"/tags/Study/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"서버통신","slug":"서버통신","link":"/tags/서버통신/"},{"name":"비동기","slug":"비동기","link":"/tags/비동기/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"context","slug":"context","link":"/tags/context/"},{"name":"실행컨텍스트","slug":"실행컨텍스트","link":"/tags/실행컨텍스트/"},{"name":"posting","slug":"posting","link":"/tags/posting/"},{"name":"Wiriting","slug":"Wiriting","link":"/tags/Wiriting/"},{"name":"post","slug":"post","link":"/tags/post/"},{"name":"scaffolds","slug":"scaffolds","link":"/tags/scaffolds/"},{"name":"setting","slug":"setting","link":"/tags/setting/"},{"name":"domain","slug":"domain","link":"/tags/domain/"},{"name":"comment","slug":"comment","link":"/tags/comment/"},{"name":"disqus","slug":"disqus","link":"/tags/disqus/"},{"name":"댓글","slug":"댓글","link":"/tags/댓글/"},{"name":"gitflow","slug":"gitflow","link":"/tags/gitflow/"},{"name":"브런치전략","slug":"브런치전략","link":"/tags/브런치전략/"},{"name":"branch","slug":"branch","link":"/tags/branch/"},{"name":"themes","slug":"themes","link":"/tags/themes/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"icarus테마","slug":"icarus테마","link":"/tags/icarus테마/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"세팅","slug":"세팅","link":"/tags/세팅/"},{"name":"깃","slug":"깃","link":"/tags/깃/"},{"name":"깃허브","slug":"깃허브","link":"/tags/깃허브/"},{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"마크다운","slug":"마크다운","link":"/tags/마크다운/"},{"name":"draft","slug":"draft","link":"/tags/draft/"},{"name":"VScode","slug":"VScode","link":"/tags/VScode/"},{"name":"extension","slug":"extension","link":"/tags/extension/"},{"name":"확장프로그램","slug":"확장프로그램","link":"/tags/확장프로그램/"},{"name":"추천","slug":"추천","link":"/tags/추천/"},{"name":"설치방법","slug":"설치방법","link":"/tags/설치방법/"},{"name":"터미널","slug":"터미널","link":"/tags/터미널/"},{"name":"Terminal","slug":"Terminal","link":"/tags/Terminal/"},{"name":"gitbash","slug":"gitbash","link":"/tags/gitbash/"},{"name":"VisualStudioCode","slug":"VisualStudioCode","link":"/tags/VisualStudioCode/"},{"name":"설정","slug":"설정","link":"/tags/설정/"},{"name":"webstorm","slug":"webstorm","link":"/tags/webstorm/"},{"name":"GitFlowIntegration","slug":"GitFlowIntegration","link":"/tags/GitFlowIntegration/"},{"name":"jira","slug":"jira","link":"/tags/jira/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"프라미스","slug":"프라미스","link":"/tags/프라미스/"},{"name":"콜백","slug":"콜백","link":"/tags/콜백/"},{"name":"단일스레드","slug":"단일스레드","link":"/tags/단일스레드/"},{"name":"연산자","slug":"연산자","link":"/tags/연산자/"},{"name":"표현식","slug":"표현식","link":"/tags/표현식/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"배열","slug":"배열","link":"/tags/배열/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"배열메서드","slug":"배열메서드","link":"/tags/배열메서드/"},{"name":"회고","slug":"회고","link":"/tags/회고/"},{"name":"1년6개월","slug":"1년6개월","link":"/tags/1년6개월/"},{"name":"LSP","slug":"LSP","link":"/tags/LSP/"},{"name":"스터디","slug":"스터디","link":"/tags/스터디/"},{"name":"공부","slug":"공부","link":"/tags/공부/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"superset","slug":"superset","link":"/tags/superset/"},{"name":"개발환경","slug":"개발환경","link":"/tags/개발환경/"},{"name":"소개","slug":"소개","link":"/tags/소개/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"if","slug":"if","link":"/tags/if/"},{"name":"switch","slug":"switch","link":"/tags/switch/"},{"name":"for","slug":"for","link":"/tags/for/"},{"name":"while","slug":"while","link":"/tags/while/"},{"name":"조건문","slug":"조건문","link":"/tags/조건문/"},{"name":"클래스","slug":"클래스","link":"/tags/클래스/"},{"name":"인터페이스","slug":"인터페이스","link":"/tags/인터페이스/"},{"name":"class","slug":"class","link":"/tags/class/"},{"name":"interface","slug":"interface","link":"/tags/interface/"},{"name":"뷰","slug":"뷰","link":"/tags/뷰/"},{"name":"프레임워크","slug":"프레임워크","link":"/tags/프레임워크/"},{"name":"val","slug":"val","link":"/tags/val/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"hoisting","slug":"hoisting","link":"/tags/hoisting/"},{"name":"blockScope","slug":"blockScope","link":"/tags/blockScope/"},{"name":"모듈","slug":"모듈","link":"/tags/모듈/"},{"name":"module","slug":"module","link":"/tags/module/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"클로저","slug":"클로저","link":"/tags/클로저/"},{"name":"컨텍스트","slug":"컨텍스트","link":"/tags/컨텍스트/"}],"categories":[{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Learning-JavaScript","slug":"Study/Learning-JavaScript","link":"/categories/Study/Learning-JavaScript/"},{"name":"hexo","slug":"Programming/hexo","link":"/categories/Programming/hexo/"},{"name":"TypeScript","slug":"Study/TypeScript","link":"/categories/Study/TypeScript/"},{"name":"git","slug":"Programming/git","link":"/categories/Programming/git/"},{"name":"Axios","slug":"Programming/Axios","link":"/categories/Programming/Axios/"},{"name":"실행컨텍스트","slug":"Study/실행컨텍스트","link":"/categories/Study/실행컨텍스트/"},{"name":"comment","slug":"Programming/hexo/comment","link":"/categories/Programming/hexo/comment/"},{"name":"SEO","slug":"Programming/hexo/SEO","link":"/categories/Programming/hexo/SEO/"},{"name":"themes","slug":"Programming/hexo/themes","link":"/categories/Programming/hexo/themes/"},{"name":"Setting","slug":"Setting","link":"/categories/Setting/"},{"name":"Markdown","slug":"Programming/Markdown","link":"/categories/Programming/Markdown/"},{"name":"posting","slug":"Programming/hexo/posting","link":"/categories/Programming/hexo/posting/"},{"name":"backup","slug":"Programming/hexo/backup","link":"/categories/Programming/hexo/backup/"},{"name":"ad","slug":"Programming/hexo/ad","link":"/categories/Programming/hexo/ad/"},{"name":"setting","slug":"Programming/hexo/setting","link":"/categories/Programming/hexo/setting/"},{"name":"SSH","slug":"Setting/SSH","link":"/categories/Setting/SSH/"},{"name":"VScode","slug":"Setting/VScode","link":"/categories/Setting/VScode/"},{"name":"webstorm","slug":"Setting/webstorm","link":"/categories/Setting/webstorm/"},{"name":"zsh","slug":"Setting/zsh","link":"/categories/Setting/zsh/"},{"name":"Extension","slug":"Setting/VScode/Extension","link":"/categories/Setting/VScode/Extension/"},{"name":"gitbash","slug":"Setting/VScode/gitbash","link":"/categories/Setting/VScode/gitbash/"},{"name":"회고","slug":"회고","link":"/categories/회고/"},{"name":"Vue.js 철저입문","slug":"Study/Vue-js-철저입문","link":"/categories/Study/Vue-js-철저입문/"},{"name":"클로저","slug":"Study/클로저","link":"/categories/Study/클로저/"}]}