{"pages":[{"title":"About","text":"안녕하세요 미슈카 입니다.미슈카는 러시아어 이름 미하일(Михаи́л)의 애칭이며 '곰돌이'라는 뜻을 가지고 있습니다. 특이하게 저의 전공은 무대미술입니다. 우연한 계기로 웹쪽 일을 접하게 되어웹 퍼블리셔로 시작하여 현재는 프론트엔드 개발자로 전향해 열심히 개발을 하고 있습니다. 개발을 공부하면서 알게 되는 것들과 남겨야 할것 들을 정리하기 위해 블로그를 운영하고 있습니다. 잘못된 부분이 있거나 논의가 필요한 부분은 댓글이나 메일로 남겨주시면 감사하겠습니다.모든 댓글에 답글을 달고 있습니다. 댓글은 소통이라고 생각하며 모든 댓글에 답글을 달아드립니다. Career밀랑 주식회사 - Front end Developer (2019.09 ~ 현재) (주)라이프스타일프로젝트 - Web Publisher (2018.02 ~ 2019.08) 카페24 솔루션 이용한 쇼핑몰 구축 (미프,대디프로젝트,글램모먼트,매드비타) 쇼핑몰 월별 프로모션 구축 HTML/CSS/Jquery/PHP 를 이용한 브랜드 사이트 구축 (라이프스타일프로젝트) 허브디앤씨 - Web Publisher (2017.03 ~ 2017~11) HTML/CSS/Jquery 를 이용한 다양한 반응형 사이트 구축 (동거동락,스트리미 등)","link":"/about/index.html"}],"posts":[{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 1. 첫 번째 애플리케이션","text":"이 포스팅은 시리즈는 러닝 자바스크립트 스터디를 하면서 개인적으로 정리의 필요성을 느끼고 정리를 위해 나만의 방법으로 정리해 놓은 포스팅입니다.저작권 문제가 발생시에 수정 될 수 있으며 해당 책없이는 의미가 없는 포스트 입니다. 책은 꼭 구매해서 봅시다. ^^ 자바스크립트의 간단한 역사 자바스크립트는 1995년 넷스케이프 커뮤니케이션즈의 개발자였던 브랜더 에이히가 개발했습니다. 자바스크립트의 원래 이름은 모카(mocha)였다. 1995년 출시된 넷스케이프 내비게이터에서 자바스크립트라는 이름을 공식적으로 사용하기 전까지 잠시 라이브 스크립트라는 이름으로 불렸다. 자바와 이름이 비슷한 이유는 마케팅 시도였다고 한다. 1996년 11월 넷스케이프는 ECMA에 자바스크립트를 제출, ECMAScript와 자바스크립트는 같은 것이라 생각해도 무방하다. ES6 : ECMAScript 6 즉 ES6는 2015년 6월에 발행 - ‘ES6 하모니’, ‘하모니’, ‘ES6’, ‘ES2015’, ‘ECMAScript 2015’는 모두 같은 말이다. 편집기를 사용해야 하는 이유 문법하이라이트 괄호 맞춤기능 코드 접기 자동완성 주석주석에는 한줄 주석와 여러 줄 주석이 있다. javascript12// //한줄주석/*내용*/ //여러줄주석:css와 동일한 형태를 하고 있다. 자바스크립트의 위치&lt;script&gt;를 헤드에 넣을 수도 있지만, 그렇게 하면 성능이 다소 떨어지고 헤드가 지나치게 복잡해지므로 바디 마지막에 놓습니다. 웹브라우저가 HTML 문서를 해석 할때 &lt;script&gt;태그를 만나면 그 안에 있는 JavaScript의 처리가 다 끝날때까지 다른 HTML의 해석을 멈추기 때문에 사용자 입장에서 HTML페이지가 화면에 다 그려지기까지 더 오래걸리게 됩니다.그래서 바디 마지막에 두는것을 권하고 있다.*참고링크 : 브라우저는 어떻게 동작하는가? 비동기적 이벤트사용자 입력은 비동기적이다. 비동기적 이벤트란 이벤트가 언제 일어날지 프로그래머가 전혀 알 수 없는 이벤트를 말한다.쉽게말해 사용자가 무엇을 입력할지 예측할 수 없다는 말이다. Hello, World!Hello, World! 애플리케이션은 1978년 브라이언 커니핸과 데니스 리치가 쓴책 “The C Programming Language”에서 시작되어 프로그래밍 언어 입문서에서는 “Hello World”를 출력하는 프로그램을 보여주는 것이 전통처럼 굳어졌다. 위에서 언급하지 않는 내용들은 중요도가 낮거나 다른 챕터에서 심화있게 다루는 내용들이어서 건너 뛰었다.","link":"/2019/06/19/Learning-JavaScript-chapter1/"},{"title":"Hexo 검색엔진 최적화(SEO) 시켜보기","text":"Hexo 블로그를 만들고 나서 이번에 적용해 보려고 하는 것은 검색엔진 최적화(SEO)였다.다행히 Hexo에는 SEO관련 플러그인들이 많이 있었다.그 중에 많이 쓰이고 해당 블로그에 적용한 플러드인들을 소개합니다. SEO SEO란?영어로 Search Engine Optimization 의 약자이며, 검색엔진 최적화 라는 의미를 가지고 있습니다.검색엔진에 맞게 사이트를 제작 및 운영하는 과정 전부를 뜻합니다. 플러그인 설치 및 설정 - hexo-auto-canonical메타 태그 중 canonical 속성을 대표 URL을 뜻합니다.각 포스트마다 자동으로 표준 링크를 만들어 줍니다. 설치 1npm install --save hexo-auto-canonical 설정HEAD에 위치 하도록 아래 내용을 추가해줍니다. ejs 의 경우 1&lt;%- autoCanonical(config, page) %&gt; jade 의 경우 1| !{ autoCanonical(config, page) } - hexo-autonofollow해당 포스트에서 참고하고 있는 외부링크에 nofollw 속성을 자동으로 추가해줍니다. 설치 1npm install hexo-autonofollow --save 설정_config.yml 파일에 아래 내용을 추가합니다. 12345nofollow: enable: true exclude: - exclude_1.com - exclude_2.com - hexo-generator-seo-friendly-sitemap사이트 맵을 제출하면 크롤러가 효율적으로 크롤링을 할 수 있습니다.자동으로 sitemap.xml을 생성해 줍니다. 설치 1npm install hexo-generator-seo-friendly-sitemap --save 설정_config.yml 파일에 아래 내용을 추가합니다. 1234sitemap: path: sitemap.xml tag: false category: false path값을 지정한 root폴더에 sitemap.xml이 생성됩니다.&lt;사이트주소&gt;/sitemap.xml 경로에서 확인 할 수 있습니다. tag : sitemap에 tag 포함 여부를 결정합니다. category : sitemap에 category 포함 여부를 결정합니다. - hexo-generator-feed자동으로 Atom 1.0또는 RSS2.0 피드를 생성해 줍니다. 설치 1npm install hexo-generator-feed --save 설정_config.yml 파일에 아래 내용을 추가합니다. 1234feed: type: rss2 path: rss2.xml limit: 20 네이버에서 Atom을 지원하지 않기 때문에 RSS2로 설정해 줍니다. type : 피드의 종류 (atom/rss2) path : 피드가 생성될 경로 (Default: atom.xml/rss2.xml) limit : 최신 포스트의 개수 설정 (0 또는 false 입력 시 모든 포스트) - hexo-generator-robotstxt자동으로 robots.txt 파일을 생성해 줍니다. 설치 1npm install hexo-generator-robotstxt --save 설정_config.yml 파일에 아래 내용을 추가합니다. 12345robotstxt: useragent: \"*\" allow: - / sitemap: https://&lt;username&gt;.github.io/sitemap.xml Deploy를 해주신 후에각 검색엔진에서 SEO설정을 해줍니다.","link":"/2019/06/11/Hexo-seo/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 10. 맵과 셋","text":"ES6에서 도입 맵은 키와 값을 연결한다는 점에서 객체와 비슷셋은 중복을 허용하지 않는다는 점만 제외하면 배열과 비슷 맵키와값을 연결할때 객체를 사용하면 발생하는 단점 프로토타입 체인 때문에 의도하지 않은 연결이 생길 수 있다.객체 안에 연결된 키와 값이 몇 개나 되는지 쉽게 알아낼 수 있는 방법이 없다.키는 반드시 문자열이나 심볼이어야 하므로 객체를 키로 써서 값과 연결 할수 없다.객체는 프로퍼티 순서를 전혀 보장하지 않는다.Map 객체는 이들 결함을 모두 해결, 키와 값을 연결할 목적이라면 객체보다 나은 선택이다. set()메서드를 써서 사용자 역할을 할당역할을 알아볼때는 get()메서드맵에 존재하지 않는 키에 get을 호출하면 undefined를 반환한다.맵에 키가 존재하는지 확인하는 has()메서드맵에 이미 존재하는 키에 set()을 호출하면 값이 교체size프로퍼티는 맵의 요소 숫자를 반환keys()메서드는 맵의 키를 반환values()메서드는 값을 반환entries()메서드는 첫 번째 요소가 키이고 두 번째 요소가 값인 배열을 각각 반환 이터러블 객체보다 배열이 필요하다면 확산연산자(…)를 사용맵의 요소를 지울때는 delete()메서드맵의 요소를 모두 지울때는 clear()메서드 위크맵다음 차이점을 제외하면 Map과 완전히 같다.키는 반드시 객체여야 한다.WeekMap의키는 가비지 콜렉션에 포함될 수 있다.WeekMap은 이터러블이 아니며 clear() 메서드도 없다. 셋셋은 중복을 허용하지 않는 데이터 집합이다. 사용자역할을 추가할 때는 add()메서드 - 추가하려는 것이 이미 있다면 아무일도 일어나지 않는다. size프로퍼티는 셋의 요소 숫자를 반환역할을 제거할 때는 delete()메서드 - 제거에 성공하면 true를 반환, 그렇지 않다면 false를 반환 위크셋위크셋은 객체만 포함 할 수 있다. 가비지 콜렉션의 대상이된다.이터러블이 아니다. 위크셋의 실제 용도는 주어진 객체가 셋안에 존재하는지 아닌지를 알아보는 것 뿐이라고 해도 과언이 아니다.","link":"/2019/08/02/Learning-JavaScript-chapter10/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 12. 이터레이터와 제너레이터","text":"이터레이터이터레이터는 ‘지금 어디있는지’ 파악할 수 있도록 돕는다는 면에서 일종의 책갈피와 비슷한 개념이다. 배열은 이터러블 객체의 좋은 예이다. 책에 여러 페이지가 있는 것처럼 배열에는 여러 요소가 들어 있으므로 책에 책갈피를 끼울수 있듯 배열에는 이터레이터를 사용 할 수 있다. next메서드는 더이상 진행 할것이 없으면 undefined가 되지만 next는 계속 호출 할 수 있습니다.물론 그렇다고 결과가 바뀌는건 아니다. 이터레이터는 모두 독립적입니다. 즉 새 이터레이터를 만들 때마다 처음에서 시작합니다.그리고 각각 다른 요소를 가리키는 이터레이터 여러 개를 동시에 사용할 수도 있습니다. 이터레이션 프로토콜이터레이터는 그 자체로 크게 쓸모가 있다기보다는 더 쓸모 있는 동작이 가능해지도록 한다는데 의미가 있다.이터레이터 프로토콜은 모든 객체를 이터러블 객체로 바꿀 수 있습니다. 1234567891011class Log { constructor(){ this.messages = []; } add(message){ this.messages.push({ message, timestamp: Date.now() }); } [Symbol.iterator](){ return.this.messages.valus(); }} 이터레이션 프로토콜은 클래스에 심볼 메서드 Symbol.iterator가 있고 이 메서드가 이터레이터처럼 동작하는 객체, 즉 value와 done프로퍼티가 있는 개체를 반환하는 next메서드를 가진 객체를 반환한다면 그 클래스의 인스턴스는 이터러블 객체라는 뜻입니다. 제너레이터제너레이터란 이터레이터를 사용해 자신의 실행을 제어하는 함수입니다. 일반적인 함수는 매개변수를 받고 값을 반환하지만 호출자는 매개변수 외에는 함수의 실행을 제어할 방법이 전혀 없습니다.함수를 호출하면 그 함수가 종료될 때까지 제어권을 완전히 넘기는 겁니다. 하지만 제너레이터에서는 그렇지 않다. 제너레이터의 도입된 새로운 개념 제너레이터는 언제든 호출자에게 제어권을 넘길 수 있습니다.제너레이터는 호출한 즉시 실행되지는 않습니다. 대신 이터레이터를 반환하고, 이터레이터의 next 메서드를 호출함에 따라 실행됩니다. 이 두가지 예외를 제외하면 일반적인 함수와 같습니다. 제너레이터를 만들때는 function키워드 뒤에 애스터리스크(*)를 붙입니다.제너레이터에서는 return 외에 yield 키워드를 쓸 수 있습니다. yield 표현식과 양방향통신통신은 yield 표현식을 통해 이뤄진다.표현식은 값으로 평가되고 yield는 표현식이므로 반드시 어떤 값으로 평가 됩니다.yield표현식의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수 입니다. 제너레이터를 시행했을 때 일어나는 일을 묘사한것 책 참고 제너레이터와 returnyield문은 설령 제너레이터의 마지만 문이더라도 제너레이터를 끝내지 않습니다.제너레이터에서 return문은 사용하면 그 위치와 관계없이 done은 true가 되고, value 프로퍼티는 return이 반환하는 값이 됩니다. 제너레이터에서 중요한 값을 return으로 반환하려 하지 마십시오.제너레이터가 반환하는 값을 사용하려 할 때는 yield를 써야 하고 return은 제너레이터를 중간에 종료하는 목적으로만 사용해야 합니다. 요약이터레이터는 배열이나 객체처럼 여러 가지 값을 제공할 수 잇는 컬렉션의 동작 방식을 표준화했습니다.이터레이터로 할 수 있는 일은 ES6 이전에도 모두 할 수 있었으므로 어떤 기능이 추가된 것은 아니다.중요하면서도 자주 사용하는 패턴을 표준화했다는데 의미가 있다. 제너레이터를 사용하면 함수를 훨씬 더 유연하고 효율적으로 사용 할 수 있다.제너레이터는 모든 연산을 지연시켰다가 필요할 때만 수행하게 만들 수 있다.","link":"/2019/08/03/Learning-JavaScript-chapter12/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 11. 예외와 에러 처리","text":"견고하고 품질 좋은 소프트웨어를 만드는 첫 번째 단계는 에러가 일어날 수 있다는 사실을 받아들이는 것이다.두 번째 단계는 에러를 예상하고 타당한 방법으로 처리하는 것이다. 예외처리는 에러를 컨트롤 하는 매커니즘이다.에러처리라고 하지 않고 예외처리라고 하는 이유는 예상치 못한 상황에 대처하는 방식이기 때문이다. Error 객체자바스크립트에는 내장된 Error 객체가 있고 이 객체는 에러 처리에 간편하게 사용할 수 있다.Error 인스턴스를 만들면서 에러 메세지를 지정할 수 있다. 1const err = new Error(‘invalid email’); try/catch와 예외처리에러를 캐치하면 프로그램은 멈추지 않는다. 에러를 기록하고 계속 진행 할 수 있다.문제가 해결된것은 아니다. 최소한 앞뒤 사정을 모르고 그냥 멈추는 일은 막을 수 있다. 실행 흐름은 에러가 일어나는 즉시 catch 블록으로 이동try블록안에 쓸수 있는 문의 숫자에 제한은 없다.에러가 일어나지 않으면 catch블록은 실행 되지 않는다. 예외처리와 호출스택완료되지 않은 함수가 쌓이는 것을 호출스택이라고 부른다.에러는 캐치될때까지 호출스택을 따라 올라간다.에러는 호출스택 어디에서든 캐치 할수 있다. try … catch … finallyfinally블록은 에러가 일어나든 일어나지 않든 반드시 호출된다. 예외 처리하는 데에도 비용이 발생한다.프로그램을 일부러 멈추려 하는게 아니라며 예외를 일으켰으면 반드시 캐치해야 한다.예외처리는 예상 할수 없는 상화에 대비한 마지노선이다.예상 할수 있는 에러는 조건문으로 처리하는 것이 최선이다.","link":"/2019/08/03/Learning-JavaScript-chapter11/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 13. 함수와 추상적 사고","text":"서브루틴으로서의 함수서브루틴은 아주 오랜 된 개념이며 복잡한 코드를 간단하게 만드는 기초적인 수단입니다.서브루틴은 프로시저, 루틴, 서브프로그램, 매크로 등 다양한 이름으로 불립니다. 이들은 모두 매우 단순하고 범용적인 호출 할수 있는 한 단위를 일컫는 말이다. 함수로서의 함수순수함수 - 순수함수에서는 입력이 같으면 결과도 반드시 같다.순수함수에는 부수효과가 없어야 한다.함수도 객체다. 자바스크립트 함수는 Function 객체의 인스턴스이다. 변수로서의 함수 함수를 가리키는 변수를 만들어 별명을 정할 수 있다,배열에 함수를 넣을 수 있습니다. 물론 다른 타입의 데이터와 섞일 수 있습니다.함수를 객체의 프로퍼티로 사용할 수 있습니다.함수를 함수에 전달 할 수 잇습니다.함수가 함수를 반환 할 수 있습니다.함수를 매개변수로 받는 함수를 반환하는 것도 물론 가능합니다. 배열 안의 함수배열을 사용하면 작업 단계를 언제든 쉽게 바꿀 수 있다는 장점이 있다.어떤 작업을 빼야 한다면 배열에서 제거하기만 하면되고, 추가할 작업이 있다면 배열에 추가하기만 하면 된다. 함수의 함수 전달함수에 함수를 전달하는 다른 용도는 비동기적 프로그래밍입니다. 이런 용도로 전달하는 함수를 보통 콜백이라 부르며 약자로 cb를 쓸때가 많습니다. 콜백 함수는 자신을 감싼 함수가 실행을 마쳤을때 호출됩니다.함수에 함수를 전달하는 대표적인 사례가 콜백이긴 하지만 그게 전부는 아니다.함수는 동작이고, 함수를 받은 함수는 그 동작을 활용할 수 있다. 함수를 반환하는 함수매개변수 여러개를 받는 함수를 매개변수 하나만 받는 함수로 바꾸는 것을 커링 이라고 부른다.커링이라는 이름은 이 패턴을 만든 미국의 수학자 하스켈 커리의 이름을 딴것이다. 재귀재귀 역시 널리 쓰이며 함수를 활용하는 중요한 패턴입니다, 재귀란 자기 자신을 호출하는 함수 입니다.같은 일을 반복하면서 그 대상이 점차 줄어드는 상황에서 재귀를 유용하게 활용 할 수 있습니다.재귀 함수에는 종료조건이 있어야 합니다. 종료 조건이 없다면 자바스크립트 인터프리터에서 스택이 너무 깊다고 판단할 때까지 재귀 호출을 계속하다가 프로그램이 멈춥니다. 함수형프로그래밍어떤 방법이 ‘더 좋은’ 방법인가? 이 질문에 정확한 답은 없다. 여러가지 상황에 맞추어 사용하면된다.","link":"/2019/08/03/Learning-JavaScript-chapter13/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 15. 날짜와 시간","text":"자바스크립트의 Date객체는 원래 넷스케이프 프로그래머 캔스미스가 만들었는데, 사실 자바의 java.util.Date을 가져온 것이다. 세계는 타임존으로 나뉘어 있습니다. 타임존은 모두 UTC(Coordinated Universal Time)를 기준으로 한 시차로 나뉩니다.UTC는 때때로 그리니치 표준시, 즉 GMT(Greenwich Mean Time)라고 불리기도 합니다. 자바스크립트에서 Date 인스턴스는 모두 유닉스 시간 원점으로 부터 몇 밀리초가 지났는지 나타내는 숫자입니다.자바스크립트는 보통 이 숫자를 사람이 읽기 편한 그리고리력 날짜로 변환합니다. 숫자형 표현이 필요하면 valueOf() 메서드를 쓰면됩니다. 123const d = new Date();console.lod(d); //타임존이 들어간 그레고리력 날짜console.log(d.valueOf()); //유닉스 타임스탬프 Date 객체 만들기Date 객체는 네 가지 방법으로 만들 수 있습니다. 매개변수 없이 호출하면 현재 날짜에 해당하는 Date 객체를 반환문자열을 제공하면 자바스크립트는 그 문자열을 해석해서 그에 맞는 날짜를 반환숫자를 넣으면 유닉스 타임스탬프로 해석타임스탬프로 입력하는 방법 Moment.jsMoment.js에는 타임존을 지원하는 버전과 지원하지 않는 버전 두 가지가 있습니다. CDN을 통한 사용 1&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.4.0/moment-timezone.min.js&quot;&gt;&lt;/script&gt; 노드를 사용할 때는 npm install –save moment-timezone 명령으로 Moment.js를 설치하고 require 명령으로 스크립트를 불러올 수 있다. 1const moment = reqire('moment-timezone'); 날짜 형식Moment.js 의 format 메서드를 써서 날짜를 원하는 형식으로 만들 수 있습니다.자세한 사항은 Moment.js 온라인 문서를 참고 합시다. 날짜 구성 요소Date 인스턴스의 각 구성 요소에 접근 할 때는 다음 메서드를 사용합니다. 12345678910const d = new Date(Date.UTC(1815, 9 ,10));d.getFullYear()d.getMonth()d.getDate()d.getDay()d.getHours()d.getMinutes()d.getSeconds()d.getMilliseconds() 날짜 비교날짜 A와 날짜 B 중 너느쪽이 더 앞인가 하는 단순 날짜 비교는 자바스크립트에 내장된 비교 연산자를 통해 할 수 있다.Date 인스턴스는 날짜를 숫자로 저장 하므로, 숫자에 쓸 수 있는 비교 연산자를 그대로 쓰면 된다. 1234const d1 = new Date(1996, 2, 1);const d2 = new Date(2009, 4, 27);d1 &gt; d2 // falsed1 &lt; d2 // true 날짜 연산날짜는 숫자이므로 날짜에서 날짜를 빼면 몇 밀리초가 지났는지 알 수 있다. 1const msDiff = d2 -d1; 요약 자바스크립트의 날자는 1970년 1월 1일 UTC로부터 몇 밀리초가 지났는지 나타내는 숫자입니다.날짜를 생성할 때는 타임존이 유의 하여야 한다.날짜 형식을 자유롭게 바꿀 수 있어야 한다면 Moment.js를 사용하면 된다.","link":"/2019/08/16/Learning-JavaScript-chapter15/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 16. Math","text":"Math 객체는 애플리케이션을 개발하면서 자주 사용하게 될 수학 함수를 담고 있습니다.(전문적인 숫자 분석이 필요하다면 별도의 라이브러리를 찾아야 한다.)자바스크립트의 숫자는 모두 IEEE 755 64비트 부동소수점 숫자이다. 숫자 형식자바스크립트는 다양한 숫자 형식을 지원하지는 못한다. 10진수 형식, 고정 소수점 형식, 지수 형식이 몇가지 있는 정도이다.숫자를 2진수, 8진수, 16진수로 나타낼 수도 있다. 자바스크립트의 숫자 형식 메서드는 모두 숫자가 아니라 문자열을 반환한다. 해당 형식에 필요한 각종 기호를 온전히 표현하려면 반드시 문자열이어야 하기 때문이다. 고정 소수점소수점 뒤 자리수를 지정하는 형식을 원한다면 toFixed()를 사용 1234const x = 19.51;x.toFixed(3) // \"19.510\"x.toFixed(2) // \"19.51\"x.toFixed(0) // \"20\" 숫자는 버림이 아니라 반올림으로 나타난다. 지수 표기법지수 표기법이 필요할 때는 toExponential()을 사용toFixed()와 마찬가지로 반올림한 결과가 출력. 매개변수로 넘긴 정밀도에 따라 소수점 쥐의 숫자가 몇 개 나타날지 정해진다. 고정 전체 자리수소수점이 어디 나타나는 관계없이 숫자 몇 개로 표현하느냐가 중요하다면 toPrecision()을 사용출력 결과는 반올림된 숫자이며 전체 자리수는 매개변수로 넘긴 자릿수와 일치 다른 진수2진수나 8진수, 16 진수 표현을 원한다면 toString()에 기수를 매개변수로 쓰면 된다. 고급 숫자 형식다양한 형식으로 숫자를 표시해야 한다면 한계에 부딪힌다. 수천자리의 아주 큰 숫자괄호를 쓰는 등, 음수 표현을 다르게 해야하는 경우공학 표기법milli-, micro-, kilo-, mega- 등의 SI 접두사가 필요한 경우 위와같은 경우 Numeral.js를 사용하는 것을 권한다. 상수Math 객체에는 몇 가지 중요한 상수가 프로퍼티로 내장돼 있다. 123456Math.E //자연로그의 밑수Math.PI //원주율Math.SQRT1_2 //1/2의 제곱근etc 대수 함수거듭제곱제곱 관련 기본 함수는 Math.pow이며 제곱근, 세제곱근,e의 거듭제곱 등 자주 쓰이는 연산에는 간편 함수가 있습니다. 로그 함수자연로그 함수는 Math.log 기타 함수의사 난수 생성자바스크립트에서 의사 난수를 생성할 때는 Math.random()을 사용합니다. 이 함수는 0이상 1 미만의 숫자를 반환합니다. 삼각함수, 쌍곡선함수","link":"/2019/08/17/Learning-JavaScript-chapter16/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 3. 리터널과 변수, 상수, 데이터 타입","text":"CHAPTER3 은 데이터에 관한 내용들이었는데, 많은 부분들이 개념정도만을 이야기하고 나머지는 뒤에서 자세하게 설명한다고 생략되어있는 부분들이 많았다.이번 포스팅에서도 간단하게 개념들만 정리하고 추후에 다시 언급하는 방법을 취하겠다. 변수와 상수 변수 : 언제든지 변할 수 있는 값 상수 : 한번 할당한 값을 바꿀 수는 없다. 변수 선언시 초기값을 할당하지 않으면 암묵적으로 undefined를 할당한다.let, const 키워드는 ES6에서 새로 생겼다.상수 이름에는 보통 대문자와 밑줄만을 사용하는데 절대적이지는 않다. 식별자 이름 반드시 글자나 달러기호, 밑줄로 시작해야 한다. (밑줄 한개 또는 두개로 시작하는 식별자는 특별한 상황또는 ‘내부’변수에서만 사용) 식별자에는 글자와 숫자, 달러기호, 밑줄만 쓸 수 있다. 유니코드 문자도 쓸 수 있다. 예약어는 사용 할 수 없다. 여러가지 식별자 표기법 카멜 표기법 (camelCase) : 각 단어의 첫문자를 대문자로 표기하고 붙여쓰되, 맨처음 문자는 소문자로 표기함 파스칼 표기법 (PascalCase) : 첫단어를 대문자로 시작하는 표기법 스네이크 표기법 (snake_case) : 단어를 밑줄문자로 구분하는 표기법 케밥 표기법 (kebab-case) : 하이픈으로 단어를 연결하는 표기법 헝가리안 표기법 (Hungrian Notation) : 변수 및 함수의 인자 이름 앞에 데이터 타입을 명시하는 코딩규칙 - 나무위키 리터널 값을 프로그램 안에서 직접 지정한다는 의미, 값을 만드는 방법 원시타입과 객체 숫자, 문자열, 불리언, null, undefined, 심볼(symbol) 원시타입은 불변 - 불변성이라는 말이 변수의 값이 바뀔 수 없다는 뜻은 아니다. 객체 - 여러가지 형태와 값을 가질 수 있다. 숫자 IEEE-764 배정도부동소수점 숫자 형식을 사용(더블) 자바스크립트에는 숫자형 데이터 타입이 하나이다. 문자열 유니코드 텍스트 - 이모티콘 까지 포함(유니코드를 사용하는 소프트웨어가 모든 코드포인트를 정확히 렌더링 한다고 보장하지는 않는다. ) 문자열 리터널에는 작은따옴표, 큰따옴표, 백틱을 사용한다. ``(백틱)은 ES6에서 도입 이스케이프 역슬래시(\\)를 사용 - 자기자신도 이스케이프 할 수 있다. 문자열 템플릿(문자열 채우기)값을 문자열 안에 써야 할때 사용 - ES5에서는 문자열병합을 통해 변수나 상수 를 문자열 안에 사용 백틱을 사용하여 변수나 상수를 문자열 안에 쓰는 방법, 문자열의 정해진 위치에 값을 채워 넣는 간편한 방법 문자열 템플릿 안에서는 달러기호가 특수문자가 된다. 달러기호 다음에 중괄호로 감싼 값을 쓰면 그 값이 문자열에 삽입된다. 심볼 심볼은 항상 유일하다. 고유한 식별자, 심볼은 모두 서로 다르다. null, undefined null은 프로그래머에게 허용된 데이터 타입 undefined 는 자바스크립트 자체에서 사용 (프로그래머가 사용 할 수는 있지만 지양) 객체 객체의 본질은 컨테이너 - 내용물이 바뀐 다고 컨테이너가 바뀌는 것은 아니다. 중괄호를 사용하는 리터널 문법이 있다. 객체의 콘텐츠는 프로퍼티 또는 멤버라고 부름 프로퍼티 이름에 유효한 식별자를 써야 멤버접근연산자(.)를 사용 할 수 있다. 유효하지 않다면 계산된 멤버접근연산자([])를 써야한다. -유효한 식별자여도 사용가능하다. 심볼프로퍼티에 접근할 때도 사용할수 있다. 객체에 함수를 담을 수도 있다. 배열 배열크기는 고정되지 않는다 - 언제든 요소를 추가하거나 제거할 수 있다. 요소의 타입을 가리지 않는다. 배열요소는 0으로 시작한다.(숫자가 아닌 키나 분수, 음수 등을 키로 쓸수 있지만 지양) 대괄호 안에 배열요소를 쉼표로 구분해서 쓴다. 요소 숫자를 반환하는 length프로터티가 있다. 요소에 접근할 때는 대괄호 안에 요소의 인덱스 숫자(Key)를 씀 값을 덮어 쓸때에는 새 할당 하면된다. 데이터타입 변환 숫자로 변환 : Number객체 생성자 - parseInt, pasrseFloat (parseInt- 기수를 지정 할 수 있음, parseFloat- 항상 기수가 10이라고 가정) Date객체를 숫자로 변환 : valuOf()메서드를 사용 - UTC 1970년1월 1일 자정으로부터 몇밀리초가 지났는지를 나타내는 숫자(타임스태프) 문자열로 변환 : toString()메서드를 사용, 문자열병합을 사용(숫자 + 문자열 = 문자열) 배열에서의 toString()메서드는 각 요소를 문자열로 바꾼다음 쉼표로 연결한 문자열을 반환한다.","link":"/2019/06/20/Learning-JavaScript-chapter3/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 2. 자바스크립트 개발 도구","text":"CHAPTER 2. 자바스크립트 개발 도구에서는 제목 그대로 개발도구들에 대해서 설명하고 세팅하는 방법에 대해서 나와있었다. 책에있는 개발도구들을 정리해보면 아래와 같다. Git : 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템 node.js : 확장성있는 네트워크 애플리케이션 개발에 사용되는 소프트웨어 플랫폼 npm(노드 패키지 매니저/Node Package Manage ) : 자바스트립트 프로그래밍 언어를 위한 패키지 관리자 gulp : 반복작업을 자동화하는 빌드도구의 하나 babel : ES6/ES7 코드를 ECMAScript5 코드로 트랜스파일링(transpiling) 하기 위한 도구 ESlint : ES + Lint입니다. ES는 EcmaScript, 즉 자바스크립트를 의미. Lint는 보푸라기라는 뜻인데 프로그래밍 쪽에서는 에러가 있는 코드에 표시를 달아놓는 것을 의미. 자바스크립트 소스 코드가 코딩 규칭을 준수하는지 확인하기 위해 소프트웨어 개발에 사용되는 정적코드분석 도구 Git Git의 관련 내용은 이전에 정리한 포스팅으로 대체한다.Git의 기본적인 명령어 빌드도구: 걸프(gulp)와 그런트(grunt) 이 책에서는 그런트에 대한 설명은 없고 걸프만을 사용한다. 반복 작업을 자동화해주는 빌드 도구들이다. 먼저 걸프를 전역으로 설치합니다. bash1npm install -g gulp *걸프의 전역설치는 개발에 사용할 컴퓨터에서 한 번만 하면된다. 프로젝트 루트에서 아래명령어를 통해 사용한다. bash1npm install --save-dev gulp --save-dev 명령어는 최종 사용자에게는 필요없는 dev 버전임을 뜻한다.걸프는 최종 사용자에게는 필요없지만, 개발 과정에서 도움이 되는 개발 의존성에 속합니다. 설치가 완료되면 프로젝트 루트에 gulpfile.js를 만듭니다. gulpfile.js123456const gulp = require('gulp');//걸프 의존성을 작성합니다.gulp.task('default', function() { //걸프 작업을 작성합니다.}); gulp를 실행하면 정상적으로 작동해야 하는데 아래와 같이 정상적으로 실행되지 않는다. 12345$ gulp[17:03:41] Using gulpfile c:\\LearningJS\\gulpfile.js[17:03:41] Starting 'default'...[17:03:41] The following tasks did not complete: default[17:03:41] Did you forget to signal async completion? 원인을 찾아보니 책출판 당시와 지금의 걸프버전이 바뀌면서 변화가 있었다고 한다. 이 부분은 바벨과 같이 엮어서 다시 살펴보기로 한다.일단 실행을 된다. 트랜스컴파일러 - 바벨(babel)바벨을 ES5를 ES6로 바꾸는 트랜스컴파일러로 시작했고, 프로젝트가 성장하면서 ES6와 리액트, ES7등 여러 가지를 지원하는 범용 트랜스 컴파일러가 됐다.바벨 버전6부터는 ES5를 ES6로 변환하려면 ES6변환 프리셋을 설치하고 바벨이 해당 프리셋을 사용하게끔 설정을 해야 한다. ES6 프리셋 설치는 아래와 같다. bash1npm install --save-dev babel-preset-es2015 실행하면 중간에 경고 문구가 하나 뜬다. 1npm WARN deprecated babel-preset-es2015@6.24.1: 🙌 Thanks for using Babel: we recommend using babel-preset-env now: please read https://babeljs.io/env to update! babel-preset-env로 업데이트가 되었으니 업데이트를 사용하는 것을 권하는 멘트이다.babel-preset-es2015대신 babel-preset-env를 설치하여준다. @babel/core도 같이 설치 해줘야 정상적으로 실행이 된다. bash1npm install --save-dev gulp-babel @babel/core @babel/preset-env 프리셋 설치 후에 프로젝트 루트에 .babelrc 파일을 만들고 파일 내용을 작성해 줍니다. .babelrc123{ \"presets\": [\"es2015\"] } #위와 같이 작성하는 프리셋내용도 아래와 같이 변경이 필요하다.{ \"presets\": [\"@babel/preset-env\"] } 파일 내용도 프리셋 버전에 맞춰서 새롭게 바꿔서 작성하여 준다. 바벨을 걸프와 함께 사용하기 책의 내용대로 gulpfile.js를 작성하려다 간편하게 바꿔서 작성하였다. gulpfile.js12345678910const gulp = require('gulp');const babel = require('gulp-babel');gulp.task('default', function(){ gulp.src(\"public/es6/**/*.js\") .pipe(babel()) .pipe(gulp.dest(\"public/es5\"));}); 그리고 책의 예제대로 ES6샘플파일을 만들고 걸프 명령어를 실행해주면 오류가 난다. ㅎㅎㅎ;;;;위에서 언급한대로 걸프의 버전이 달라져서 변화가 있었다.이리저리 해매이다가 구글링으로 해결 방법을 찾았다.해결방법원문 여러가지 해결책중에서 가장 간단하다는 콜백함수를 추가하는 방법을 사용하여 문제를 해결하였다. gulpfile.js1234567891011const gulp = require('gulp');const babel = require('gulp-babel');gulp.task('default', function(done){ gulp.src(\"public/es6/**/*.js\") .pipe(babel()) .pipe(gulp.dest(\"public/es5\")); done();}); 콜백함수에 done을 추가하고 함수 끝 부분에서 실행해 줍니다. 린트(ESlint)ESlint는 책에서 소개한 예제대로 정상작동하였다. 하나라도 그냥 넘어가서 다행이었다 ㅎㅎㅎ;; ESlint 설치1npm install -g eslint 프로젝트 루트에서 eslint --init명령을 실행해주면 질문들이 나오는데 모든 질문에 답하면.eslintrc파일이 생성됩니다. 린트 설정에 관련해서는 나중에 따로 포스팅하면 좋을것 같다. 걸프와 같이 eslint를 실행하기 위해 다음 명령을 실행합니다. bash1npm install --save-dev gulp-eslint gulpfile.js파일을 책의 예제대로 수정하고 gulp를 실행하면 정상 작동합니다.","link":"/2019/06/19/Learning-JavaScript-chapter2/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 4. 제어문","text":"이번챕터에서는 제어문에 대해서 나와 있었다. 제어문은 크게 조건문과 반복문으로 나눌 수 있다.대표적으로 조건문에는 if…else 문,switch 문이 있고 반복문에는 for 문, while 문 등이 있다.제어문을 시각적으로 나타내는 방법에는 순서도가 있다. 순서도 순서도에서 마름모 모양은 예/아니오 인 결정이며 사각형은 행동입니다. 시작과 끝은 원으로 나타냅니다. 순서도를 프로그램으로 바꿀 때 중요한 것은 컴퓨터가 이해 할수 있는 말로 변환하는 것이다. 블록문 제어문과 함께 쓰인다. 복합문(Compound Statement) 이라고도 함 문 여러개를 중괄호로 묶은것을 말한다. 한 줄 일때에는 블록문과 같이 사용하지 않아도 된다. 공백 자바스크립트는 줄바꿈 문자를 포함해, 추가 공백을 신경쓰지 않는다. 들여쓰기는 항상 의미가 명확히 드러나도록 써야 한다. 조건문if…else 문if…else 문은 주어진 조건식의 평가 결과, 즉 논리적 참,거짓에 따라 실행할 코드 블록을 결정하여 if 문 혹은 else 문을 실행합니다.만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제변환 되어서 논리적 참,거짓을 구별합니다. if...else 문의 문법12345if(조건식){ // 조건식이 참이면 이 코드 블록을 실행합니다.}else { // 조건식이 거짓이면 이 코드 블록을 실행합니다.} 조건식을 추가 하고 싶으면 else if 문을 사용한다.else if문과 else문은 옵션으로 사용 할 수도 있고 사용하지 않을 수도 있다.if 문과 else문은 1번씩만 사용이 가능하고 else if문은 여러 번 사용이 가능하다. switch 문if 문은 두 가지 중 하나를 선택하지만 switch 문은 조건 하나로 여러가지 중 하나를 선택 할 수 있다.다양하게 나뉘는 조건을 표현 할때 사용 switch 문의 문법1234567891011121314switch(표현식){ case value1: // 표현식을 평가한 결과가 value1 일때 실행 [break;] case value2: // 표현식을 평가한 결과가 value2 일때 실행 [break;] case valueN: // 표현식을 평가한 결과가 valueN 일때 실행 [break;] default: // 표현식을 평가한 결과가 없을때 실행 [break;]} default 절은 일치하는 case 절이 없을 때 실행 필수는 아니지만, 보통 맨 마지막에 사용 break문이 없어도 되지만 사용하는 습관이 중요한다. switch 문을 함수 안에서 사용 할때는 return 문을 break 문 대신해서 사용 할 수 있다. 제어문의 예외 break - 루프 중간에 빠져 나갑니다. continue - 루프에서 다음 단계로 바로 건너뜁니다. return - 제어문을 무시 하고 현재 함수를 즉시 빠져나갑니다. throw - 예외 핸들러에서 반드시 처리해야 할 예외를 일으킵니다. 예외 핸들러는 현재 제어문 바깥에 있어도 상관없습니다. 반복문while 문조건을 만족하는 동안 코드를 계속 반복한다. while 문의 문법123while(조건식){ //조건식이 참이면 실행} do…while문최소 한번은 실행 하려 할 때 사용합니다. do...while 문의 문법123do{ //실행문}while(조건문) for 문while문,do...while문은 모두 for 문으로 고쳐 쓸 수 있습니다. 어떤일을 정해진 숫자만큼 반복할거나 특히 그 일을 지금 몇번째 하는지 알아야 할때 사용합니다. for 문의 문법123for( 초기화식; 조건식; 증감식){ //조건식이 참인경우 실행문이 반복된다.} for 문의 다른 패턴 쉼표 연산자를 쓰면 초기화와 마지막 표현식에 여러가지 문을 결합 할 수 있다, 보통 정수 인덱스를 늘이거나 줄이면서 반복하지만 꼭 그래야 하는 건 아니다. 어떤 표현식이든 쓸수 있다.(문자열, 정수가 아닌 수, 객체 프로퍼티) 장점 제어부가 첫번째 행에 모여 있어서 일목요연하게 파악 할 수 있다. 초기화한 변수가 for문 안에서만 유효하다.(호이스팅) for..in 문for…in 문은 객체의 프로퍼티에 루프를 실행 하도록 설계된 반복문이다. for...in 문의 문법123for(variable in object){ //실행문 } for…in 문 주의사항객체 리터럴에 쓴 순서대로 열거되지 않는다.(순서가 보장되지 않는다.)열거 할 수 없는 프로퍼티가 존재한다.(객체의 모든 내장 메서드를 비롯해 각종 내장 프로퍼티 같은 비열거형 속성은 반복되지 않는다. 예:length)프로토타입에서 상속한 프로터티도 나열한다.hasOwnProperty 관련 참고링크 for…of 문ES6에서 새로 생긴 반복문, 컬렉션의 요소에 루프를 실행하는 다른 방법 for...of 문의 문법123for(variable of object){ //실행문 } 배열은 물론 이터러블 객체(member를 하나씩 차례로 반환 가능한 object)에 모두 사용 할 수 있는 범용적인 루프루프를 실행해야 하지만 각 요소의 인데스를 알 필요는 없을 때이터러블 관련 참고링크 메타문법 다른 문법을 설명하는 문법","link":"/2019/06/27/Learning-JavaScript-chapter4/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 7. 스코프","text":"스코프는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정합니다. 변수가 존재하지 않으면 그 변수는 스코프안에 ‘있지않음’을 직관적으로 알수 있다.즉 아직 선언하지 않은 변수나 함수가 종료되면서 존재하지 않게 된 변수는 분명 스코프안에 ‘있지 않다’ 스코프와 존재를 구별해야 한다.가시성이라고도 불리는 스코프는 프로그램의 현재 실행 중인 부분, 즉 실행 컨텍스트에서 현재 보이고 접근 할 수 있는 식별자들을 말한다. 반면 존재한다는 말은 식별자가 메모리에 할당된 무언가를 가리키고 있다는 뜻이다. 정적스코프와 동적스코프자바스크립트의 스코프는 정적이다. 소스코드만 봐도 변수가 스코프에 있는지 판단 할 수 있다.다만 소스코드만 봐도 즉시 스코프를 분명히 알 수 있다는 뜻은 아니다. 정적스코프어떤 변수가 함수 스코프 안에 잇는지 함수를 정의 할 때 알 수 있다는 뜻 이다. 호출할 때 알 수 있는 것은 아니다.자신이 정의 될 때 접근 할 수 있었던 식별자에는 여전히 접근 할 수 있지만, 호출 할 때 스코프에 있는 식별자에는 접근 할 수 없다. 전역스코프전역스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있다.전역스코프에서 선언된 것들을 전역변수(global)라고 합니다.전역스코프에 의존하는 것은 피해야한다. 블록스코프let 과 const 는 식별자를 블록스코프에서 선언합니다.블록스코프는 블록(문을 중괄호로 묶은것)의 스코프에서만 보이는 식별자를 의미한다. 변수 숨기기123456789101112{ // 외부블록 let x = 'blue'; console.log(x); // \"blue\" { // 내부블록 let x = 3; console.log(x) // \"3\" } console.log(x); // \"blue\"}console.log(typeof x); // \"undefined\"; x는 스코프에 있지 않습니다. 내부블럭의 x는 외부 블록에서 정의한 x와 이름만 같을 뿐 다른 변수이므로 외부 스코프의 x를 숨기는 효과가 있다.실행 흐름이 내부 블록에 들어가 새 변수 x를 정의 하는 순간 두 변수는 모두 스코프안에 있다.(외부 변수가 숨겨짐)변수의 이름이 같으므로 외부 스코프에 있는 변수에 접근할 방법이 없다. 스코프 체인스코프가 계속 연결됨(중첩), 스코프안에 스코프가 있는 형태내부 함수에서는 외부 함수의 변수에 접근이 가능하지만 외부 함수에서는 내부 함수의 변수에 접근 할수 없다.모든 함수들은 전역 객체에 접근 할 수 있다. 함수, 클로저, 정적스코프클로저는 함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의 하는 경우, 스코프를 함수 주변으로 좁히는 것을 말한다. 12345678let globalFunc; // 정의 되지 않는 전역 함수{ let blockVar = \"a\" // 블록 스코프에 있는 변수 globalFunc = function(){ console.log(blockVar); }}globalFunc(); // \"a\" globalFunc는 블록 안에서 값을 할당받았습니다. 이 블록 스크로와 그 부모인 전역 스코프가 클로저를 형성합니다.globalFunc를 어디서 호출하든 이 함수는 클로저에 들어있는 식별자에 접근 할수 있다.globalFunc을 호출하면, 이 함수는 스코프에서 빠져나왔음에도 불구하고 blockVar에 접근 할 수 있습니다. 즉시실행함수IIFE(즉시실행함수)는 함수를 선언하고 즉시 실행합니다. 123(function(){ // 즉시실행함수 바디})(); IIFE의 장점은 내부에 있는 것들이 모두 자신만의 스코프를 가지지만 IIFE 자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있는 것이다. 내부 변수는 IIFE안에 안전하게 보관되어 있으므로 손댈 방법이 없다.ES6에서 블록스코프 변수를 도입하면서 IIFE가 필요한 경우가 줄긴 했지만 여전히 널리 쓰인다.클로저를 만들고 클로저에서 무언가 반환 받을 때에는 유용하게 쓸 수 있다. 함수스코프와 호이스팅var로 선언된 변수들은 함수스코프라 불리는 스코프를 가진다.var로 선언한 전역 변수는 명시적인 함수 안에 있지 않지만 함수 스코프와 똑같이 동작한다. let으로 변수를 선언하면, 그 변수는 선언하지 전에는 존재하지 않습니다.var로 선언한 변수는 현재 스코프 안이라면 어디서든 사용 할 수 있으며, 심지어 선언하기도 전에 사용할 수 있습니다. 12345let var1;let var2 = undefined;var1; // undefined;var2; // undefinde;undefinedVar; // ReferenceError:undefinedVar is not defined let을 쓰면 변수를 선언하기 전에 사용하려 할때 에러가 일어 납니다.반면 var로 변수를 선언하면 선언하기도 전에 사용 할 수 있습니다. 호이스팅var로 선언한 변수는 호이스팅이라는 메커니즘을 따릅니다.자바스크립트는 함수나 전역스코프 전체를 살펴보고 var로 선언한 변수를 맨 위로 끌어올립니다.(여기서 중요한 것은 선언만 끌어올려진다는 것이며, 할당을 끌어 올려지지 않는다는 것이다.) 12345678910111213141516// 원래코드var x = 3;if(x ===3){ var x = 2; console.log(x);} console.log(x);// 자바스크립트가 해석한 코드var x;x = 3;if(x === 3){ x = 2; console.log(x);}console.log(x); 위의 예제를 보면 같은 함수나 전역스코프 안에서는 var로 새 변수를 만들수 없으며 let으로 가능 했던 변수숨김도 불가능하다.(블록 안에서 두번째 var문을 썻지만 변수x는 하나뿐이다.) 함수 호이스팅함수 선언도 스코프 맨 위로 끌어올려집니다.따라서 함수를 언언하기 전에 호출 할 수 있습니다. 1234f(); // 'f'function f(){ console.log('f');} 단, 변수에 할당한 함수 표현식은 끌어올려지지 않습니다. 이들은 변수의 스코프 규칙을 그래도 따릅니다. 1234f(); // ReferrenceError: f 는 정의되지 않았습니다.let f = function(){ console.log('f');} 사각지대스코프안에서 변수의 사각지대는 변수가 선언되기 전의 코드입니다. ES6 이전에 주의 해야한다. 스트릭트 모드스트릭트 모드에서는 암시적 전역 변수를 허용하지 않습니다.스트릭트 모드를 사용하려면 문자열 “use strict”(작은 따옴표도 가능) 하나만으로 이루언진 행을 코드 맨 앞에 쓰면 됩니다.전역스코프에서 사용하면 스크립트 전체가 스트릭트 모드로 실행되고, 함수 안에서 사용하면 해당 함수만 스트릭트 모드로 실행됩니다.","link":"/2019/07/12/Learning-JavaScript-chapter7/"},{"title":"Hexo 배포 원리에 따른 백업 방법","text":"Hexo를 이용해서 블로그를 만들고 관리 하다보니 문제점을 하나 발견했다.바로 백업에 관한 문제인데 Hexo 블로그는 Github에 repository를 통해 구성되어 있으니다른 곳에서 작업할때 그것을 clone해서 수정하면 된다고 생각했다. 그러나 다른 곳에서 clone을 해보고는 문제가 있음을 알수 있었다.라이브되는 repository에 올라가는건 public 폴더의 내용이라 실제로 작업한 것은 올라가지 않는다는 것을 말이다. 그래서 해결책으로 별도의 repository 하나를 생성하여 별도로 백업을 하기로 했는데이 방법도 문제가 있었다. Hexo의 테마들을 각자의 git을 가지고 있어서git 안에 git이 있어 재대로 관리가 되어지지 않았다. 그래서 검색을 통해 알아보다가 git의 서브모듈(submodule)을 이용해서 백업 하기로 했다. 새 저장소 생성저장소는 총 2개가 필요합니다. 테마를 저장할 저장소와 나머지 블로그 자료를 저장할 저장소 이렇게 2개 입니다. 저는 제가 사용하는 테마의 이름인 icarus라는 저장소와 blog_backup 이라는 두개의 저장소를 private로 만들어 줬습니다. 2019.01.07일부로 Github의 private 저장소가 무료로 전환 되었습니다. 테마 백업먼저 테마폴더를 백업해줍니다.보통 테마를 설치 할때는 아래와 같은 명령어를 사용합니다. bash1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 물론 위와 같은 방법으로 설치해도 백업문제만을 제외한다면 아무런 문제없이 잘 작동합니다.그러나 여러 컴퓨터에서 포스팅을 해야 하는 상황이 발생한다면 백업의 문제가 발생합니다. 그래서 설치되어 있는 테마의 원격 저장소의 주소를 변경해줍니다. bash123456789101112# 테마 폴더에서 원격 저장소를 확인합니다.$ git remote -v# 원격 저장소를 변경해 줍니다. (자신의 저장소 URL로 변경)$ git remote set-url origin https://github.com/mishka86/icarus.git# 변경된 원격 저장소를 확인합니다.$ git remote -v# 변경 사항 올려줍니다.$ git commit -a -m 'theme backup'$ git push -u origin master 블로그 자료 백업블로그 폴더를 git으로 초기화 시켜줍니다. bash12345678#git 초기화git init#현재 내용을 전부 커밋해 줍니다.git commit -a또는git add .git commit -m \"커밋메세지\" 테마폴더 서브모듈 추가원격 저장소로 푸시 하기 전에 서브모듈을 추가해 주어야 합니다.테마 폴더는 따로 git으로 관리되고 있으므로 submodlue로 관리 해주어야 합니다. 테마폴더는 이전 작업에서 백업을 해준것을 확인하고 삭제하여 줍니다.그리고 git submodule 이용해서 서브모듈로 추가해 줍니다. bash123456789# 미리 올려둔 저장소의 내용을 서브모듈로 추가한다.# git submodule add &lt;저장소주소&gt; &lt;테마폴더&gt;git submodule add https://github.com/mishka86/icarus.git themes/icarus#변경된 후의 git submodule status 이용해서 확인 하여준다.$ git submodule status 46cf786d5356d36fcac4dc80abbebb56a71dae9b themes/icarus (heads/master)# 변경된 내용을 모두 커밋$ git commit -a 새로운 테마를 설치 할때로 git clone이 아니라 git submodlue을 사용해서 관리해 줍니다. 배포하기bash123# 이제 브랜치를 원격 리파지토리에 올린다.git remote add origin &lt;저장소주소&gt;git push -u origin master 두개의 저장소에 테마와 블로그 내용을 별도로 백업을 했습니다.이로써 안전한 백업과 어디서든지 접속하여 deploy 할 수 있게 되었습니다.","link":"/2019/06/13/backup/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 9. 객체와 객체지향 프로그래밍","text":"객체배열과 마찬가지로 자바스크립트 객체 역시 컨테이너지만, 크게 보면 다음 두 가지 측면에서 배열과 다릅니다.배열은 값을 가지며 각 값에는 숫자형 인덱스가 있습니다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있습니다.배열에는 순서가 있습니다. 즉 arr[0] 는 항상 arr[1]보다 앞에 있습니다. 반면 객체에는 그런 순서가 보장 되지 않습니다.obj.a가 obj.b보다 앞에 있다고 말할 수는 없습니다. 프로퍼티는 키(문자열 또는 심볼)과 값으로 구성됩니다. 객체의 특징은 키를 통해 프로퍼티에 접근할 수 있다는 점입니다. 프로퍼티나열프로퍼티 나열에서 기억해야 할 것은 순서가 보장되지 않는다는 점입니다.객체프로퍼티에는 순서가 없습니다. Object.keysObject.keys는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환한다. 123const SYM = Symbol();const o = { a:1, b:2, c:3, [SYM]:4; }Object.keys(o).forEach(prop =&gt; console.log(`${prop}: ${o{prop}}`)); 객체의 프로퍼티 키를 배열로 가져와야 할때는 object.keys가 편리합니다. 객체지향 프로그래밍객체지향 프로그래밍(OOP)은 컴퓨터 과학에서 전통적인 패러다임입니다.OOP의 개념중 일부는 1950년대부터 있었지만 , 시뮬러 67과 스몰토크가 등장하면서 OOP의 형태가 갖춰지기 시작했습니다.OOP의 기본아이디어는 단순하고 직관적이다. 객체는 데이터와 기능을 논리적으로 묶어 놓은겁니다.OOP는 우리가 사물을 이해하는 자연스러운 방식을 반영하도록 설계됐습니다. 또한 OOP는 사물에 관해 추상적으로, 구체적으로 생각할 수 있게 합니다. 클래스는 어떤자동차 처럼 추상적이고 범용적인 것인스턴스는 특정자동차 처럼 구체적이고 한정적인 것메서드는 기능클래스 메서드는 클래스에 속하지만 특정 인스턴스에 묶이지는 않는 기능oop는 클래스를 계층적으로 분류하는 수단도 제공합니다. 클래스와 인스턴스 생성클래스 문법123456789class Car { let = a constructor(b){ this.a = b }}let c = new Car(3); console.log(c.a) 클래스를 만들때 사용한 this 키워드는 나중에 만들 인스턴스의 플레이스 홀더입니다.메서드를 호출하는 시점에서 this가 무엇인지 알 수 있게 됩니다. 클래스는 함수다class 키워드를 도입하기 전까지 클래스를 만든다는 것은 곧 클래스 생성자로 사용할 함수를 만든다는 의미였다.class 문법이 훨씬 더 직관적이고 단순하긴 하지만, 사실 class 는 단축 문법일 뿐이며 자바스크립트의 클래스 자체가 바뀐것은 아니다.따라서 클래스 자체를 이해하는 것이 중요하다.클래스는 사실 함수일 뿐이다. 12function Es5Car {}class Es6Car {} 클래스가 바뀐것이 아니라 간편한 새 문법이 생겼을 뿐이다. 프로토타입클래스의 인스턴스에서 사용할 수 있는 메서드라고 하면 그건 프로토타입 메서드를 말하는 것이다. 최근에는 프로토타입 메서드를 #으로 표시하는 표기법이 널리 쓰입니다.Car.prototype.shift 를 Car#shift 로 표기한다. 모든 함수에는 prototype이라는 특별한 프로퍼티가 있다.일반적인 함수에서는 프로토타입을 사용할 일이 없지만객체 생성자로 동작하는 함수에서는 프로토타입이 대단히 중요하다.함수의 prototype 프로퍼티가 중요해지는 시점은 new 키워드로 새 인스턴스를 만들었을 때이다new키워드로 만든 새 객체는 생성자의 prototype프로퍼티에 접근할 수 있습니다.객체 인스턴스는 생성자의 prototype프로퍼티를 __proto__프로퍼티에 저장합니다. 프로토타입에서 중요한 것은 동적 디스패치하는 매커니즘입니다.여기서 디스패치는 메서드호출과 같은의미입니다.객체의 프로퍼티나 메서드에 접근하려 할 때 그런 프로퍼티나 메서드가 존재하지 않으면자바스크립트는 객체의 프로토타입에서 해당 프로퍼티나 메서드를 찾습니다. 클래스의 인스턴스는 모두 같은 프로토타입을 공유하므로 프로토타입에 프로퍼티나 메서드가 있다면해당 클래스의 인스턴스는 모두 그 프로퍼티나 메서드에 접근 할 수 있습니다. 인스턴스에서 메서드나 프로퍼티를 정의하면 프로토타입에 있는 것을 가리는 효과가 있습니다.자바스크립트는 먼저 인스턴스를 체크하고 거기에 없으면 프로토타입을 체크하기 때문이다. 정적메서드특정인스턴스에 적용되지 않는다.정적메서드에서 this는 인스턴스가 아니라 클래스자체에 묶인다.일반적으로 정적 메서드에는 this대신 클래스 이름을 사용하는 것이 좋은습관이다.정적메서드는 클래스에 관련되지만 인스턴스와는 관련이 없는 범용적인 작업에 사용된다. 상속클래스의 인스턴스는 클래스의 기능을 모두 상속한다. 상속은 한 단계로 끝나지 않는다.객체의 프로토타입에서 메서드를 찾지 못하면 자바스크립트는 프로토타입의 프로토타입을 검색한다.조건에 맞는 프로토타입을 찾을 때까지 프로토타입 체인을 거슬러 올라갑니다.조건에 맞는 프로토타입을 찾지 못하면 에러를 일으킨다. extends키워드는 Car를 Vehicle의 서브클래스로 만듭니다. 12345class Car extends Vehicle { constructor(){ super(); }} super() 는 슈퍼클래스의 생성자를 호출하는 함수이다.서브클래스에서는 이 함수를 반드시 호출해야 한다. 호출하지 않으면 에러가 난다. 상속은 단방향이다. 다형성디형성이란? 객체지향 언어에서 여러 슈퍼클래스의 멤버인 인스턴스를 가리키는 말이다. 자바스크립트는 믹스인 방법을 사용한다.","link":"/2019/08/02/Learning-JavaScript-chapter9/"},{"title":"클로저(closure)에 대하여","text":"클로저의 의미클로저(closure)라는 영어단어의 사전적 의미는 ‘닫혀있음’, ‘폐쇄성’, ‘완결성’ 정도의 의미를 가집니다.그렇다면 자바스크립트에서의 클로저는 무슨 의미를 가지고 있을까요? 클로저(closure)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특징입니다.자바스크립트에서만 사용하는 개념이 아니다 보니 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있다고 합니다.다양한 서적에서 클로저를 정의하고 있는 문장들을 한번 살펴보겠습니다. 자신을 내포하는 함수의 컨텍스트에 접근 할 수 있는 함수 - 더글라스 크록포드, ‘자바스크립트 핵심 가이드’(한빛 미디어) 함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의 하는 것 - 에단 브라운, ‘러닝 자바스크립트’(한빛 미디어) 함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출 할 수 있는 함수 - 존 레식, ‘자바스크립트 닌자 비급’(인사이트) 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수 - 송현주, 고현준, ‘인사이드 자바스크립트’(한빛 미디어) 자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합 - 에릭 프리먼, ‘Head First Javascript Programing’(한빛 미디어) 로컬 변수를 참조하고 있는 함수 내의 함수 - 야마다 요시히로, ‘자바스크립트 마스터 북’(제이펍) 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수 - 유인동, ‘함수형 자바스크립트 프로그래밍’(인사이트) MDN 에서는 클로저에 대해 “A closure is the combination of a function and the lexical environment within which that function was declared.”직역해 보면“클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상” 정도가 되겠습니다. A함수 내부에서 B함수를 선언 했을 경우에A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에서 선언한 변수에 접근 가능합니다.내부 함수 B가 A의 lexical enviroment를 언제나 사용하는 것은 아닙니다. 내부함수에서 외부 변수를 참조하는 경우에 한해서만 사용 가능합니다. 간단하게 한번 정리해 보자면 &quot;어떤 함수에서 선언한 변수를 참조하는 내부 함수에서만 발생하는 현상&quot;이라고 볼 수 있겠습니다. 예제 112345678910var outer = function() { var a = 1 var inner = function () { console.log(++a) } inner()}outer()outer()outer() 코드펜 링크 실행순서를 살펴보면 outer 함수에서 변수 a를 선언했고, outer의 내부함수인 inner 함수에서 a의 값을 1만큼 증가시킨 다음 출력합니다.inner 함수에서는 a를 선언하지 않았기 때문에 스코프체인을 타고 outer 함수에 접근해서 a를 찾습니다.그리고 4번째 줄에서 2가 출력됩니다. outer 함수가 종료되면 저장된 식별자들(a, inner)에 대한 참조를 지웁니다.그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 컬렉터의 수집 대상이 됩니다.그래서 2를 3번 출력하게 됩니다.` 예제 21234567891011var outer = function() { var a = 1 var inner = function () { return ++a } return inner}var outerFunc = outer()console.log(outerFunc())console.log(outerFunc())console.log(outerFunc()) 코드펜 링크 위 예제를 살펴보면 inner함수의 실행 시점에는 outer함수는 이미 실행이 종료된 상태인데 outer함수의 Lexical environment에 접근할 수 있는 걸까요?이는 가비지 컬렉터의 동작 방식 때문입니다. 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다.그래서 예제를 보면 outer 함수는 실행 종료 시점에 inner 함수를 반환합니다.외부 함수인 outer 의 실행이 종료되더라도 내부 함수인 inner 함수는 언젠가 outerFunc를 실행함으로써 호출될 가능성이 열린 겁니다.언젠가 inner 함수의 실행 컨텍스트가 활성화되면 outer함수 a 의 값을 필요로 할것이므로 수집대상에서 제외됩니다. 예제1과 2의 다른점은 변수가 가비지 컬렉터에 포함 되었느냐 제외 되었느근냐 입니다.함수의 실행 컨텍스트가 종료돈 후에도 lexical environment가 가비지 컬렉터의 수집대상에서 제외되는 경우는 지역변수를 참조하는 내부 함수가 외부로 전달된 경우가 유일합니다.위 현상을 토대로 클로저의 정의를 다시 고쳐보자면 “어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상”이라고 할 수 있습니다. 외부로 전달하는 방법으로는 return 외에도 Window의 메서드(setTimeout 또는 setInterval), DOM의 메서드(addEventListener) 같은 경우도지역변수를 참조하는 내부함수를 외부로 전달 했기 때문에 클로저라고 할 수 있습니다. 클로저의 메모리 관리클로저의 메모리 소모는 본질적인 특정일 뿐입니다. ‘메모리 누수’라는 표현은 개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC(Garbage Collector)의 수거 대상이 되지 않는 경우에는 맞는 표현이지만 개발자가 의도적으로 참조 카운트를 0이되지 않게 설계한 경우는 ‘누수’라고 할 수는 없습니다.클로저의 메모리 관리 방법은 간단합니다.클로저는 어떤 필요의 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다. 그러면 필요성이 사라진 시점에 메모리를 소모하지 않도록 해주면 됩니다. 참조 카운트를 0으로 만들면 GC가 수거 해가고 이때 소모됐던 메모리가 회수 됩니다.참조 카운트를 0으로 만드는 방법은 식별자의 참조형이 아닌 기본형 데이터(null 이나 undefined)를 할당하면 됩니다. 예제 3 메모리 관리123456789101112var outer = function() { var a = 1 var inner = function () { return ++a } return inner}var outerFunc = outer()console.log(outerFunc())console.log(outerFunc())console.log(outerFunc())outer = null // outer 식별자의 inner 함수 참조를 끊음 클로저 활용 사례콜백 함수와 클로저콜백 함수 내부에서 외부변수를 참조하기 위한 방법으로 세가지가 있습니다. 콜백 함수를 내부 함수로 선언해서 외부 변수를 직접 참조하는 방법으로 클로저를 사용하는 방법 bind 메서드로 값을 직접 넘겨줘서 클로저를 발생 시키지 않는 대신 여러가지 제약이 있는 방법 콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용한 방법 접근 권한 제어(정보은닉)정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나 입니다.흔희 접근 한에는 public, private, protected 의 세 종류가 있습니다. public은 외부에서 접근 가능한 것 private은 내부에서만 사용하며 외부에 노출되지 않는 것 protected는 상속받은 클래스 또는 같은 패키지에서만 접근이 가능한 것(java) 자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직업 부여하도록 설계되어 있지 않습니다.그렇다고 접근 제한이 불가능 한 것을 아닙니다. 클로저를 활용해서 함수차원에서 public한 값과 private 한 값을 구분하는 것이 가능합니다. 정보은닉123456789var outer = function () { var a = 1 var inner = function () { return ++a } return inner}var outerFunc = outer()console.log(outerFunc()) outer 함수를 종료할 때 inner 함수를 반환함으로써 outer 함수의 지역변수인 a의 값을 외부에서도 읽을 수 있게 됐습니다.외부에서는 outer라는 변수를 통해 outer함수를 실행 할 수는 있지만 outer함수 내부에는 어떤한 개입도 할 수 없습니다.외부에서는 오직 outer함수가 return한 정보에만 접 할수 있습니다.그러니까 외부에 제공하고자 하는 정보들을 모아서 return하고, 내부에서만 사용 할 정보들은 return 하지 않는 것으로 접근 권한 제어가 가능한것입니다.return한 변수들은 공개맴버(public member) 가 되고, 그렇지 않는 변수들은 비공개 멤버(private member)가 되는 것입니다. 부분 적용 함수 (partially applied function)부분 적용 함수란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가,나중에 (n-m) 개의 인자를 넘기면 비로소 원래 함수의 실행 결과를 얻을 수 있게끔 하는 함수 입니다. 커링 함수 (currying function)커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말합니다.부분 적용 함수와 다른 점은 커링은 한 번에 하나의 인자만 전달하는 것을 원칙으로 합니다. 또한 중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 할 뿐으로, 마지막 인자가 전달되기 전 까지는 원본 함수가 실행되지 않습니다(부분 적용 함수는 여러 개의 인자를 전달할 수 있고, 실행 결과를 재실행할때 원본 함수가 무조건 실행됩니다). Reference 코어 자바스크립트 (위키북스)","link":"/2020/01/04/closure/"},{"title":"실행 컨텍스트(execution context)","text":"실행 컨텍스트(execution context)는 쉽게 보면 코드가 실행되고 있는 구역,범위에 대한 개념정도로 볼 수 있다.실행 컨텍스트는 실행할 코드에 제공할 환경정보들을 모아놓은 객체이다.ECMAScript 스펙에서는 실행 컨텍스트를 ‘실행 가능한 코드를 형상화하고 구분하는 추상적인 개념’이라고 정의 한다. 자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러가지 정보들을 알고 있어야 한다고 한다. 실행에 필요한 정보들을 아래와 같다. 변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티 함수 선언 변수의 유효범위(Scope) this 코드를 실행하면 ‘전역 컨텍스트(Global execution Context)’가 생깁니다. 전역 컨텍스트는 브라우저가 종료 될 때까지 유지됩니다.특정 ‘함수’안에서 실행되는 코드가 아니라면 코드는 전역 컨텍스트에서 실행됩니다. 함수가 호출 될때 해당 함수에 대한 실행 컨텍스트가 생성된다.(Functional Execution Context) 함수들은 각각 자신만의 실행 컨텍스트를 가지지만이를 함수가 호출 되어야 만들어 집니다. 예제로 한번 보겠습니다. javascript12345678910111213// (1)var a = 1function outer() { function inner() { console.log(a) // undefined var a = 3 console.log(a) // 3 } inner() // (2) console.log(a) // 1 }outer() // (3)console.log(a) // 1 위의 코드의 실행 순서를 따라가 보면 처음에 자바스크립트 코드를 실행하면(1) 전역 컨텍스트가 콜 스텍에 담깁니다. 순차적으로 코드를 읽다가 (3)에서 outer 함수를 호출하면 outer함수에 대한 실행 컨텍스트를 생성한 후 콜 스텍에 담습니다. 콜 스텍에 새로운 컨텍스트가 놓인상태가 됐으므로 전역 컨텍스트와 관련된 코드 실행을 일시 중단하고 outer 함수에 대한 실행 컨텍스트를 실행합니다. outer 함수 내부의 코드들을 순차로 실행합니다. (2)에서 inner 함수가 호출되서 inner함수의 실행 컨켄스트가 콜 스택의 가장 위에 담기면 outer 컨텍스트와 관련되 코드의 실행을 중단하고 inner함수 내부의 코드를 순서대로 진행합니다. inner함수 내부의 값을 출력하고 나면 inner함수의 실행이 종료되면서 inner 실행 컨텍스트가 콜 스택에서 제거됩니다. inner컨텍스트의 의해 중단되었던 outer (2)줄 다음부터 실행됩니다. a 변수 값을 출력하고 outer함수의 실행이 종료되며 outer실행 컨텍스트가 종료되며 콜 스택에서 제거됩니다. 중단되었던 전역 컨텍스트 (3)의 다음 줄부터 실행됩니다. a 변수의 값이 출력되고 전역 컨텍스트도 콜 스택에서 제거 됩니다. 스택구조를 잘 살펴보면 한 실행 컨텍스트가 콜 스택의 맨위에 쌓이는 순간이 곧 현재 실핼할 코드에 관여하게 되는 시점임을 알 수 있습니다.기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치 할 수 밖에 없기 때문입니다. 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장합니다. 실행 컨텍스트의 3가지 객체실행 컨텍스트 자체는 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 가지며 3가지 프로퍼티를 가진다. Variavle Object (VO / 변수객체)변수, 매개변수, 인수정보, 함수 선언의 정보를 담고있는 객체컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 정보를 수집전역 실행 컨텍스트와 함수 실행 컨텍스트 일때 내용이 다르다전역 컨텍스트의 경우 - 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Gloval Object / GO)함수 컨텍스트의 경우 - Acrivation Object(AO / 활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고있는arguments object가 추가됨 호이스팅변수를 선언하고 초기화 했을때 선언 부분이 코드의 최상단으로 끌어올려지는 현상.선언부만 올라가므로 최기화 또는 대입 부분은 그대로 남아있음함수 선언식의 경우에는 함수 전체가 통째로 끌어올려짐 javascript12345678function a (x) { console.log(x); var x; console.log(x); var x = 2; console.log(x);}a(1) 위의 코드를 호이스팅 개념처럼 변경하면 javascript123456789101112function a () { var x; var x; var x; x = 1 console.log(x); console.log(x); x = 2; console.log(x);}a() 인자들과 함께 함수를 호출한 경우의 동작은 전달된 인자를 arguments object에 담는 것을 제외하면 코드내부에서 변수를 선언한 것과 다르지 않아서 함수 내부의 코드 최상단에서 선언 및 할당이 이뤄진것으로 간주하여 적용 javascript12345678function a () { console.log(b); var b = 'bbb'; console.log(b); function b () {}; console.log(b);}a(); 위의 코드를 호이스팅 개념처럼 변경하면 javascript123456789function a () { var b; function b () {}; console.log(b); b = 'bbb'; console.log(b); console.log(b);}a(); 함수 선언식의 경우는 식이 통째로 끌어올려지는것에 주의 Scope Chain(SC)스코프 체인은 일종의 리스트, 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장해당 전역 또는 함수가 참조 할 수 있는 변수, 함수 선언 등의 정보를 담고있는 전역 객체 또는 활성 객체의 리스트현재 실행 컨텍스트의 활성 객체로 시작해서 순차적으로 상위 컨텍스트의 활성 객체를 가리키며 마지막에는 전역 객체를 가리킴스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하며 스코프 체인은 식별자 중에서 변수를 검색하는 메커니즘 javascript1234567891011var a = 1;var outer = function () { var inner = function () { console.log(a); var a = 3; }; inner(); console.log(a);};outer();console.log(a); this valuethis 프로퍼티에는 this 값이 할당 됨this에 할당되는 값은 함수 호출 패턴에 의해 결정된다. Reference 코어 자바스크립트 - 위키북스 https://poiemaweb.com/js-execution-context https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy https://velog.io/@stampid/Execution-Context%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80 https://reinvint.tistory.com/6","link":"/2020/01/02/execution_context/"},{"title":"Git의 기본적인 명령어","text":"안녕하세요 미슈카 입니다.오늘은 git의 기본적인 명령어들을 정리해보려고 합니다.모든 명령어들을 정리하는 것이 아닌 많이 쓰이는 명령어들을 위주로 정리 하려고 합니다. 그전에 먼저 간단하게 git이란 무엇인가? 그리고 git에서 사용하는 용어들을 정리해 보겠습니다. git이란 무엇인가? git은 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템이다.위키백과위키 백과에서는 위와 같이 말하고 있다. 그 중에서 우리가 주위깊게 보아야 할 단어들은“추적, 분산 버전 관리 시스템”이다.git은 2005년 리누스 토르발스가 리눅스 커널 개발을 위해 처음 개발하였다.많은 버전 관리 시스템(VCS : Version Control System)중에 하나인데 다른 버전 관리 시스템과 다른점은저장소를 분산해서 관리 한다는 점이다. 즉 중앙 저장소에 문제가 생겨도 로컬저장소를 이용하여 복원이 가능하다는 것이다. git에서 사용하는 용어 Working tree : 현재 작업하고 있는 공간, git이 관리하고 있지만 아직 추적(track)하고 있지 않은 상태 (또는 Working Directory) Staging area : 커밋 하기전 staged 된 파일들이 있는 공간,수정한 파일을 커밋하기 전에 표시(add)해둔 공간 Commit : 작업한 내용을 로컬 저장소에 저장하는 것을 의미합니다. Repository : 저장소를 의미 합니다. 저장소에는 2가지가 있습니다. -Local Repository : 본인 PC에 존재하는 저장소를 의미합니다.-Remote Repository : Github, Gitlab과 같은 원격저장소를 의미합니다. Push : 로컬저장소(Local Repository) 에서 Commit이 완료된 내용을 원격저장소에 업로드 하는 것. Clone : 원격저장소의 내용을 통째로 다운로드 하는 것을 말합니다. Branch : 가지 또는 분기점을 의미, 현재 상태를 복사하여 자신만의 branch를 만들수 있고 작업이 완료되면 merge를 통해 합칠 수 있다. Checkout : 특정 시점이나 브런치로 이동하는 것을 의미 Fetch : master나 다른 branch에서 작업한 내용이 내 로컬저장소와 버전이 맞지 않을때 최신버전으로 업데이트 Merge : 다른 branch의 내용을 현재 branch로 가져와 합치는 작업 Pull : 원격저장소의 변경된 내용이 로컬저장소에 반영됩니다.(fetch + merge) git에서 일어나는 상태변화위 그림은 git을 사용하면서 일어나는 트랜젝션을 정리해 본 그림이다. git 명령어 본격적으로 git 명령어 들에 대해 알아보자모든 명령어를 나열하는 것은 아니고 주로 사용하는 명령어를 기준으로 써보고자 한다. 환경설정git configbash123git config --global --list // 현재 설정 정보를 조회합니다.git config --global user.name \"사용자명\" // 사용자명을 등록합니다.git config --global user.email \"이메일주소\" // 사용자 이메일주소을 등록합니다. 기본명령어git initbash1git init // 깃 저장소를 초기화 한다. 현재 디텍토리에서 git 저장소를 생성합니다. git statusbash1git status // 저장소 상태 보기 저장소의 상태를 체크 합니다. Commit이 필요한 변경사항이 있는지, 현재 저장소의 어떤 브런치를 작업하고 있는지 등을 볼 수 있다. git diffbash123456git diff // 스테이징 영역과 현재 작업트리의 차이점을 보여준다.옵션HEAD // 저장소, 스테이징 영역, 작업트리의 차이점을 모두 볼수 있다.--cached // 스테이징 영역과 저장소의 차이점을 볼 수 있다.--stat // 변경사항에 대한 통계를 볼 수 있다. git addbash123456789git add &lt;파일이름&gt; // 파일단위로 선택git add . // 모든 파일 추가 또는git add *옵션 -i // 대화형모드 실행, 일부분만 선택하여 스테이징 가능-p // 대화형 모드 없이 바로 패치모드 사용 단일 파일 또는 변경된 모든 파일을 스테이징 한다. git commitbash123git commitgit commit -m \"커밋메세지\"git commit -a // 스테이지에 올리는 것과 커밋을 동시에 진행 git revertbash1git revert &lt;커밋아이디&gt; 기존 커밋에서 변경한 내용을 취소해서 새로운 커밋을 만듭니다. git resetbash123git reset --&lt;커밋아이디&gt; // 커밋 취소git reset --hard &lt;커밋아이디&gt; // 해당 위치로 되돌림git reset --hard HEAD // 마지막 커밋 상태로 되돌림 git logbash123456git log옵션-3 // 출력할 커밋로그의 갯수를 지정 할 수 있습니다.--oneline // 한 줄로 간단하게 보여줍니다.--graph // 브런치 트리를 볼 수 있습니다. 커밋로그들을 볼 수 있습니다. 여러가지 옵션들을 적절히 사용하면 자신이 원하는 로그만을 볼 수 있습니다. Branch 명령어branch 목록bash1234git branch // 로컬 브런치git branch -v // 해당 브런치의 commit ID도 볼 수 있다.git branch -r // 리모트 브런치git branch -a // 로컬, 리모트 포함된 모든 브런치 브런치목록을 보여줍니다. 옵션을 통해 원하는 저장소의 브런치를 볼 수 있습니다. branch 생성bash1git branch &lt;브런치이름&gt; // 원하는 이름으로 브런치를 생성한다. branch 삭제bash1git branch -d &lt;브런치이름&gt; git checkoutbash1git checkout &lt;브런치이름&gt; // 활성 브런치 변경 git mergebash1git merge &lt;브런치이름&gt; // 브런치이름의 내용을 현재 브런치로 합친다. 원격저장소git clonebash1git clone &lt;저장소주소&gt; &lt;폴더명&gt; //원격저장소를 복제하여 저장소를 생성합니다.(폴더명은 생략가능) git remotebash123git remote add &lt;저장소이름&gt; &lt;저장소주소&gt; // 원격저장소 연결git remote -v // 연결된 원격 저장소를 보여줍니다. git remote rm &lt;저장소이름&gt; // 원격저장소를 제거합니다. git fetchbash1git fetch 원격저장소의 변경사항을 가져와서 갱신합니다. git pullbash12git pull git pull -rebase &lt;저장소이름&gt; &lt;브런치이름&gt; // 커밋메세지를 남기지 않는다. git pushbash123git push // 원격저장소에 업로드 한다.git push &lt;저장소이름&gt; &lt;브런치이름&gt;git push origin master 파라미터 값을 주지 않으면 origin 저장소에 푸싱하며 현재 지역브런치와 같은 이름으로 브런치에 푸싱합니다.","link":"/2019/06/03/git-basic/"},{"title":"Hexo 블로그 Github를 이용해 만들어보기","text":"블로그를 만들고 꾸미다 보니 나같은 사탐들이 많을 거라는 생각에서Hexo를 이용해 Github 블로그 세팅 하는 방법들을 처음부터 하나씩 보고자 한다. HexoHexo는 Node.js 기반의 정적 사이트 생성기(Static site generator)이다.Hexo 공식 사이트에서는 빠르고 간단하고 파워풀한 블로그 프레임워크라고 소개하고 있다.npm을 통해 쉽게 설치가 가능하고 배포역시 쉽게 가능한 것이 장점이다.한글문서로도 잘 정리가 되어있으니 참고 하길 바랍니다. Hexo 한글 튜토리얼 설치 전 준비Github를 이용하여 Hexo 블로그를 세팅 하려고 하기때문에 Git Node.js(npm) Github 계정 위의 구성요소들의 사전 설치가 필요하다. 위에 설치 방법들은 이번 포스팅에서는 따로 언급하지 않고 공식사이트로의 링크들만 걸어 놓겠습니다. 설치하기node.js가 설치되어 있다면 npm을 이용해서 간편히 설치 할 수 있습니다. bash1npm install hexo-cli -g 블로그 Setup아래 명령을 실행 하여 간단하게 hexo를 초기화 할수 있습니다. bash123hexo init &lt;폴더이름&gt;cd &lt;폴더이름&gt;npm install 초기화가 완료되면 아래와 같은 구조로 세팅됩니다. 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 블로그 설정_config.yml이 root경로에 생성되는데 해당 파일을 통해서 블로그에 대한 설정을 세팅할 수 있습니다.자세한 설명은 Hexo의 Cofiguration을 통해 확인해 볼수 있다. Cofiguration : https://hexo.io/ko/docs/configuration 로컬테스트간단한 설정을 하고 나서 바로 로컬 서버에서 띄워 확인해 볼 수 있습니다. bash12hexo serverhexo s #단축명령어 서버가 구동되면 아래와 같은 문구가 출력되며 http://localhost:4000에서 확인 할 수 있습니다. 1Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. Github 블로그 호스팅Github에서 새로운 repository를 생성합니다.Repository name을 username.github.io의 형식으로 기재하고 public으로 만들어 줍니다. 설정하기_config.yml 에서 Deployment 항목을 설정해 준다. 12345# Deploymentdeploy: type: git repo: repository 주소 branch: master Github에 배포하기hexo server를 통해 로컬에서 정상적으로 작동되었다면 Github에 hexo cli를 통해 쉽게 배포가 가능하다. 정적리소스 생성bash12hexo generate hexo g #단축 명령어 public 폴더가 생성되어 배포가 가능하다. 배포하기bash12hexo deployhexo d #단축 명령어 배포 중 오류가 발생 하면 아래 이슈체크를 확인 Generate와 Deploy 동시실행아래와 같이 Generate와 Deploy를 동시실행 할 수도 있다. bash12345hexo deploy --generate #Deploy 전에 Generate를 해준다.hexo d -g #단축 명령어hexo generate --deploy #Generate 후에 Deploy를 해준다.hexo g -d #단축 명령어 https://username.github.io 로 접속하면 deploy된 사이트가 확인 가능하다. 이슈체크배포시 아래와 같은 에러가 발생하면1ERROR Deployer not found: git hexo-deployer-git 플러그인을 설치해준다. bash1npm install hexo-deployer-git --save 업데이트 시간혹 업데이트가 바로 이루어 지지 않을 경우에는 아래와 같이 public을 clean시켜준 후 배포를 하면 된다. bash12hexo cleanhexo d -g 글쓰기bash1hexo new post &lt;포스트이름&gt; \\source_post 폴더에 포스트이름.md 으로 새로운 마크다운 파일이 생성됩니다.포스트내용을 작성한후에 다시한번 clean과 generate 그리고 deploy를 해주면 정상 반영된다. 이상으로 Hexo 블로그 만들기에 대한 포스팅을 마친다.잘못된 사항이나 궁금한 점은 댓글로 남겨주시면 감사하겠습니다.","link":"/2019/06/12/hexo-blog/"},{"title":"Disqus를 사용하여 댓글 기능 세팅하기","text":"오늘은 블로그의 세팅중 한가지인 댓글 기능을 세팅하는 방법에 대해 포스팅해보겠습니다. 사실 hexo 테마들의 대부분은 여러 댓글 시스템들을 간편하게 세팅 할 수 있도록 되어있습니다.그 중에 디스커스(Disqus)를 사용하여 댓글 기능을 세팅해보겠습니다. 디스커스(Disqus)란?디스커스는 소셜 댓글 서비스의 하나입니다. 소셜 댓글 서비스란 소셜미디어(SNS)를 활용한 댓글 시스템으로 페이스북,트위터 와 같은 SNS와 연동해서 댓글을 달 수 있게 만들어 주는 서비스입니다. 소셜 댓글 서비스를 활용하여 댓글을 달면 동시에 해당 댓글이 자신이 연동한 SNS에도 발행이 됩니다.별도의 댓글시스템을 구현할 필요없이 디스커스에서 제공하는 위젯을 설치함으로 사용 할 수 있는 것이 장점입니다. 설치순서 Disqus 회원가입 Settings &gt; profile, Account 수정 Add Disqus To Site &gt; I Want to comment on site 사이트 추가 Account &gt; Username 확인 (shortname) _config.yml 설정 변경 회원가입Disqus 회원이 아니라면 회원가입이 필요합니다.Disqus 사이트에서 회원가입을 진행합니다. 정보 수정Settings 에 profile 과 Account에서 필요한 정보들을 수정해 줍니다. 사이트 추가우측 상단의 Add Disqus To Site 에 들어가서 I Want to comment on site 를 클릭 혹은 메인에서 GET STARTED 에 들어가서 I Want to comment on site 를 클릭 해당 정보들을 입력 후 Select a plan 에서 Basic 을 선택 Select Platform 단계에서는 맨 아래의 universal Code를 선택해 줍니다. 여기는 테마마다 조금 다릅니다. 디스커스를 지원하는 테마라면 configure 누르고 사이트 세팅을 마친다음_config.yml 의 설정만 변경 해주면 되고 안되어 있다면 소스를 추가해 주어야 한다. 그 때 이 코드를 사용하여 주면 됩니다.Installation instructions 계정정보 확인Account 에서 Username(shortname)을 확인하여 줍니다. _config.yml 설정_config.yml123comment: type: disqus shortname: disqus 계정이름 이 부분은 현재 제가 사용하는 icarus 테마의 _config.yml의 양식이고 테마마다 조금씩 다를수 있습니다. 배포1hexo d -g 배포를 시켜주고 아래와 같이 나온다면 성공입니다. 오류체크icarus테마는 기본적으로 disqus 댓글 시스템을 지원하고 있어서 위와같이 세팅하면 정상적으로 댓글기능이 작동해야 하지만무엇이 문제였는지 시스템 자체는 연결되었는데 댓글을 작성하는 위젯이 제대로 작동하지 않았다 ㅠㅜ icarus테마에서 제공하는 포스팅에서도 comment Plugin 의 설정만을 변경해 주면된다고 나오는데 말이다.Disqus Comment Plugin 여러가지를 시도해 보다 결국 소스코드 자체를 변경하는 것으로 해결하였다.icarus 테마의 경우 disqus.ejs 파일의 내용을 universal Code에서 제공하는 코드로 변경하니 정상적으로 작동되었다.테마마다 약간의 설정이 다를수 있으니 참고정도만 하시면 되겠습니다. 언어선택 문제현재 disqus에서는 한글을 지원하지 않는 것으로 변경되었다고 한다.그래서 편법으로 설정하는 방법이 있는데 편법이라 방법이 나와있는 포스팅을 공유하는 것으로 대체한다.디스커스 한글 세팅을 해보자","link":"/2019/07/02/hexo-comment-disqus/"},{"title":"쿠팡파트너스 Hexo 블로그에 등록하기","text":"모든 블로거들의 목표중에 하나인 블로거를 통한 수익창출을 시도해 보았습니다.물론 큰 기대는 하지 않습니다 ㅎㅎㅎ;;;많은 광고 시스템중에서 오늘 해볼것은 간단하게 설치가 가능한 쿠팡 파트너스 입니다. 쿠팡 파트너스는 CPA 방식의 광고 시스템입니다. CPA란?Cost Per Action 의 줄임말입니다. 변역하자면 ‘행위 당 과금’ 방식입니다.단순히 광고를 클릭하는 것으로 수익배분이 일어나는 것은 아니고 광고를 클릭해서 사이트로 접속하여 제품을 구매했을 때, 제품 구매가의 3%가 포인트로 적립되는 방식입니다. 가입먼저 회원가입이 필요합니다. 쿠팡파트너스로 접속하여 회원가입을 하여 줍니다.기존 쿠팡아이디로도 사용가능하니 있으신 분은 별도의 가입이 필요없습니다.가입 하는 방법 자체는 매우 간단하니 생략하도록 하겠습니다. 가입승인이 2~3일 정도 걸린다고 하는데 그 사이에 시스템이 바뀌었는지 저는 가입하자마자 바로 등록할 수 있었습니다. 회원가입시에 추천인 코드를 쓰면 1%추가 적립을 받을수 있다고 합니다.추천인코드가 필요하신 분은 가져다 쓰세요 ^^ ID : AF3074287 상품링크쿠팡 파트너스에서는 여러가지 형태의 배너를 제공하고 있습니다.상품링크에 메뉴를 선택하면 위와 같이 여러가지 형태에 링크 또는 배너를 만들 수 있습니다.블로그에 맞는 배너를 선택하셔서 사용 할 수 있습니다. 배너생성링크링크의 경우 마음에 드는 상품을 선택해서 url 혹은 배너로 만들수 있는 기능입니다.한가지 상품만 노출되는 형태로 쿠팡에 있는 상품을 블로그로 작성하고 광고 할때 수익을 볼 수 있는 형태로 작성하는 것이 좋을 것 같습니다. 상품 탐색에서 원하는 상품을 검색 마음에 드는 상품 선택단계로 넘어가면 상품탐색에서 검색한 상품들이 나옵니다. 그 중에 원하는 상품상품 정보를 확인하고 링크생성을 누릅니다. URL 혹은 배너 만들기에서 생성된 단축 URL만을 사용하셔도 되고 아래에 있는 태그를 복사하셔서 블로그에 사용하시면 됩니다. 간편링크만들기간편링크만들기의 경우에는 URL을 생성하는 기능입니다.추천링크로는 쿠팡홈, 골드박스, 로켓와우, 로켓배송, 로켓직구가 있고 그 외의 링크도 쿠팡에서 원하는 페이지 찾아보기를 클릭하셔서원하는 링크를 아래 인풋창에 복사하셔서 링크생성 버튼을 누르면 파트너스URL이 생성됩니다.이 링크를 블로그에 사용하셔서 사용자가 링크를 타고 물건을 구매하게 되면 수익배분이 일어납니다. 다이나믹 배너저는 이 기능을 이용해서 배너를 만들었습니다. 크기를 마음대로 조정 할 수 있어서 자신의 블로그에 맞는 형태로 적용할수 있으며여러가지 상품들이 슬라이드 형태로 노출되어서 특정상품의 배너 보다는 방문자의 클릭이 있을것 같아서 선택했습니다. 배너생성버튼을 눌러서 배너 만들기를 시작합니다. 배너명을 정해주고 배너타입,카테고리를 선택해 줍니다. 저는 랜덤으로 돌아가는 파트너스 추천과 Coupang Only를 선택했습니다.그리고 원하는 크기를 입력하고 테두리 여부를 선택합니다.미리보기 화면을 통해서 원하는 형태로 만들어 졌는지 여부를 확인 할 수 있습니다. 배너 만들기 버튼을 클릭하면 하단에 파트너스 코드가 생성됩니다.이 코드를 복사해서 블로그에 넣으시면 배너 등록 완료입니다. 배너의 크기를 %로 작성 할수 있습니다. 100%로 작성하시면 반응형 페이지에도 사용하기 편합니다. 배너, 검색위젯배너와 검색위젯 기능은 미리 만들어진 배너를 사용할수 있는 코드들을 보여줍니다.원하는 형태의 배너를 선택하셔서 사용하시면 됩니다. Hexo 블로그에 적용레이아웃의 경우 적용하신 테마에 따라 형식이 조금씩 다르겠지만 보통 layout 폴더에서 ejs파일들로 관리합니다.EJS 는 Embedded JavaScrip의 줄임말로 간단한 자바스크립트로 HTML마크업을 생성 할수 있는 간단한 템플릿언어입니다.hexo블로그들은 대부분 ejs로 작성되어있습니다. layout폴더 경로에 layout/ads라는 폴더를 만들고 coupang_ad.ejs라는 파일을 새로 생성합니다.배너 만들기를 통해 생성한 코드를 coupang_ad.ejs에 입력해 줍니다. coupang_ad.ejs12345//예시코드입니다. 생성받으신 코드를 입력하시면 됩니다.&lt;script src=\"https://ads-partners.coupang.com/g.js\"&gt;&lt;/script&gt;&lt;script&gt; new PartnersCoupang.G({ id: });&lt;/script&gt; 그리고 원하시는 위치에 위의 코드를 불러오면 됩니다.형태는 &lt;%- partial('ads/coupang_ad') %&gt; 이것 처럼 넣으시면 됩니다. 이때 확장자는 쓰시면 안됩니다. 원하는위치.ejs1&lt;%- partial('ads/coupang_ad') %&gt; 이제 모든 과정이 끝났습니다. 블로그를 재배포 해준후에 확인하시면 잘 들어가 잇는 것을 볼 수 있습니다.쿠팡파트너스 페이지에서 클릭,구매액,수익 등을 확인 할 수 있습니다. 그리고 회원가입시에 추천인 코드를 쓰면 1%추가 적립을 받을수 있다고 합니다.추천인코드가 필요하신 분은 가져다 쓰세요 ^^ ID : AF3074287 우리모두 블로그로 부수입을 창출해 봅시다. ㅎㅎㅎ","link":"/2019/06/21/blog-ad-coupang/"},{"title":"hexo 블로그에 테마 적용하기 - icarus테마","text":"hexo를 이용해서 github블로그를 만들었습니다. 이제는 나만의 색깔을 입혀볼 테마를 적용해 보겠습니다.블로그 세팅 방법은 지난 블로그를 참고하면 좋을것 같습니다. ^^ hexo블로그에 테마를 입히는 방법은 사실 아주 간단 합니다.git을 이용하여 clone만 해주면 됩니다. 하지만 테마들마다 사용방법이나 설정법이 약간씩 다르고 자신의 색깔에 맞게커스텀을 하려고 한다면 점점 복잡해 집니다.테마마다 설정방법이 다르기 때문에 이번 포스팅에서는 제가 적용한 icarus테마를 기준으로 설명하겠습니다. 테마 고르기 우선 자신의 블로그에 적용할 테마를 고릅니다.Hexo Themes 에서 자신이 원하는 테마를 골라줍니다.Hexo Themes에는 많은 개발자들이 hexo를 사용하여 만든 테마 목록들을 확인하고 다운받을 수 있습니다. 물론 별도로 만들수도 있지만 시간이 많이 들고 잘만들어진것들이 많이 있으니 오픈소스를 적극 활용 해보기로 합니다. ㅋ 저는 테마를 고를때 디자인, 반응형, 영문메뉴얼유무 를 따져 보았고 그 중에 여러가지 테마를 적용해 보고icarus테마를 골랐습니다. 테마 적용하기 앞에서 말했듯이 테마별로 적용 방법의 약간의 차이가 있을수 있으나 대체적으로 git clone 을 이용하여 설치하는 방법을repository에 README 파일로 적용방법을 알려주고있다.icarus테마역시 hexo-theme-icarus repository에서 설치방법을 알려주고 있다. 설치터미널을 이용하여 hexo블로그가 있는 폴더에 들어가 줍니다. icarus테마를 themes/icarus 경로에 clone 받아 줍니다. bash12cd bloggit clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 위와 같이 입력해 주면 themes 디테토리 하위에 icarus 라는 디텍토리가 생기면서 해당 저장소의 내용을 clone 하여 줍니다. 그리고 blog 폴더 안에있는 _config.yml에서 theme 부분을 landscape에서 icarus로 수정해줍니다. _config.yml123# Extensions## Themes: https://hexo.io/themes/theme: icarus 이렇게만 설정하고 배포하여 주어도 테마가 잘 설정된 모습을 볼 수 있다.하지만 이렇게만 설정하였을 경우 전체 git repo안에 다른 repo가 들어간 형태가 되어blog repo만 관리하여 백업을 하게 되면 themes/icarus 안에 내용은 전혀 백업이 되지 않는다.지난 포스트에서 설명했듯이 테마를 따로 백업해준뒤에 git submodule기능을 사용하여 추가해 주는 것이 관리하기 좋다. 설정themes/icarus 폴더에 있는 _config.yml에서 테마 설정을 변경 할 수 있습니다.블로그 폴더에도 _config.yml에서 설정을 변경하였는데 테마 역시 _config.yml를 사용하여 설정하여 준다. 블로그 폴더의 _config.yml가 hexo블로그의 전반적인 설정 이라면themes/테마 폳더의 _config.yml는 hexo 블로그에 적용된 테마의 추가 설정이라고 보면된다.","link":"/2019/06/19/hexo-themes/"},{"title":"hexo 포스팅 스타일 설정하기","text":"hexo를 통해 포스팅을 하다보니 테마커스텀에 대한 욕구가 스멀스멀 솟아올랐다. ㅎㅎㅎ;;메인 이미지도 그리고 아이콘이나 위젯들의 위치도 이곳 저곳 옮겨보기도 하면서나름 나만의 스타일로 하나씩 바꿔나가는 재미가 있었다, 아래 내용들은 현재 제가 사용하고 있는 icarus 테마를 기준으로 작성한것입니다.다른 테마에서는 다른 방법이 있을 수 있습니다. 그렇게 블로그를 조금씩 꾸미고 여러가지 포스팅들도 올리고 하다가 한 가지 의문이 생겼다.바로 포스트 리스트에서 사용하는 위젯들을 _config.yml 에서 설정으로 잡아 주었는데포스트 상세페이지에서도 똑같이 노출이 되다보니 포스트 본문의 가로 넓이가 너무 적게 보인다는 점이었다. 그래서 _config.yml에 있는 설정들을 하나씩 뜯어보고 해당 기능이 있는지 찾아보았지만원하는 기능은 없는것 같아서 기운없이 여러 블로그를 돌아다니고 있는 도중에 내가 사용하는 테마를 같이 사용하는블로그에서 리스트와 포스트 상세페이지에 스타일이 다른 것을 발견하고는 다시 이것 저것 세팅을 바꿔보고해당 블로그와 코드도 비교해 보면서 방법을 찾기 시작했다. 그러던 중 정말 우연히 내 포스트와 다른 점을 발견하게 됐고 방법을 찾았다.나와 같은 필요를 느끼고 있는 분들을 위해 그 방법을 간단하게 정리해 보고자 한다. 우선 포스팅방법이 궁금하신 분들은 지난번에 작성한 hexo 포스팅 방법을 참고하면 됩니다. 여러가지 실험끝에 발견한 방법은 그러한 세팅이 따로 존재하는 것이 아니라 포스팅을 작성할때머리말(Front matter)에 해당 파일의 정보를 입력해주면 되는 것이었다. 머리말은 지난 포스트에서 설명했듯이 포스트 생성시 포스트 최상단에 자동으로 생성이 됩니다.저자는 이곳에 카테고리,태그,썸네일등을 지정하여 포스트마다 다르게 노출되는 값들을 입력하는 곳이라 생각하였고머리말을 이용하여 위젯이나 레이아웃을 변경할 수 있을것이라고는 미처 생각하지 못했었다.그렇게 한참 다른 곳을 해메이다가 우연히 머리말의 입력값이 다른 것을 발견하고는 유레카를 외쳤다. 저자는 포스트작성시 머리글에 카탈로그,카테고리,태그 클라우드 위젯을 추가하고 싶었고포스팅 우측에 고정으로 놓고 싶었다. 그래서 아래와 같은 설정을 머리말에 추가해 주었다. 머리말1234567891011toc: truewidgets: - type: toc position: right - type: category position: right - type: tagcloud position: rightsidebar: right: sticky: true 하나씩 옵션을 살펴보면 머리말12345678910111213141516toc: true# 카탈로그 옵션을 사용하기 위해 true옵션을 사용하였다.widgets: - type: toc position: right - type: category position: right - type: tagcloud position: right # 위젯의 타입을 지정하여주고 위치를 오른쪽으로 지정하였다. sidebar: right: sticky: true# sticky 옵션은 true로 하여 우측에 고정을 시켜주었다. 위와 같은 내용들을 머리말에 추가하여 원하는 스타일로 꾸밀 수 있었다. 그리고 매번 포스팅을 할때위의 내용을 작성하면 번거롭기 때문에 스캐폴드에 해당내용을 추가해서 자동으로 추가되게 세팅하였다. 이상으로 hexo 포스팅 스타일 설정하기 포스팅을 마칩니다. 해당글로 많은 분들이 조금이나마 쉽게 hexo 블로그를 접하고 꾸밀 수 있기를 바랍니다.도움이 되었다면 댓글을 살포시 남겨주시면 감사하겠습니다.","link":"/2019/07/29/hexo-post-setting/"},{"title":"[VScode] Visual Studio Code에서 터미널을 git bash 기본으로 설정하기","text":"Visual Studio Code(이하 VScode)에서 터미널을 같이 사용 할수 있습니다. 별도의 창으로 작업을 하면 비효율 적이기도 하고 탭을 계속해서 눌러주어야 하는 불편함을 감수해야 합니다.VScode의 기본 터미널 사용값은 powershell입니다. 설정변경을 통해서 gitbash를 사용 할 수 있습니다. git bash로 변경하는 방법VScode를 실행해서 ctrl + , 를 눌러 설정에 들어갑니다. 설정 검색칸에 terminal.integrated.shell.windows를 입력합니다. 위와 같이 검색결과가 뜹니다.settings.json에서 편집을 누릅니다. settings.json 편집아래와 같이 문구를 추가해 줍니다. settings.json12345678910{ \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\", \"workbench.startupEditor\": \"newUntitledFile\", \"editor.renderIndentGuides\": false, \"editor.minimap.enabled\": false, \"editor.renderWhitespace\": \"boundary\", \"window.zoomLevel\": 0, \"workbench.iconTheme\": \"vscode-icons\", \"files.autoGuessEncoding\": true} &quot;C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe&quot;에는 설치경로가 다르다면 자신의 git 설치경로를 입력해 줍니다. 저장을 해주고 ctrl+shift+` 을 눌러서 새 터미널을 열어 확인합니다.바로 반영이 안되면 VScode를 한번 껏다가 켜줍니다. 터미널 단축키 바꾸기터미널 단축키를 편하기 변경 할 수 있습니다.ctrl + k , ctrl + s 눌러서 바로 가기 키 설정에 들어갑니다. 검색창에 터미널을 검색합니다.더블클릭하면 새로운 단축키를 설정할 수 있습니다.","link":"/2019/06/24/vscode-gitbash/"},{"title":"[VScode] VScode Extension - 확장프로그램 추천 및 설치방법","text":"VScode는 비교적 가벼운 에디터 입니다. 기본적으로는 필수적인 기능들만을 제공 하고 있습니다.대신 마켓플레이스(Marketplace)를 통해서 많은 확장프로그램(Extension)들을 설치하여 즉시 사용 할수 있습니다.확장프로그램을 통해 보다 편리하게 코드를 작성 할 수 있습니다.그 중에서 많이 사용하는 것들을 한번 알아보겠습니다. 확장프로그램 찾아보기VScode 내에서 확장기능을 찾아서 설치할 수 있습니다. VScode를 실행하면 왼쪽에 여러가지 아이콘들이 있습니다.그 중에 가장 아래에 있는 네모모양의 아이콘 또는 명령어(Ctrl+Shift+X)를 실행하여 확장프로그램들을 확인할 수 있습니다. * 검색창의 검색을 통해서 간단하게 설치 할수 있습니다. 확장프로그램 리스트 (Extension List)Korean Language Pack for Visual Studio CodeKorean Language Pack for Visual Studio Code는 VScode의 언어의 한국어 팩입니다. VScode의 언어를 한국어로 변경해 줍니다. Git HistoryGit history는 Git으로 관리되는 프로젝트의 Git log. file History, branch, commit 등을 편리하게 확인 할수 있는 확장프로그램입니다.파일을 열고 F1키를 누르고 Git: View History, Git: View File History, Git: View Line History를 입력하여 사용합니다. Active File In StatusBarActive File In StatusBar는 Vscode 상태 표시 줄에 현재 활성 파일의 전체 경로를 표시하는 확장 프로그램입니다.현재 활성 파일의 경로를 하단 상태 막대에 표시합니다. 이 경로를 클릭하면 클립보드에 복사하여 사용 할수 있습니다. Auto Rename TagAuto Rename Tag는 HTML/XML 태그의 이름을 자동으로 바꿉니다. GuidesGuides은 안내선을 표시해 주는 확장프로그램입니다. indent-rainbowindent-rainbow는 텍스트 앞의 들여쓰기를 각 단계에서 네가지 색상으로 번갈아 보여주어 들여쓰기를 보다 쉽게 읽을 수 있게 해주는 확장프로그램입니다. Rainbow BracketsRainbow Brackets은 괄호(bracket)마다 다른 컬러를 제공합니다. Settings SyncSettings Sync는 Github Gist를 사용하여 VScode의 설정(확장플러그인 포함)을 동기화 시켜주는 도구 입니다. Waka TimeWaka Time은 VScode에서 어떤 프로젝트에서 어떤 언어로 작성했는지 그에 따른 비율 시간을 측정하여 줍니다.별도의 회원가입이 필요합니다. VScode 플러그인에 API kye를 입력해서 사용합니다. 위의 확장프로그램들은 제가 사용하는것 위주로 정리하였습니다. 추천 프로그램 있으면 댓글로 남겨주세요^^","link":"/2019/06/24/vscode-extension/"},{"title":"Hexo 포스팅 방법","text":"이전 포스팅 에서 Hexo 블로그의 세팅 방법과 간단한 글쓰는 방법 그리고 SEO세팅 등에 대헤 알아보았습니다.Hexo는 간단한 포스팅 외에도 다양한 기능의 포스팅 방법을 제공해 줍니다.이번에는 포스팅 방법에 대한 내용들을 정리해 보겠습니다. 글쓰기(Writing) hexo 명령어를 사용하여 새로운 포스팅의 마크다운 파일을 생성해 줍니다. bash 12hexo new &lt;layout&gt; &lt;포스트이름&gt;hexo new &lt;포스트이름&gt; # layout을 지정하지 않으면 기본으로 post을 생성합니다. 위 명령어를 실행하면 \\source_posts 폴더에 포스트이름.md 으로 새로운 마크다운 파일이 생성됩니다.파일명에 띄어쓰기가 있다면 하이픈(-)으로 표시됩니다. layout 에는 3종류가 있습니다. -post-draft-page 각기 다른 경로에 보관 됩니다. layout 경로 특징 post source/_posts 기본 레이아웃 draft source/_drafts 게시되지 않는 초안 page source 새로운 페이지를 작성 Post (포스트)기본 레이아웃으로 레이아웃 종류를 입력하지 않으면 자동으로 포스트로 인식합니다.기본 레이아웃의 변경은 _config.yml 의 default_layout 항목에서 변경 할 수 있습니다. bash 1hexo new post &lt;포스트이름&gt; page (페이지)새글을 추가하는 것이아니라 별도의 페이지를 생성합니다. bash 1hexo new page &lt;페이지이름&gt; draft (초안)포스트를 바로 발행 하는 것이 아닌 초안 형태로 저장한다. bash 1hexo new draft &lt;포스트이름&gt; 기본 레이아웃 변경을 _config.yml 의 default_layout 항목에서 draft로 변경하면,hexo new &lt;포스트이름&gt; 명령어 실행시 post가 아닌 draft로 생성됩니다. 초안으로 작성된 글은 로컬서버에서 확인 할 수 있다. bash 1hexo server --draft 초안으로 작성된 글을 post로 변경할려면 수동으로 _posts폴더로 옮길 수도 있지만아래와 같은 hexo 명령어로 publish가 가능하다. bash 1hexo publish &lt;포스트이름&gt; 스캐폴드 (Scaffolds) 포스트의 구조를 설정할때 사용합니다. Scaffolds폴더 안에 각 md파일을 수정하여 설정을 변경할 수 있습니다. /scaffolds/post.md12345---title: {{ title }}date: {{ date }}tags:--- 기본적인 구조는 위와 같이 되어있고 각 항목들을 추가하여 기본값을 설정해 줍니다.저 같은 경우에는 태그, 카테고리, 썸네일 등을 추가로 작성해 놓았습니다. /scaffolds/post.md1234567---title: {{ title }}date: {{ date }}categories:tags: [ ]thumbnail: /img/ --- 머리말 (Front matter) 머리말(Front matter)은 포스트 생성시 포스트 최상단에 자동으로 생성되며 해당 파일의 정보를 입력하는 곳입니다. 형태는 ---로 구분되어 있습니다. 항목사용하는 항목들을 스캐폴더에 미리 지정해 놓으면 편리하게 사용 할 수 있습니다.Docs : https://hexo.io/ko/docs/front-matter.html 설정 설명 기본값 layout 레이아웃 title 타이틀 date 발행일 파일이 생성된 날짜 updated 갱신일 파일이 업로드된 날짜 comments 포스트에서 comment 기능을 사용할지 여부 true tags 태그 (page에서는 사용 불가능) categories 카테고리 (page에서는 사용 불가능) permalink 포스트의 기본 permalink를 override합니다. 카테고리와 태그 (categories,tags)카테고리와 태그는 Post와 Draft에서만 사용 가능합니다. 카테고리를 여러가지 지정할 경우 분류와 하위 분류의 계층적인 관계를 가집니다. 즉 위에 있는게 메인카테고리 아래에 있는게 서브카테고리가 됩니다. 태그는 순서와 상관없이 모두 같은 계층입니다. 여러개를 작성할 경우 아래와 같이 사용 할 수 있습니다. post.md1234567891011categories:- 카테고리이름- 서브카테고리이름tags:- 태그- 태그- 태그#또는 아래와 같이도 사용 할 수 있습니다.categories: [카테고리이름, 서브카테고리이름]tags:[태그, 태그, 태그] 머리말(Front matter)의 항목은 기본적으로 제공하는 것 외에 각 테마들마다 다양한 옵션들을 가지고 있습니다.자신에게 맞는 항목들을 찾아서 사용하시면 됩니다. 요약글기본적으로 요약글 형태로 보여줄수 있는 기능을 제공합니다. &lt;!-- more --&gt;을 사용해서 요약글을 만들수 있습니다. 테마에 따라 첫페이지에서 자동으로 요약글 형태로 만들어 주는 테마도 있지만 없는 경우에는 &lt;!-- more --&gt; 기능을 사용합니다.사용방법은 포스트 본문에 첫페이지에서 보여줄 부분 밑에 &lt;!-- more --&gt;을 추가하면 read more 버튼이 생성되고 아래의 내용은 보여지지 않습니다. 포스트의 작성이 끝나면 Generate와 Deploy 실행하여 업데이트 해주면 된다.포스트의 적용이 바로 되지 않을 경우에는 Clean을 같이 실행 해준다. bash12hexo cleanhexo d -g","link":"/2019/06/10/hexo-writing/"},{"title":"마크다운(Markdown) 사용법을 알아보자","text":"블로그를 hexo로 옮기게 되면서 가장 처음 접한 문제는 github 그리고 마크다운이었다.세팅은 여차저차 했지만 글 작성에서부터 막히기 시작했다.나와 같은 사람들을 위해 쉽게 마크다운 사용법을 정리해 보았다. 먼저 간단하게 마크다운에 대해 알아보고 넘아가겠습니다. 마크다운(Markdown) 마크다운(Markdown)은 일반 텍스트 문서의 양식을 편집하는 문법이다.README 파일이나 온라인 문서, 혹은 일반 텍스트 편집기로 문서 양식을 편집할 때 쓰인다.마크다운을 이용해 작성된 문서는 쉽게 HTML 등 다른 문서 형태로 변환이 가능하다.위키백과 마크다운의 장점과 단점 장점 문법이 쉽고 간결합니다. 별도의 도구가 필요없다. 지원하는 플랫폼과 프로그램이 다양하다. 다양한 형태로 변환이 가능하다. 단점 표준이 없고 그로인해 사용자마다 문법이 다르다. 모든 HTML 마크업을 대신 할 수 없다. 마크다운 문법(Syntax) 제목 (Header)HTML의 &lt;h1&gt;부터 &lt;h6&gt;으로 변환되며 제목을 표현할 때 사용합니다. .md123456# 제목1## 제목2### 제목3#### 제목4##### 제목5###### 제목6 수평선 (Horizontal rule)HTML의 &lt;hr&gt; 태그로 변환됩니다.수평선을 표시하는 방법은 여러가지가 있다.각 기호를 3번 이상 입력하는 방법으로 사용한다. .md123--- (Hyphens)*** (Asterisks)___ (Underscores) 인용문구 (Blockquote)HTML의 &lt;blockquote&gt; 태그로 변환됩니다.중첩해서 사용이 가능합니다.인용안에서 마크다운 문법을 사용할 수 있습니다. .md123&gt; 안용문구를 나타낼때 사용합니다.&gt;&gt; 중첩해서 사용이 가능합니다.&gt;&gt;&gt; ## 인용의 인용 인용구문을 나타낼때 사용합니다. 중첩해서 사용이 가능합니다. 인용의 인용 목록 (List)HTML의 &lt;ol&gt;,&lt;ul&gt;,&lt;li&gt; 태그로 변환됩니다. 순서있는 목록 (ol)순서있는 목록은 숫자와 점을 사용합니다. .md1231. 첫번째2. 두번째3. 세번째 *특이한 점은 어떤 번호를 입력해도 순서는 내림차순으로 정의가 된다. 순서없는 목록 (ul).md123- 대쉬 (hyphen)* 별표 (asterisks)+ 더하기 (plus sign) 강조 (Emphasis)HTML의 &lt;em&gt;, &lt;strong&gt;, &lt;del&gt; 태그로 변환됩니다.밑줄 은 &lt;u&gt;&lt;/u&gt; 태그를 사용하시면 됩니다. 1234이텔릭체: *텍스트* 또는 _텍스트_ 를 사용두껍게: **텍스트** 또는 __텍스트__ 를 사용취소선: ~~텍스트~~ 를 사용&lt;u&gt;밑줄&lt;/u&gt; 은 &lt;u&gt;&lt;/u&gt; 태그를 사용 링크 (Link)HTML의 &lt;a&gt; 태그로 변환됩니다. .md123456[링크](링크주소)[링크](링크주소 \"링크설명- 생략가능\")문서안에서 [참조링크] 사용가능합니다.[참조링크노출설명][참조링크] 의 형태로 사용[참조링크]: 참조링크주소 \"링크설명 - 생략가능\" 이미지HTML의 &lt;img&gt; 태그로 변환됩니다.링크와 비슷하지만 앞에 !가 붙습니다. .md1![대체텍스트](링크 \"링크설명\") 이미지에 링크마크다운 이미지코드를 링크 코드로 묶어 줍니다. .md1[![대체텍스트](링크 \"링크설명\")](링크주소) HTML 코드 마크다운 문법 뿐 아니라 원시 HTML문법을 사용할 수 있습니다. 이상으로 마크다운 문법에 대해서 알아보았는데요 쉬운 면이 있으면서도처음 접하는 거라 그런지 낯선부분들도 있습니다.쓰다 보면 차차 익숙해지겠죠 ㅎㅎ 궁금하신 점이나 잘못된점은 언제든 댓글로 남겨주시면 감사하겠습니다.","link":"/2019/05/28/markdown/"},{"title":"Mac os에 zsh 세팅하기","text":"이번에 직장을 옮기면서 맥북 유저로 돌아왔다. 퍼블리싱작업을 할때는 별로 신경쓰지 않았던 작업환경들이 개발을 하게되고 맥북을 가지면서 조금더 편한 것들을 찾게 되었다. 그중에 하나로 zsh을 적용해 보았다. ZSH 란? Z 셸(Z shell, zsh)은 상호작용 로그인 셸이자 셸 스크립트를 위한 강력한 명령 줄 인터프리터로 사용할 수 있는 유닉스 셸이다.Zsh는 bash, ksh, tcsh의 일부 기능을 포함하여 수많은 개선 사항이 갖추어진 확장형 본 셸이다. 위키백과 ZSH 기능 살펴보기 경로 자동 추론 타이핑 교정 명령어 추천 다양한 플러그인 이쁜 디자인이 핵심이다 ㅋㅋㅋ 개발속도를 올려줄 수 있는 간편한 기능들이 많이 있다. ZSH 설치본격적으로 ZSH를 설치 해보자먼저 macOS 용 패키지 관리자인 Homebrew를 설치한다.설치방법은 Homebrew 사이트에 자세히 나와있으니 이번 포스팅에서는 생략한다. 먼저 아래 명령으로 zsh 가 설치되어있나 확인작업을 해준다. 12zsh --versionzsh 5.7.1 설치되어 있지 않다면 아래의 명령으로 설치를 해준다. 1brew install zsh 설치가 끝났다면 기본 쉘을 chsh을 사용하여 변경해준다. 1chsh -s `which zsh` Oh My ZshOh My Zsh는 ZSH 구성 관리를 위한 오픈 소스 커뮤니티 중심 프레임 워크 입니다. 여기에는 수천가지의 유용한 기능, 도우미, 플러그인, 테마 및 몇가지 소리가 제공됩니다. curl1$ sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" wget1sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" ZSH 설치가 완료되었다. 이렇게만 설치하고 사용하여도 상관없지만 이왕 설치한 김에 몇가지 편리한 기능들을 추가로 세팅해보기로 했다. iTerm2 설치iTerm2는 터미널의 부족한 기능들을 보안해주는 터미널 에뮬레이터이다. iTerm2에서 제공하는 많은 기능들 중에 유용한 기능들은 아래와 같다. 자동완성 기능 (Cmd + ;) 터미널 분할 창 기능 (Split Panes) 터미널 내에서 찾기 기능 마우스 없이 복사와 붙여넣기 더 많은 기능 살펴보기 : https://www.iterm2.com/features.html iTerm2 설치는 iTerm2홈페이지에서 다운로드 받은 후에 프로그램을 어플리케이션으로 옮겨주기만 하면된다. iTerm2 테마설치(선택)iTerm Color Schemes에 접속하여 컬러 스킨을 다운로드 받는다.다운을 받으면 iTerm2를 실행하여 cmd + ,를 눌러서 환경설정 창을 띄워준다. Profile &gt; colors 메뉴에 들어가서 Color Presets를 눌러서 하단의 imports를 누른다. 다운로드 받은 폴더 schemes의 테마 중 원하는 테마를 선택한다.(취향존중) ZSH 테마 설치많은 테마들 중에 필자는 Spaceship ZSH 테마를 설치해 보았다. 아래 명령어를 사용해서 설치를 진행한다. 1234# 복사git clone https://github.com/denysdovhan/spaceship-prompt.git \"$ZSH_CUSTOM/themes/spaceship-prompt\"# 심볼릭링크(심볼릭 링크는 원본파일을 가리키도록 링크만 시켜둔 것 - 윈도우의 바로가기)ln -s \"$ZSH_CUSTOM/themes/spaceship-prompt/spaceship.zsh-theme\" \"$ZSH_CUSTOM/themes/spaceship.zsh-theme\" .zshrc 파일에서 ZSH_THEME 내용을 변경해준다. 12vi ~/.zshrc또는 open ~/.zshrc 해당 내용을 실행 1source ~/.zshrc 이렇게 테마 적용시 폰트가 깨져서 원하던 모습을 볼수 없을 경우 폰트 설치를 진행하여 준다. Powerline fonts 설치자세한 설치 방법은 Powerline fonts을 참고 하기 바라며 간단한 설치 방법을 공유 합니다. 12345678# 복사git clone https://github.com/powerline/fonts.git --depth=1# 설치cd fonts./install.sh# 지우기cd ..rm -rf fonts 설치가 완료되면 아까와 같이 iTerm2 에서 설정을 cmd + ,를 눌러 환경설정에서 Profiles &gt; Text 에서 Powerline폰트를 선택주면된다.ZSH로 터미널과 조금 더 친해져 보자~!!","link":"/2019/09/27/zsh-setting/"},{"title":"Github SSH key 생성 및 적용하기","text":"많은 Git 서버들은 SSH 공개키로 인증을 합니다. 또한 Github 연결시마다 계정정보를 입력해야 하는 번거로운을 제거해 준다. 이번에 입사한 회사에서도 서버에서 SSH를 사용해서 인증하는 시스템을 가지고 있어서 이 기회에 세팅을하면서 적용방법을 정리해 보았다. SSH 공개키 생성일단 공개키를 사용하려면 공개키를 만들어야 한다. 그 전에 공개키가 있는지 확인이 필요하다. 기본적으로 사용자의 SSH키들은 사용자의 ~/.ssh 디텍토리에 저장한다. 디텍토리의 파일을 살펴서 공개키가 있는지 확인 할 수 있다. 12cd ~/.sshls 보통 id_dsa나 id_rsa라고 되어 있다. 그 중 .pub 파일이 공개키이고 다른 파일은 개인키 입니다.이 파일이 없거나 .ssh 디텍토리가 없으면 ssh-keygen 프로그램으로 키를 생성하여 준다. 터미널 실행하여 다음 명령어를 실행1ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 적은 이메일을 레이블로 사용해서 새 SSH 키를 작성한다는 메세지가 출력됩니다.(아래와 같은 메세지가 나온다면 성공입니다.) 1&gt; Generating public/private rsa key pair. SSH Key 저장위치 설정“키를 저정할 파일을 입력하십시오” 라는 프로프트가 표시되면 Enter를 누르십시오.(기본위치로 지정) 1&gt; Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] SSH Key 비밀번호 설정비밀번호 없이 설정할경우 엔터 두번을 눌러주면된다. 12&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]&gt; Enter same passphrase again: [Type passphrase again] SSH Key 등록생성한 SSH Key를 등록해 봅시다 터미널을 실행하여 아래 명령어를 실행하여 백그라운드에서 ssh-agent를 시작12eval \"$(ssh-agent -s)\"&gt; Agent pid 59566 ssh의 config 파일에 아래 text를 입력1vi ~/.ssh/config Host * AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_rsa 아래 명령어를 입력하여 SSH Key 값을 ssh-agent에 추가1ssh-add -K ~/.ssh/id_rsa SSH Key를 Github 계정에 추가Github 로그인후 우측상단 메뉴에서 Setting을 클릭 좌측의 Personal settings 메뉴 중에 SSH and GPG keys 클릭 New SSH Key를 눌러서 Title과 Key를 입력후 Add SSH Key 버튼을 눌러준다. Key 에는 아래명령어를 사용해서 .pub 의 공개키를 입력해 준다. 1cat ~/.ssh/id_rsa.pub id_rsa.pub 예시ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@agadorlaptop.local Github SSH key 생성 및 적용하기를 해보았다. Github 연결시 계정정보를 입력해야 하는 번거로움에서 해방돠었다.","link":"/2019/10/18/ssh-setting/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 14. 비동기적 프로그래밍","text":"사용자의 행동은 전적으로 비동기적이다. 사용자가 언제 클릭할지, 터치할지, 또는 타이핑 할지 프로그래머는 전혀 알수 없기 때문이다. 하지만 비동기적 실행이 사용자입력 하나 때문에 필요한 것은 아니다. 자바스크립트 애플리케이션은 단일 스레드에서 동작한다.즉 자바스크립트는 한 번에 한가지 일만 할 수 있다. 이러한 자바스크립트의 본질 때문에 비동기적 프로그램밍이 필요하다. 자바스크립트에는 매우 일찍부터 비동기적 실행 메커니즘이 존재 했지만, 자바스크립트의 인기가 높아지고 소프트웨어가 복잡해짐에 따라 비동기적 프로그래밍에 필요한 장치들이 추가 되었다. 자바스크립트의 비동기적 프로그래밍에는 뚜렷이 구분되는 세가지 패러다임이 있습니다.처음에는 콜백 그 뒤로 프라미스 마지막은 제너레이터 입니다. 제너레이터 자체는 비동기적 프로그래밍을 전혀 지원하지 않는다.제너레이터를 비동기적으로 사용하려면 프라미스나 특수한 콜백과 함께 사용해야 한다. 사용자 입력 외에, 비동기적 테크닉을 사용해야 하는 경우는 크게 세가지가 있다. Ajax 호출을 비롯한 네트워크 요청파일을 읽고 쓰는 등의 파일시스템 작업의도적으로 시간 지연을 사용하는 기능(알람 등) 비유어떤 음식점은 당신이 줄을 서서 기다리지 않도록, 당신의 전화번호를 받아서 자리가 나면 전화를 해줍니다. 이런 음심적은 콜백과 비슷하다. 자리가 나면 당신이 알 수 있도록 하는 수단을 당신이 음식점 주인에게 넘겨준다. 음식점은 다른 손님을 대접하면 되고 당신은 다른 일을 하면된다. 어느쪽도 서로를 기다리지 않는다. 다른 음식점은 자리가 났을 때 진동하는 호출기를 당신에게 넘겨준다. 이런 음식점은 프라미스와 비슷하다.자리가 나면 당신이 알수 있도록 하는 수단을 음식점에서 당신에게 넘겨준다. 콜백콜백은 자바스크립트에서 가장 오래된 비동기적 메커니즘이다. 콜백은 간단히 말해 나중에 호출할 함수이다.콜백 함수 자체에는 특별할 것이 전혀 없다. 콜백 함수도 일반적인 자바스크립트 함수일 뿐이다.콜백함수는 일반적으로 다른 함수에 넘기거나 객체의 프로퍼티로 사용한다. 드물게는 배열에 넣어서 쓸 때도 있다.항상 그런건 아니지만 콜백은 보통 익명 함수로 사용한다. 비동기적 실행의 가장 큰 목적이자 중요한 요점은 어떤 것도 차단하지 않는다는 것이다.자바스크립트는 싱글 스레드를 사용하기 때문에 우리가 컴퓨터에 60초동안 대기한 후 코드를 실행하라고 지시한다면 그 실행이 동기적으로 이루어 진다면 프로그램이 멈추고 사용자 입력을 받아들이지도 않고 화면도 업데이트 하지 않을것이다.비동기적 테크닉은 프로그램이 이런 식으로 멈추는 일을 막아준다. 오류 우선 콜백콜백을 사용하면 예외 처리가 어려워지므로 콜백과 관련된 에러를 처리할 방법의 표준이 필요했다.이에 따라 나타난 패턴이 콜백의 첫 번째 매개변수에 에러 객체를 쓰자는 것이었다.에러가 null이나 undefined이면 에러가 없는 것입니다.오류 우선 콜백을 다룰 때 가장 먼저 생각할 것은 에러 매개변수를 체크하고 그에 맞게 반응하는 겁니다. 노드에는 파일 콘텐츠를 읽는다고 할 때 오류 우선 콜백을 사용한다면 다음과 같다. 1234567const fs = require('fs');const fname = 'may_or_may_nor_exist.txt';fs.readFile(fname, function(err, data){ if(err) return console.error(`error reading file $(fname): ${err.message}`); console.log(`$(fname) contents: $(data)`);}) 콜백에서 가장 먼저 하는 일은 err이 참 같은 값인지 확인 하는 것이다.err이 참 같은 값이라면 파일을 읽는 데 문제가 있다는 뜻이므로 콘솔에 오류를 보고하고 즉시 빠져나온다.오류 우선 콜백을 사용할 때는 에러 객체를 체크해야 하고, 빠져 나와야 한다는 사실을 기억해야 한다.콜백을 사용하는 함수는 대개 콜백이 성공적이라고 가정하고 만들어 진다. 그런데 콜백이 실패 했으니 빠져나가지 않으면 오류를 예약하는 것이나 다름 없다.물론, 콜백을 만들 때 실패하는 경우도 염두에 두고 만들었다면 에러를 기록 하기만 하고 계속 진행해도 된다.프라미스를 사용하지 않으면 오류우선 콜백은 노드 개발의 표준이나 다름 없다. 콜백 헬콜백을 사용해 비동기적으로 실행할 수 있긴 하지만 현실적인 단점이 있다. 한 번에 여러가지를 기다려야 한다면 콜백을 관리하기가 상당히 어려워진다. 중괄호에 둘러싸여 끝없이 중청된 삼각형의 코드 블록들을 프로그래머들은 콜백 헬이라고 부른다. 가장 골치 아픈것은 에러 처리이다. 비동기적 코드가 늘어나면 늘어날수록 버그가 없고 관리하기 쉬운 코드를 작성하기는 매우 어렵다 그래서 프라미스가 등장했다. 프라미스프라미스는 콜백의 단점을 해결하려는 시도 속에서 만들어졌다.프라미스가 콜백을 대체하는 것은 아니다. 사실 프라미스에서도 콜백을 사용한다.프라미스는 콜백을 예측 가능한 패턴으로 사용 할수 있게 하며, 프라미스 없이 콜백만 사용했을 때 나타날수 있는 엉뚱한 현상이나 찾기 힘든 버그를 상당수 해결한다. 프라미스의 기본 개념은 프라미스 기반 함수를 호출하면 그 함수는 Promise 인스턴스를 반환한다.프라미스는 성공(resolve)하거나 실패(reject)하거나 단 두가지 뿐이다.프라미스는 성공 혹은 실패 둘 중 하나만 일어난다고 확신할 수 있다.성공한 프라미스가 나중에 실패하는 일 같은건 절대 없다. 또한 성공이든 실패든 단 한번만 일어난다.프라미스가 성공하거나 실패하면 그 프라미스를 결정 됐다고 한다. 프라미스는 객체이므로 어디든 전달할 수 있다는 점도 콜백에 비해 간편한 장점이다.비동기적 처리를 여기서 하지 않고 다른 함수에서 처리하게 하고 싶다면 프라미스를 넘기기만 하면 된다. 프라미스 만들기프라미스는 쉽게 만들 수 있다.resolve와 reject 콜백이 있는 함수로 새 Promise 인스턴스를 만들기만 하면 된다. 프라미스 사용프라미스는 비동기적 작업이 성공 또는 실패하도록 확정하는 매우 안전하고 잘 정의된 매커니즘을 제공하지만 현재는 진행 상황을 전혀 알려주지 않는다. 즉 프라미스는 완료되거나 파기 될뿐 ‘50% 진행됐다’ 라는 개념은 아예 없다.Q 같은 프라미스 라이브러리에는 진행 상황을 보고하는 기능이 있고 나중에 언젠가는 도입될 수도 있지만 지금 당장은 없다. 이벤트이벤트는 자바스크립트에서 자주 사용된다. 이벤트의 개념은 간단하다.이벤트가 일어나면 이벤트 발생을 담당하는 객체에서 이벤트가 일어났음을 알린다,필요한 이벤트는 모두 주시 할수 있다.(콜백을 통해서) 프라미스 체인프라미스에는 체인으로 연결 할수 있다는 장점이 있다. 즉, 프라미스가 완료되면 다른 프라미스를 반환하는 함수를 즉시 호출 할수 있다. 프라미스 체인을 사용하면 모든 단계에서 에러를 캐치할 필요는 없다. 체인 어디에서든 에러가 생기면 체인 전체가 멈추고 catch핸들러가 동작한다. 결정되지 않는 프라미스 방지하기프라미스는 비동기적 코드를 단순화하고 콜백이 두 번 이상 실행되는 문제를 방지한다.하지만 resolve나 reject를 호출하는 걸 잊어서 프라미스가 결정되지 않는 문제까지 자동으로 해결하지는 못한다.에러가 일어나지 않으므로 찾기 매우 어렵다. 복잡한 시스템에서 결정되지 않은 프라미스는 그냥 잊혀질 수 있다. 결정되지 않는 프라미스를 방지하는 한 가지 방법은 타임아웃을 거는 것이다.출분한 시간이 지났는데도 프라미스가 결정되지 않으며 자동으로 실패하게 만들 수 있다. 프라미스에 타임아웃을 거는 함수123456789101112131415161718function addTimeout(fn, timeout){ if(timeout === undefined) timeout = 1000; //타임아웃 기본값 return function(...args){ return new Promise(function(resolve, reject){ const tid = setTimeout(reject, timeout, new Error(\"promise timed out\")); fn(...args) .then(function(...args){ clearTimeout(tid); resolve(...args); }) .catch(function(...args){ clearTimeout(tid); reject(...args) }); }); }} 프라미스를 반환하는 함수를 호출하는 프라미스를 반환하는 함수를 반환하는 함수 ??프라미스에 타임아웃을 걸기 위해서는 함수를 반환하는 함수가 필요하다. 제너레이터제너레이터는 원래 동기적인 성격을 가졌지만 프라미스와 결합하면 비동기 코드를 효율적으로 관리 할 수 있다.비동기 코드에서 가장 어려운 부분은 동기적인 코드에 비해 만들기가 어렵다는 점이다. 프로그램에서 어떤 부분을 동시에 실행할 수 있고 또 어떤 부분은 동시에 실행 할수 없는지 판단하는 것이 중요하다. 제너레이터 실행기와 예외처리제너레이터 실행기를 쓰면 try/catch를 써서 예외 처리를 할수 있다는 것도 중요한 장점이다.콜백이나 프라미스를 사용하면 예외 처리가 쉽지 않다. 콜백에서 일으킨 예외는 그 콜백 밖에서 캐치할 수 없다.제너레이터 실행기는 비동기적으로 실행하면서도 동기적인 동작 방식을 유지하므로 try/catch문과 함께 쓸수 있다. 요약 자바스크립트의 비동기적 실행은 콜백을 통해 이루어진다.프라미스를 콜백 대신 사용할수 잇는건 아니다. 프라미스 역시 콜백을 사용한다.프라미스는 콜백이 여러번 호출되는 문제를 해결했다.콜백을 여러번 호출해야 한다면 이벤트와 결합하는 방법을 생각 할수 있다.(프라미스도 함께 쓸 수 있다.)프라미스는 반드시 결정된다는 보장은 없다. 프라미스의 타임아웃을 걸어 이문제를 해결 할수 있다.프라미스는 체인으로 연결할 수 있다.프라미스와 제너레이터 실행기를 결합하면 비동기적 실행의 장점을 그대로 유지하면서도 동기적인 사고방식으로 문제를 해결할 수 있다,제너레이터를 써서 동기적인 사고방식으로 문제를 해결할 때는 프로그래의 어느 부분을 동시에 실행 할수 있는지 잘 살펴야 한다. 동시에 실행 할수 있는 부분은 Promise.all을 써서 실행해라제너레이터 실행기를 직점 만드는 고생을 하지말고 co나 Koa를 써라노드 스타일 콜백을 프라미스로 바꾸는 고생도 필요없다 Q를 써라제너레이터 실행기를 쓰면 예외 처리도 익숙한 방식으로 할 수 있다.","link":"/2019/08/03/Learning-JavaScript-chapter14/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 6. 함수","text":"함수(function)는 하나의 단위로 실행되는 문의 집합, 일종의 부속프로그램으로 볼 수도 있다.함수를 호출 할 때는 이름 다음에 괄호를 쓴다. 반환값 함수 바디 안에 return키워드를 사용하면 함수를 즉시 종료하고 값을 반환한다.return을 명시적으로 호출하지 안으면 반환값은 undefined가 됩니다.함수는 어떤 타입의 값이라도 반환 할 수 있습니다. 호출과 참조자바스크립트에서는 함수도 객체 따라서 다른개체와 마찬가지로 넘기거나 할당 할 수 있다. 함수 식별자 뒤에 괄호를 쓰면 자바스크립트는 함수를 호출한다. 그리고 함수를 호출한 표현식은 반환값이 된다. 괄호를 쓰지않으면 다른 값과 마찬가지로 함수를 참조하는 것이며, 그 함수 는 실행되지 않는다. 함수를 변수에 할당하면 다른 이름으로 함수를 호출 할 수 있다.함수를 객체 프로퍼티에 할당 할 수도 있다. 배열 요소로 할당 할 수도 있다. 함수와 매개변수함수를 호출하면서 정보를 전달 할때는 함수 매겨변수를 이용한다.매개변수는 함수가 호출되기 전에는 존재하지 않는다는 점을 제외하면 일반적인 변수나 마찬가지이다. 123function avg(a,b){ return(a+b)/2} 이 함수 선언에서 a와b를 정해진 매개변수를 한 개 전달하든 같은 함수를 호출 하는 것이다.다시 말해 어떤 함수를 그 함수에서 정해진 매개변수 숫자와 관계없이 몇 개의 매개 변수를 전달해도 됩니다.정해진 매개변수에 값을 제공하지 않으면 암묵적을 undefined가 할당됩니다. 매개변수 해체매개변수도 해체 할 수 있다. 해체 할당과 마찬가지로 프로퍼티 이름은 반드시 유효한 식별자여야 하고,들어오는 객체에 해당 프로퍼티가 없는 변수는 undefined를 할당받습니다.확산 연산자를 써서 남는 매개변수를 이용 할 수 있습니다.함수를 선언 할 때 확산 연산자는 반드시 마지막 매개변수여야 합니다.확산 연산자 뒤에 다른 매개변수가 있으면 값 중 어디까지를 확산 매개변수에 할당 해야 하는지 판단 할 수 없어 에러를 일으킨다. 매개변수 기본값ES6에서 추가, 일반적으로 매개변수에 값을 제공하지 않으면 undefined가 값으로 할당됩니다. 12345678function f(a,b= \"default\", c=3){ return `${a} - ${b} - ${c}`;}f(5,6,7); // \"5 - 6 - 7\"f(5,6); // \"5 - 6 - 3\"f(5); // \"5 -default -3\"f(); // \"undefined - default - 3\" 객체의 프로퍼티인 함수객체의 프로퍼티인 함수를 메서드라고 불러서 일반적인 함수와 구별합니다.ES6에서는 간편하게 메서드를 추가 할 수 있는 문법이 생겼다. 12345678910const o = { name: 'Wallace', // 원시 값 프로퍼티 bark: function() { return 'Woof!'; } // 함수 프로퍼티(메서드)}// ES6const o = { name: 'Wallace', // 원시 값 프로퍼티 bark() { return 'Woof!'; } // 함수 프로퍼티(메서드)} this키워드함수 바디 안에는 특별한 읽기 전용값이 this가 있다.일반적으로 this는 객체의 프로퍼티인 함수에서 의미가 있다.this는 함수를 어떻게 선언했느냐가 아니라 어떻게 호촐했느냐에 따라 달라진다는 것을 이해해야 한다.중첩된 함수 안에서 this를 사용하려다 보면 혼랑을 야기한다. 이러한 문제해결을 위해 다른 변수에 this를 할당해서 사용한다.ES6에서는 화살표함수를 써도 이 문제를 해결 할 수 있다. 함수 표현식과 익명함수익명 함수에서는 함수에 식별자가 주어지지 않습니다.함수 표현식은 함수를 선언하는 한 가지 방법일 뿐이며, 그 함수가 익명이 될 수도 있을 뿐이다.함수 표현식은 식별자에 할당 할 수도 있고 즉시 호출 할 수도 있다. 함수 표현식은 함수 이름을 생략 할 수 있다는 점을 제외하면 함수 선언과 문법적으로 완전히 같다. 함수 표현식12345678// 기명함수const f = function name(){ // ...}// 익명함수const f = function(){ // ...} 일반적인 함수 선언과 마찬가지로 f()로 함수를 호출 할 수 있다.차이점은 먼저 함수 표현식으로 익명함수를 만들고 그 함수를 변수에 할당했다는 것이다. 익명함수는 어디든 쓸 수 있다.다른 함수나 메서드의 매개변수로 넘길 수도 있고, 객체의 함수 프로퍼티가 될 수도 있다.-재귀함수 컨택스트의 차이함수선언이 표현식으로 사용됐다면 그건 함수 표현식, 표현식으로 사용되지 않았다면 함수 선언 화살표 표기법funtion이라는 단어와 중괄호 숫자를 줄이려고 고안된 단축문법 화살표 함수의 세가지 단축문법 function을 생략해도 됩니다. 함수에 매개변수가 단 하나 뿐이라면 괄호()도 생략 할 수 있습니다. 함수 바디가 표현식 하나라면 중괄호와 return문도 생략 할 수 있습니다. 화살표 함수는 항상 익명입니다. 변수에 할당 할수는 있지만 이름 붙은 함수를 만들 수는 없다. 1234567891011const f1 = function() { return \"hello!\"; }// 또는const f1 = () =&gt; \"hello!\";const f2 = function(name) { return `Hello, ${name}!`; }// 또는const f2 = name =&gt; `Hello, $(name)!`;const f3 = function(a,b) { return a + b; }// 또는const f3 = (a,b) =&gt; a + b; 화살표표기법은 단순한 단축문법에 그치는 것이 아니라 함수형 프로그래밍을 자바스크립트에 도입하는 중요한 열쇠이다.또 다른 차이는 객체 생성자로 사용 할 수 없고, arguments 변수도 사용 할 수 없다. call, apply, bind자바스크립트에서는 일반적인 방법 외에도, 함수를 어디서, 어떻게 호출 했느냐와 상관없이this가 무엇인지 지정 할 수 있습니다.call 메서드는 모든 함수에서 사용 할 수 있으며, this를 특정 값으로 지정할 수 있습니다. 1234567891011const bruce = { name: \"Bruce\" };const madeline = { name : \"Madeline\" };// 이 함수는 어떤 객체에도 연결되지 않았지만 this를 사용합니다.function greet(){ return `Hello, I'm ${this.name}!`;}greet(); // \"Hello, I'm undefined!\" - this는 어디에도 묶이지 않았습니다.greet.call(bruce); // \"Hello, I'm Bruce!\" - this는 bruce 입니다.greet.call(madeline); // \"Hello, I'm Madeline!\" - this는 madeline 입니다. 함수를 호출하면서 call를 사용하고 this로 사용할 객체를 넘기면 해당 함수가 주어진 객체의 메서드인 것처럼 사용 할 수 있다.call의 첫번째 매개변수는 this로 사용할 값이고, 매개변수가 더 있으면 그 매개변수는 호출하는 함수로 전달된다. apply는 함수 매개변수처리 방법만 제외하고 call과 같습니다.call은 함수와 마찬가지로 매개변수를 직접 받지만 apply는 매개변수를 배열로 받습니다. apply는 배열 요소를 함수 매개변수로 사용해야 할 때 유용하다.ES6의 확장연산자(…)를 사용해도 apply와 같은 결과를 얻을 수 있다. bind를 사용하면 함수의 함수의 this값을 영구히 바꿀 수 있다. bind에 매개변수를 넘기면 항상 그 매개변수를 받으면서 호출되는 새 함수를 만드는 효과가 있다.","link":"/2019/07/05/Learning-JavaScript-chapter6/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 5. 표현식과 연산자","text":"이번 챕터에서는 표현식과 연산자에 대해 알아보는 챕터였다. 실습보다는 이론적인 부분들이 많았다. 표현식값으로 평가될 수 있는 문 즉 결과가 값인 문과, 표현식이 아닌 문의 차이를 이해한다.표현식이 아닌 문은 일종의 지시라고 생각 할 수있고, 표현식은 무언가를 요청하는 것이라고 생각 할 수 있다. 표현식은 값이 된다. 그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있다. 그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있다. 표현식이 아닌 문은 이런 식의 결합을 할 수 있다. 표현식은 값이 되므로 할당에 쓸 수 있다. 즉 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다. 연산자표현식이 값이 되는 것이라면 연산자는 값을 만드는 행동이라는 뜻이다.연산자는 하나 이상의 피연산자가 있어야 결과를 낼 수 있다. 피연산자를 매개변수라 부르는 경우도 있다. 산술 연산자 연산자 설명 예제 + 덧셈(문자열 병합에도 쓰임) 3 + 2 5 - 뺄셈 3 - 2 1 / 나눗셈 3/2 1.5 * 곱셈 3*2 6 % 나머지 3%2 1 - 단항 부정 -x x의 부호를 바꿉니다. x가 5이면 -x는 -5입니다. + 단항 플러스 +x x가 숫자가 아니면 숫자로 변환을 시도합니다. ++ 전위 증가 ++x x에 1을 더한 다음 평가합니다. ++ 후위 증가 x++ x를 평가한 다음 1을 더합니다. – 전위 감소 –x x에서 1을 뺀 다름 평가합니다. – 후위 감소 x– x의 값을 평가한 다음 1을 뺍니다. 뺄셈과 단항 부정은 같은 -기호를 사용단항 부정이 먼저 이루어지고 그 다음에 뺄셈을 한다.나머지 연산자는 나눗셈을 한 나머지를 반환 증가연산자(++),감소연산자(–) 할당 연산자와 덧셈연산자,뺄셈 연산자를 하나로 합친거나 다름없다.전위와 후위의 차이의 이해가 필요하다. 전위 연산자는 먼저 변수의 값을 바꾼 다음에 평가, 후위 연산자는 값을 바꾸기 전에 평가한다. 연산자 우선 순위현재 자바스크립트에는 56개의 연산자가 있고, 우선순위를 기준으로 19개의 그룹으로 묶을 수 있다.우선순위가 같은 연산자들은 오른쪽에서 왼쪽으로 또는 왼쪽에서 오른쪽으로 평가한다. 비교연산자비교연산자는 이름처럼 두 개의 값을 비교한다.일치함(===), 동등함(==), 관계연산자 이렇게 세가지 타입으로 나뉜다. 두 값이 같은 개체를 가리키거나, 같은 타입이고 값(원시타입)도 같다면 이 값을 일치한다고 한다.두 값이 같은 개체를 가리키거나, 같은 값을 갖도록 변환할 수 있다면 두 값을 동등하다고 한다.관계연산자에는 작다(&lt;), 작거나 같다(&lt;=), 크다(&gt;), 크거나 같다(&gt;=) 네가지가 있다. 숫자비교 특별한 숫자형 값 NAN은 그 자신을 포함하여 무엇과도 같지 않다.숫자가 NAN인지 알아보려면 내장된 isNAN 함수를 사용해야한다.자바스크립트의 숫자는 모두 더블 형식이다. 문자열 병합 +연산자는 덧셈과 문자열 병합에 모두 사용자바스크립트는 피연산자의 타입을 보고 덧셈을 할지 문자열 병합을 할지 판단덧셈과 문자열병합은 모두 왼쪽에서 오른쪽으로 평가합니다.평가후 피연산자 중 하나라도 문자열이면 문자열 병합을 수행두 값이 모두 숫자형이면 덧셈을 수행 논리연산자불리언 값만 다룰 수 있다. - true, false참 같은 값과 거짓 같은 값 - truthy, falsy 자바스크립트의 거짓 같은 값undefinednullfalse0 NAN‘’(빈문자열) 위의 6가지 외에는 모두 참 같은 값이다. 참 같은 값 몇 가지 예시모든 객체, valueOf() 메서드를 호출했을때 false를 반환하는 객체배열,빈 배열 - 공백만 있는 문자열문자열 “false” AND, OR, NOTAND(&amp;&amp;) 연산의 진위표 x y x &amp;&amp; y false false false false true false true false flase true true true AND 연산은 피연산자가 모두 true일때만 true OR(||) 연산의 진위표 x y x II y false false false false true true true false true true true true OR 연산은 피연산자가 모두 false일때만 false NOT(!) 연산의 진위표 x !x false true true false NOT연산은 피연산자를 반대로 바꿈 단축평가x &amp;&amp; y 에서 x가 거짓 같은 값이면 y의 값을 평가할 필요없이 false이다.x || y 에서 x가 참 같은 갑이면 y를 평가할 필요없이 true이다.이러한 방식으로 동작하며 이를 단축평가 라고 한다. 단축평가가 중요한 이유는 두번째 피연산자에 부수효과가 있다 하더라고단축평가를 거치면 그 효과는 일어나지 않기 때문이다. 피연산자가 불리언이 아닐때 논리 연산자가 동작하는 방법불리언 피연산자를 사용하면 논리 연산자는 항상 불리언을 반환한다.피연산자가 불리언이 아니라면 결과를 결정한 값이 반환된다. 불리언이 아닌 피연산자에 대한 AND(&amp;&amp;)의 진위표 x y x &amp;&amp; y 거짓 같은 값 거짓 같은 값 x (거짓 같은 값) 거짓 같은 값 참 같은 값 x (거짓 같은 값) 참 같은 값 거짓 같은 값 y (거짓 같은 값) 참 같은 값 참 같은 값 y (참 같은 값) 불리언이 아닌 피연산자에 대한 AND(&amp;&amp;)의 진위표 x y x II y 거짓 같은 값 거짓 같은 값 y (거짓 같은 값) 거짓 같은 값 참 같은 값 y (참 같은 값) 참 같은 값 거짓 같은 값 x (참 같은 값) 참 같은 값 참 같은 값 x (참 같은 값) 결과를 불리언으로 변환하면 불리언 값을 제공했을 때의 진위표와 같은 결과가 된다. 조건연산자자바스크립트의 유일한 3항 연산자피연산자 세개를 받습니다. 1조건식 ? 조건식이 ture일때 반환할 값 : 조건식이 false일때 반환할 값 쉼표연산자쉼표연산자는 표현식을 결합하여 두 표현식을 평가하 후, 두 번째 표현식의 결과를 반환한다.표현식을 하나 이상 실행해야 하지만 값으로 필요 것은 마지막 표현식의 결과 뿐일 때 쉼표 연산자를 유용하게 쓸 수 있다. 그룹연산자그룹연산자()에는 아무 효과도 없지만 연산자 우선 순위를 높이거나 명확히 표현하는데 쓸 수 있다.연산 순서만 바꿀 뿐 다른 부작용은 없다. 비트연산자typeof연산자typeof연산자는 피연산자의 타입을 나타내는 문자열을 반환한다.자바스크립트의 일곱가지 데이터 타입을 정확히 나타내지 못한다. (null을 “object”로 판단) void연산자피연산자를 평가한 후 undefined를 반환한다. 할당연산자변수에 값을 할당한다.등호에 왼쪽에 잇는 것은 반드시 변수나 프로퍼티, 배열 요소 중 하나여야 한다.(상수에 값을 할당 하는 것은 엄밀히 말하면 선언이다.)즉 표현식의 왼쪽에 있는 것은 반드시 값을 저장 할 수 있는 것이어야 한다. 간편할당연산자연산과 할당을 한꺼번에 수행한다. 연산자 동등한 표현 x += y x = x + y x -= y x = x - y x *= y x = x * y x /= y x = x / y x %= y x = x % y x &lt;&lt;= y x = x &lt;&lt; y x &gt;&gt;= y x = x &gt;&gt; y x &gt;&gt;&gt;= y x = x &gt;&gt;&gt; y x &amp;= y x = x &amp; y x I= y x = x I y x ^= y x = x ^ y 해체할당ES6에 새로 도입객체나 배열을 변수로 해체 할 수 있다. 해체할당123456789//객체선언cosnt obj = { b:2, c:3, d:4 }//해체할당const {a,b,c} = obj;a; //undefined : obj에는 \"a\" 프로퍼티가 없습니다.b; // 2c; // 3d; // ReferenceError: \"d\"는 정의되지 않았습니다. 객체를 해체할 때는 반드시 변수 이름과 객체의 프로퍼티 이름이 일치해야 한다. 프로퍼티 이름이 유효한 식별자인 프로퍼티만 해체 후 할당 된다. 객체 해체는 할당만으로 이뤄질 수도 있지만 그렇게 하려면 반드시 괄호를 써야한다. 배열을 해체할 때는 배열 요소에 대응할 변수 이름을 마음대로 쓸 수 있으며 이들은 배열 순서대로 대응한다. 확산 연산자를 사용하면 남은 요소를 새 배열에 할당 할 수 있다. - 배열 해체는 꼭 배열에만 사용 할수 있는 것은 아니다, 이터러블 객체에는 모두 사용 할 수있다.","link":"/2019/07/05/Learning-JavaScript-chapter5/"},{"title":"러닝 자바스크립트 스터디 자료 - CHAPTER 8. 배열과 배열처리","text":"배열의 기초 배열은 객체와 달리 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다. 자바스크립트의 배열은 비균질적입니다. 즉 한 배열의 요소가 모두 같은 데이터 타입일 필요는 없습니다. 배열은 다른 배열이나 객체도 포함 할 수 있습니다. 배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근 할 때도 대괄호를 사용합니다. 모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다. 배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하며 배열을 자동으로 그 인덱스에 맞게 늘어나며, 빈자리는 undefined로 채워집니다. Array 생성자를 써서 배열을 만들수도 있습니다. 배열요소 조작배열 메서드 중 일부는 ‘배열자체를 수정’하며, 다른 일부는 ‘새 배열’을 반환합니다.예) push는 배열자체를 수정하며, concat은 새 배열을 반환합니다. push, pop, shift, unshift 메서드배열의 처음은 첫 번째 요소, 즉 인덱스가 0인 요소배열의 끝은 인덱스가 가장 큰 요소, 즉 배열이 arr이라면 arr.length -1 인 요소push 와 pop은 각각 배열의 끝에 요소를 추가하거나 제거합니다. (수정)shift와 unshift는 각각 배열의 처음에 요소를 제거하거나 추가합니다. (수정) concat 메서드concat메서드는 배열의 끝에 여러요소를 추가한 사본을 반환concat은 제공받은 배열을 한 번만 분해합니다.배열안에 있는 배열을 다시 분해 하지는 않습니다. - 이해가 잘 안감 slice 메서드배열의 일부만을 가져올때 사용합니다.slice 메서드는 매개변수 두 개를 받습니다.첫 번째 매개변수는 어디서부터 가져올지를 두 번째 매개변수는 어디까지 가져올지를(바로 앞 인덱스까지 가져옵니다.) 지정합니다.두 번째 매개변수를 생략하면 배열의 마지막 까지 반환합니다.음수인덱스를 사용하면 배열의 끝에서부터 요소를 셉니다. 123456const arr = [1, 2, 3, 4, 5];arr.slice(3); // [4,5] arr은 바뀌지 않았습니다.arr.slice(2,4); // [3,4] arr은 바뀌지 않았습니다.arr.slice(-2); // [4,5] arr은 바뀌지 않았습니다.arr.slice(1,-2); // [2,4] arr은 바뀌지 않았습니다.arr.slice(-2,-1); // [4] arr은 바뀌지 않았습니다. splice 메서드배열을 자유롭게 수정할 수 있습니다.첫 번째 매개변수는 수정을 시작할 인덱스 이고, 두 번째 매개변수는 제거할 요소 숫자입니다.아무요소도 제거하지 않을 때는 0을 넘깁니다. 나머지 매개변수는 배열에 추가될 요소입니다. 12345const arr = [1, 5, 7];arr.splice(1,0,2,3,4); // [] arr은 이제 [1,2,3,4,5,7]입니다.arr.splice(5,0,6); // [] arr은 이제 [1,2,3,4,5,6,7]입니다.arr.splice(1,2); // [2,3] arr은 이제 [1,4,5,6,7]입니다.arr.splice(2,1,'a','b') // [5] arr은 이제 [1,4,'a','b',6,7]입니다. copyWithin 메서드ES6에서 도입, 배열요소를 복사해서 다른 위치에 붙여넣고, 기존 요소를 덮어 씁니다.첫 번째 매개변수는 복사한 요소를 붙여넣을 위치이고, 두 번째 매개변수는 복사를 시작할 위치, 세 번째 매개변수는 복사를 끝낼 위치입니다.(생략가능)음수를 사용하면 배열의 끝에서부터 셉니다. 1234const arr = [1,2,3,4];arr.copyWithin(1, 2); // arr은 이제 [1,3,4,4]입니다.arr.copyWithin(2, 0, 2); // arr은 이제 [1,3,1,3]입니다.arr.copyWithin(0, -3, -1); // arr은 이제 [3,1,1,3]입니다. fill 메서드ES6에서 도입, 정해진 값으로 배열을 채웁니다.크기를 지정해서 배열을 생성하는 Array 생성자와 잘 어울립니다.배열의 일부만 채우려 할때는 시작인덱스와 끝인덱스를 지정하면 된다.음수인덱스도 사용 할 수 있다. 123456const arr = new Array(5).fill(1); // arr이 [1,1,1,1,1]로 초기화 뙵니다.arr.fill(\"a\"); // arr은 이제 [\"a\",\"a\",\"a\",\"a\",\"a\"]입니다.arr.fill(\"b\",1); // arr은 이제 [\"a\",\"b\",\"b\",\"b\",\"b\"]입니다.arr.fill(\"c\",2,4); // arr은 이제 [\"a\",\"b\",\"c\",\"c\",\"b\"]입니다.arr.fill(5.5, -4); // arr은 이제 [\"a\",5.5,5.5,5.5,5.5]입니다.arr.fill(0,-3,-1); // arr은 이제 [\"a\",5.5,0,0,5.5]입니다. reverse 메서드배열의 요소의 순서를 반대로 바꿉니다. sort 메서드배열 요소의 순서를 정렬합니다. sort는 정렬 함수를 받을 수 있습니다.일반적으로는 객체가 들어있는 배열을 정렬 할 수 없지만 정렬 함수를 사용하면 가능하다. 배열검색indexOf,lastIndexOf 메서드,indecOf 메서드는 찾고자 하는 것과 정확히 일치(===)하는 첫 번째 요소의 인덱스를 반환lastIndexOf 메서드는 배열의 끝에서부터 검색배열의 일부분만 검색하려면 시작 인덱스를 지정할 수 있다.indexOf 와 lastIndexOf는 일치하는 것을 찾지 못하면 -1 을 반환한다. findindex 메서드findindex는 메서드는 보조함수를 써서 검색조건을 지정할 수 있다.indexOf와 lastindexOf 처럼 일치하는 것을 찾지 못하면 -1을 반환검색 시작할 인덱스를 지정 할 수 없고, 뒤에서 부터 찾을 수도 없다. find 메서드조건에 맞는 요소의 인덱스가 아니라 요소 자체를 검색할 때 사용검색 조건을 함수로 전달 할 수 있다.조건에 맞는 요소가 없을 때는 undefined를 반환 some 메서드조건에 맞는 요소를 찾으면 즉시 검색을 멈추고 true를 반환조건에 맞는 요소를 찾지 못하면 false를 반환 every 메서드배열의 모든 요소가 조건에 맞아야 true를 반환 그렇지 않다면 false를 반환조건에 맞지 않는 요소를 찾아야만 검색을 멈추고 false를 반환조건에 맞지 않는 요소를 찾지 못하면 배열 전체를 검색 map 과 filter 메서드map은 배열 요소를 변형합니다.map 과 filter 는 사본을 반환하며 원래 배열을 바뀌지 않습니다.콜백함수는 각 요소에서 호출 될 때 요소 자체와 요소인덱스, 배열전체를 매개변수로 받습니다. fliter 는 필요한 것들만 남깁니다.map과 마찬가지로 사본을 반환하며 새 배열에는 필요한 요소만 남습니다.어떤 요소를 남길지 함수로 넘깁니다. reduce 메서드map이 배열의 각 요소를 변형한다면 reduce는 배열 자체를 변형합니다.reduce는 map과 filter를 비롯해 앞의 설명한 배열 메서드의 동작 대부분을 대신 할 수 있다.reduce가 받는 첫번째 매개변수는 배열이 줄어드는 대상인 어큐뮬레이터 입니다.두 번째 매개변수부터는 여태까지 설명한 콜백의 순서대로 현재배열요소, 현재인덱스, 배열 자체 입니다. reduce는 초기값도 옵션으로 받을 수 있습니다. 12const arr = [5,7,2,4];const sum = arr.reduce((a,x =&gt; a += x,0)); reduce의 콜백 함수는 매개변수로 누적값 a와 현재 배열요소 x를 받았습니다. 이 예제에서 누적값은 0으로 시작합니다. 진행순서 첫 번째 배열 요소 5에서 익명 함수를 호출합니다. a의 초깃값은 0이고 x의 값은 5입니다. 함수는 a와 x(5)의 합을 반환합니다. 이 값은 다음 단계에서 a의 값이 됩니다. 두 번째 배열 요소 7에서 함수를 호출합니다. a의 초깃값은 이전 단계에서 전달한 5이고, x의 값은 7입니다. 함수는 a와 x의 합 12를 반환합니다. 이 값은 다음 단계에서 a의 값이 됩니다. 세 번째 배열 요소 2에서 함수를 호출합니다. 이 단계에서 a는 12이고 x는 2 입니다. 함수는 a와 x의 합인 14를 반환합니다. 네 번째이자 마지막 배열 요소인 4에서 함수를 호출합니다 a는 14이고 x는 4입니다. 함수는 a와 x의 합인 18을 반환하며 이 값은 reduce의 값이고 sum에 할당 되는 값입니다.누적값이 어떻게 변하는 지 생각하는 습관을 기르는게 좋다. 누적값이 undefined로 시작된다면 어떻게 될까? 누적갑이 제공되지 않으면 reduce는 첫 번째 배열요소를 초기값으로 보고 두 번째 요소에서부터 함수를 호출합니다.배열의 첫 번재 요소가 그대로 초깃값이 될 수 있을때는 초깃값을 생략해도 됩니다. reduce는 보통 숫자나 문자열 같은 원시값을 누적값으로 사용하지만 객체 또한 누적 값이 될 수 있고 이를 통해 아주 다양하게 활용할수 있다.","link":"/2019/07/13/Learning-JavaScript-chapter8/"},{"title":"1. 프로그레시브 프레임워크 Vue.js - part 2","text":"Vue.js 의 특징Vue.js는 그 자체로는 뷰만을 다루는 단순한 라이브러리다. Vue.js 본체 뿐만 아니라 관련 라이브러리도 Vue.js 공식 프로젝트의 일부로서 개발 및 관리 된다. 이 때문에 몇가지 라이브러리를 조합하면 마치 종합적인 프레임워크처럼 사용 할 수 있다. 낮은 학습 비용Vue.js 가 제공하는 API는 매운 단순하다. UI를 구성하는 데는 HTML을 기반으로 하는 평범한 템플릿을 사용한다. HTML이나 자바스크립트에 이미 익숙하면 Vue.js 에 대해 특별히 더 배우지 않고서도 라이브러리를 사용할 수 있다. 기본적인 사용만 한다면 빌드 도구나 패키징, EC2015 이후 문법에 대한 지식이 없어도 바로 동작하는 코드를 작성할 수 있다. Vue.js 는 앞서 언급한 모던 웹 프런트 엔드 개발의 어려움을 잘 극복했다. HTML5 이후 고도화된 개발 스타일에 부응하면서도 개발 환경 구축이 쉬워서 개발을 바로 시작할 수 있으며 자바스크립트에 대한 사전지식과 라이브러리 고유의 문법을 학습하지 않아도 라이브러리를 사용할 수 있다. 컴포넌트 지향을 통한 UI 구조화Vue.js 는 구조화해 컴포넌트로 재사용할 수 있다. UI 구성 요소를 컴포넌트로 만들면 시스템 전체를 컴포넌트의 집합 형태로 개발 할 수 있다. 개발에 컴포넌트를 적용하면 컴포넌트 분리에서 오는 유지보수성 개선 및 컴포넌트 재사용 등 여러 장점이 있다. 리액티브 데이터 바인딩Vue.js 는 DOM요소와 리액티브 데이터 바인딩을 통해 자바스크립트 데이터를 연결해 준다. 리액티브 데이터 바인딩이란 HTML 템플릿 안에서 대상 DOM 요소에 바인딩 을 지정해 Vue.js 가 해당 데이터의 변화를 감지할 때마다 바인딩된 DOM 요소에 표시되는 내용도 함께 업데이트하는 것을 말한다. 값은 자바스크립트에서 DOM요소로 일방적으로 전달된다. 이것을 단방향 바인딩이라고 한다. 자바스크립트쪽에서 위치한 데이터 값이 변경되면 변경된 값이 웹 페이지에도 자동으로 반영되는 기능이다. input 요소등 사용자의 입력을 받는 DOM요소는 요소에서 받아온 데이터와 자바스크립트 데이터를 서로동기화하는 바인딩을 지정한다. 이런 경우 자바스크립트의 데이터 값이 변경될때마다 DOM요소의 표시 내용이 수정되며, 사용자의 입력이 감지될때마다 자바스크립트 데이터가 수정된다. 이런 방법으로 자바스크립트 데이터와 DOM요소 데이터의 동기화 상태를 유지한다. 이 방법은 자바스크립트와 DOM요소가 서로 최신 데이터를 주고받으므로 양방향 바인딩이라고 한다. 바인딩을 이용함으로써 귀찮은 표시 내용 업데이트 처리와 DOM 요소와 자바스크립트 간 데이터 동기화 상태 유지로부터 해당됐으며 데이터 중심 웹 애플리케이션 설계 및 구현이 가능해졌다. Vue.js의 설계사상Vue.js는 사용성 면에서도 뛰어난 라이브러리지만, 성능적인 측면을 비롯해 다른 장점도 많은 라이브러리다. 그러나 이와 비슷한 장점이 많은 라이브러리도 있다. Vue.js 가 이런 다른 라이브러리와 분명이 차별화 되는 점이 있다. 바로 밑바탕이 되는 설계사상이다. Vue.js의 설계 밑 바탕에는 프로그래시브 프레임워크(Progressive framework) 라는 아이디어가 깔려있다.‘프레임워크는 어떤 경우든지 규모와 상관없이 단계적으로 유연하게 사용할 수 있어야 한다.’ 라고 Vue.js를 만든 에반유가 처음 주창했다. 프레임워크의 복잡성웹 프런트 엔트 분야에는 React와 Angular 등 라이브러리와 프레임워크가 여러 가지 있다. 프레임워크는 애플리케이션 개발의 복잡성을 해소해주는 도구다. 그러나 애플리케이션과 마찬가지로 프레임워크에도 프레임워크 자체의 복잡성이 있다. 프레임워크라는 도구를 사용하려면 도구 자체의 복잡성에서 오는 비용과 애플리케이션 개발의 복잡성에서 오는 비용이 균형을 이루도록 적합한 프레임워크를 선택하는 것이 중요하다. 요구 사항의 변화를 수용할수 있는 프레임워크사이트 및 애플리케이션의 요규사항은 끊임없이 변화한다. 프레임워크도 이렇게 변화하는 요구사항에 맞춰 가치를 제공하려면 그만큼 유연하지 않으면 안 된다. 애플리케이션이 최초 완성되고 나면 변화하는 요구사항에 대응하기 위해 애플리케이션의 규모가 지족해서 커지게 마련이다. 대부분 애플리케이션 개발을 지원하는 라이브러리나 도구를 추가로 도입해 새로운 비즈니스 요구사항을 만족시키게 된다. 그러나 이렇게 새로운 요소를 덧붙이는 방법은 생각대로 되지 않는 경우가 많다. 웹 프런트엔드 생태계는 최근 끊임없이 변화하고 있기 때문에 애플리케이션에 도입한 프레임워크나 개발 환경이 얼마 지나지 않아 시대에 뒤떨어지게 되고 다시 어떤 프레임워크로 갈아타야 하는지조차 알 수 없는 상황에 직면하게 된다. 이런 상황에 대처하려면 요구 사항 변과에 단계적으로 대응해야 한다. 이러한 아이디어를 반영한 것이 바로 프로그래시브 프레임워크다. 프로그래시브 프레임워크는 무제를 해결할 수 있는 적합한 라이브러리를 적시에 도입해 문제를 해결한다. Vue.js는 뷰 계층에 초점을 맞춘 라이브러리다. Vue.js 프로젝트가 제공하는 부가적인 라이브러리와 개발환경 도구를 사용하면 프로그래시브 프레임워크가 된다. 프로그레시브 프레임워크가 제공하는 단계적 영역선언적 렌더링이 영역은 선언적 DOM 렌더링과 관련된 영역이다. HTML 템플릿에 렌더링 대상을 선언적으로 기술해 데이터가 변경될 때마다 DOM을 반응적으로 렌더링하고 사용자 입력 데이터를 동기화 할 수 있다,Vue.js 본체가 제공하는 기능이다. 컴포넌트 시스템UI를 모듈화해 재사용할수 있게 해주는 영역 이 영역 역시 UI 를 컴포넌트로 만들어주는 Vue.js 본체가 제공하는 기능이다. 클라이언트 사이드 라우팅단일 페이지 애플리케이션이 동작하기 위해 필요한 영역이다. 라우팅이란 간단히 말해 애플리케이션의 URL 설계, 지시와 같은 것이다. Vue.js의 공식 라우팅 라이브러리인 Vue Router를 사용하면 기존에 개발한 컴포넌트로 당일 페이지 애플리케이션을 만들 수 있다. 대규모 상태관리컴포넌트 간에 상태를 고유하는 방법을 필요로 하는 영역이다. Vue.js의 공식 데이터플로 아키텍처를 따라 만든 상태관리 라이브러리인 VUEX 를 사용하면 이 영역의 문제를 해결할 수 있다, 기존 컴포넌트를 확장하는 형태로 상태를 중앙에서 관리 할 수 있다. 빌드시스템웹 애플리케이션을 구성하는 컴포넌트 관리, 운영환경배포, 프로젝트 구성등과 관련된 영역이다. Vue.js의 공식 개발지원 도구를 이용해 이 영역의 문제를 해결할 수 있다, 프로젝트의 환경구축, 구성관리에 수고를 들이는 대신 개발에 집중할 수 있다. (Vue Cli) 클라이언트-서버데이터 퍼시스턴스웹애프리케이션의 복잡한 데이터는 클라이언트 사이드와 서버사이트 양쪽 모두에서 퍼시스턴스 데이터로 유지돼야 한다. 이 책을 쓰는 시점에는 이러한 분야의 문제를 해결해 주는 Vue.js공식 라이브러리가 아직 없으며 서드파티 라이브러리 사용자들이 직접 작성한 라이브러리를 사용해 구현한다. Vue.js의 기반 기술컴포넌트 시스템Vue.js는 컴포넌트를 쉽게 다루기 위한 라이브러리다. 컴포넌트 시스템에서 특기할 만한 기능은 단일 파일 컴포넌트다. Vue.js는 단일 파일에 HTML과 유사한 방식으로 컴포넌트를 작성할 수 있다. 이 파일은 .vue라는 독자적인 확장자를 사용한다. Vue.js 컴포넌트는 기존 웹 표준을 구성하는 기술과 유사한 형태로 정의되기 때문에 학습비용이 매우 낮은것이 특정이다. 파일하나에 컴포넌트의 모든 요소를 함께 담을 수 있다는 점은 큰 장점이다. 컴포넌트의 요점은 언어의 역할과는 별도로 기능이나 관심사를 기준으로 코드를 분리하는 것이기 때문이다. 하나의 관심사만을 같은 GUI 컴포넌트를 분리하려고 할때 HTML/CSS/JavaScript 3가지 요소를 하나의 파일로 합쳐 컴포넌트로 분리 할 수 있으므로 이해하기 쉽다. 리액티브 시스템Vue.js의 리액티브 시스템은 옵저버 패턴을 기반으로 구현 좀더 쉽게 셜명하면 상태의 변화를 Vue.js가 감지해 자동으로 그 변화를 DOM에 반영하는 구조라고 할 수 있다. DOM 을 더욱 정교하고 잦은 비도로 조작해야 하는 애플리케이션에서는 데이터 바인딩이 매우 유용하다. 라이브러리에 이러한 기능이 없다면 값의 변화에 따라 변화해야 하는 곳을 직접 변경하거나 갑의 변경에 따른 사이드 이펙트를 완전히 파악하지 못하고 임시변통으로 틀어막게 되기 쉽다. 뒤에 설명할 계산 프로퍼티는 이러한 리액티브 시스템 덕을 가장 크게보는 사례다. 계산 프로퍼티란 값의 변화를 탐지해 자동으로 업데이트 되는 프로퍼티를 말한다. Vue.js 템플릿에서 빼놓을 수 없는 기능이다. 리액티브 시트템은 리액티브 프로퍼티와 와처가 한 쌍을 이뤄 구현된다. 리액티브 시스템의 내부계산프로퍼티에서는 와처 내부의 게터가 계산 프로터티로 정의하는 함수 역할을 한다. 계산프로퍼티를 처음 참조하면 와처내부에 잇는 게터를 거쳐 리액티브 프ㄹ퍼티의 계산 결과가 와처에 캐싱되며 이와 함께 리액티브 프로퍼티의 의존관계 추적도 완료된다. 그 다음 이 계산 프로퍼티가 다시 참조될 때는 캐싱된 값을 반환해 계산 비용을 절약할 수 있다, 이후에 계산 프로퍼티에서 이 값이 의존하는 리액티브 프로퍼티의 일부가 대입 등의 이유로 변경되면 후크 처리를 통해 와처에 이 변경이 통지되면 내부 게터가 이 통지를 전달받아 프로퍼티 값을 다시 계산해 그 결과가 와처에 새로 캐싱된다. 반면 컴포넌트 렌더링에서는 와처 내부의 게터가 컴포넌트를 렌더링하는 함수 역할을 한다. 모든 컴포넌트가 와처를 갖고 있기 때문에 컴포넌트의 모든 데이터를 래액티브 프로퍼티로 모니터링 한다. 컴포넌트 렌더링은 모니터링 대상 중 어떤 리액티브 프로퍼티가 값이 변경됐다는 통지를 보내면 그때마다 와처의 게터가 실행돼 컴포넌트가 렌더링되는 구조다. 렌더링시스템Vue.js는 가장 DOM을 이용해 DOM을 고속으로 렌더링한다. 가상 DOM은 DOM을 간편하고 빠르게 제어하기 위한 기술이다. 더 편리하고 빠르게 다룰 수 있는 DOM 구조의 대체물을 만든 다음 이 대체물을 조작하고 그 결과를 실제 DOM에 반영한다. 다른라이브러리와 다른 점은 템플릿이 HTML과 유사해 개발이 쉽고 최적화가 잘 돼 있어 빠른 렌더링이 가능하다는 점이다. Vue.js의 생태계Vue.js는 뷰 계층에 초점을 맞춘 라이브러리이므로 엄밀히 말해 프레임워크는 아니다. 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능처럼 UI외적인 기능을 이용하는 웹애플리케이션을 개발하려면 추가 라이브러리가 필요하다. 웹애플리케이션 테스트 및 빌드, 개발 환경역시 직접 구축하지 않으면 안 된다. Vue Router : 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능을 제공하는 플러그인 Vuex : 대규모 웹 애플리케이션을 구축하기 위한 상태 관리 플러그인 Vue Loader : 컴포넌트의 고급 기능을 이용하기 위한 webpack 용 로더 라이브러리 Vue CLI : 웹 애플리케이션을 구축하기 위한 템플릿 프로젝트 생성 및 프로토타입을 추가 설정없이 빌드하기 위한 명령해 Vue DevToolls : Vue.js 애플리케이션을 브라우저의 개발자 도구로 디버깅할 수 있게 해주는 도구 Nuxt.js : 단일 페이지 애플리케이션과 서버 사이드 렌더링을 지원하는 Vue.js 애플리케이션을 개발하기 위한 프레임워크 Weex : Vue.js 문법을 사용해 IOS 및 안드로이드 애플리케이션을 개발할 수 있는 프레임워크 Onsen UI : 모바일 웹 애플리케이션을 개발하기 위한 프레임워크 커뮤니티에서 추천 플러그인, 라이브러리, 도구 등의 정보를 얻을 수 있다. Awesome Vue : Vue.js와 관련된 오픈 소스 프로젝트나 Vue.js가 사용된 웹 사이트 및 애플리케이션 정보를 공유하는 사이트 Vue Curated : Vue.js 코어 팀에서 엄선한 플러그인, 라이브러리, 프레임워크 등을 검색 할수 있는 공식 사이트 Vue.js 첫걸음123456789101112&lt;DOCTYPE html&gt; &lt;title&gt;Vue.js 시작하기&lt;/title&gt; &lt;script src=“https://unpkg.comvue@2.5.17”&gt;&lt;/script&gt; &lt;div id=“app”&gt;&lt;/div&gt;&lt;script&gt; new Vue({ template: ‘&lt;p&gt;{{ msg }}&lt;/p&gt;’, data : { msg: ‘hello world!’ } }).$mount(‘app’)&lt;/script&gt;&lt;/html&gt; Vue.js 참조문서 - 공식사이트 참고(https://vuejs.org) Vue.js 사용자 커뮤니티 Vue.js 포럼 : Vue.js 를 사용하다가 발생하는 트러블이나 질문 사항을 논의하는 사이트 Vue Land : Vue.js 사용자와 코어 팀 멤버 및 컨트리뷰터가 채팅을 커뮤니케이션 하는 커뮤니티 Vue.js 밋업 : 한국 Vue.js 사용자들이 Vue.js 지식과 정보를 공유하는 밋업 이벤트","link":"/2019/11/08/Vue-study-1.1/"},{"title":"지난 1년6개월의 회고","text":"이번에 정들었던 (주)라이프스타일프로젝트(이하 LSP) 를 떠나면서 그동안의 회사생활 및 1년6개월 동안의 생활을 회고해보고 달라진 점들을 정리해본다. 사실 지금 글을 쓰고있는 오늘(8월29일)이 마지막 출근날이다. 뜻밖의 연락현재 다니고있고 곧 퇴사(8월31일부)하게 되는 LSP와의 인연은 2018년 2월에 시작됐다.그 당시 이직을 준비하고 있는 상태였던 필자는 취업사이트에 이력서를 올려놓고 여러군데에 면접을 보고 있는 상황이었다.그러던중 지금의 회사 인사팀에서 먼저 필자의 이력서를 보고 연락이 왔다. 그당시 회사명은 (주)유앤김파트너스 였다. 그때까지만 해도 이력서를 넣지 않은 곳에서 직접적으로 연락이 온적은 없어서 있단 신기했고 또 그 당시 회사 주력브랜드였던 미프(미남프로젝트)의 제품을 우연히 정글의 법칙에서 김병만이 사용하는 것을 본 후라 그런지 더욱 신기했었다. 그렇게 면접제의를 받고 면접을 보게 되엇는데 1:3의 면접이었다. 면접관으로는 지금 같이 일하고 있는 팀장님, 인사담당자, 부사장님 이렇게 세분이 들어오셨었다. 몇가지 기술적인 질문이 있었으나 크게 어려운 질문은 없었고 상당히 즐거운 분위기에서 면접은 마무리되었다. 기억나는게 한가지 있는데 면접 마지막에 언제 연락을 줄 수 있냐는 필자의 질문에 회사측에서 필자가 첫번째 면접자라고 시간이 조금 걸릴것 같다고 했는데 그 대답을 듣고 필자가 호기롭게 &quot;첫번째가 가장좋은거 아시죠??&quot;하며 너스레를 떨었던 것이 기억이 난다. ㅎㅎㅎ 지금 생각해도 참….. 그 덕분인지는 모르겠지만 면접 다음날 바로 연락이 왔는데 다른 사람을 추가면접보지 않고 바로 필자를 합격자로 정했다는 연락이었다. 연봉제안도 필자가 제시했던 금액보다 좋은 조건을 제시해주어서 여러가지 망설임이 있었지만 입사를 결정하게 되었다. 두근두근 첫 출근입사는 설이 지나고였다. 명절을 보내고 새로운 마음으로 회사에 첫 출근을 하였다. 부서는 크리에이티브팀이었고, 필자를 제외한 모든 부서원들은 디자이너들이었다. 필자의 업무는 기존에 계시던 분이 인수인계를 해주셨는데, 회사가 원래는 판교에서 지금의 역삼역근터로 이사를 오면서 거리도 멀어지고 건강도 안좋아지셔서 어쩔수 없이 퇴사를 하게 되었다고 하셨다. 그렇게 인수인계 받은 기존의 사이트는 카페24 쇼핑몰 솔루션을 통해 작업이 되어있었고 대부분이 이미지로 코딩이 되어있는 상태였다. 기존에 계시던분이 원래 디자이너 출신이어서 간단하게 코딩이 이루어져 있었다. 추후에 대대적인 리뉴얼이 이루어졌다.그때까지만 해도 필자는 카페25 쇼핑몰 솔루션은 로그인만 해서 보았던게 전부였고 그 전에 하드코딩을 했었어서 카페25를 통한 코딩에 막연한 두려움을 약간을 가지고 있었으나 기존에 하던것에서 약간의 환경의 변화만 있었을 뿐 어려움 없이 적응 할 수 있었다.또한 인수인계를 해주고 떠나시는 분을 제외하고는 회사에서 코딩 및 개방을 할 수 있는 사람이 한 사람도 없어서 막막하기도 하였다. 하면된다.짧은 인수인계 기간이 끝나고 본격적으로 홀로 업무가 시작되었다.그때 급한 업무를 처음으로 처리했던 기억이 나는데 기존에 계시던 분도 처음하는 일이었도 필자도 처음 듣는 업무여서 약간 당황했덨던 기억이난다. 업무내용은 그 때 당시 미프 모바일 사이트를 패키징하여 어플출시를 앞두고 있었는데 그 어플 출시를 위해서 애플 개발자 등록을 해야하고 결재를 해야되는데 그 단계에서 애플과 메일을 주고받고 전화를 받고 거기에서 받은 인증번호를 다시 입력하고 하는 등의 복잡한 프로세스가 있었는데 전에 계신던 분도 몇번 시도를 하다가 중간에 문제가 생겨서 해결을 못하시고 퇴사를 하시면서 필자에게 넘어왔던 업무였다. 중간에 무엇을 잘못했는지 중간 프로세스에서 막혀있는 상태였고 그렇게 상당한 시간이 흘러서 앱스토어 어플 출시 자체가 기약없이 미뤄지고 있는 상황이었다. 필자도 처음 겪는 업무여서 현재의 상황과 구글링 그리고 앱스토어의 문의를 통해 예상보다 빠르고 쉽게 앱스토어 어플 출시를 이루어낼 수 있었다. 오랜기간 멈춰져있던 업무를 필자가 잘 마무리 해서 입사한 후에 업무에 적응하는데 큰 도움이 되었던 사건이었다. 일을 하면서1년6개월 동안 LSP를 다니면서 많은 것들을 배우고 성장하는 시간이었다. 회사의 기초가 화장품제조 및 판매이다보니 쇼핑몰 사이트의 개발과 운영에 대해 많은 것들을 배우게 되었고 쇼핑몰의 기초가 되는 카페24 쇼핑몰 솔루션에 대한 깊은 이해를 가질수 있었다. 그와 더불어 기존에 다니넌 에이전시와는 다르게 여유시간들을 갖게되어 아무래도 별도의 클라이언트가 있는것이 아니라 자사의 제품들만 다루기 때문에 일정과 같은 부분에서 회사 내부에 사정에 맞게 조율이 가능한 부분이 있었다. 많은 커뮤니티활동과 더불어 학원에도 다닐수 있는 기회가 있었고 스터디에도 참여해서 많은 것들을 배우는 시간을 가질 수 있었다. 필자는 크리에이티브팀에 소속되어있었다. 암묵적으로 디자인팀으로 불리운다 그 이유는 앞에서 잠깐 언급했듯이 필자를 제외한 모든 팀원이 디자이너로 구성되어있기 때문이었다. 필자도 퍼블려서로 전향하기 이전에는 무대디자인을 하였기에 디자이너들과의 소통 및 협업에는 큰 문제가 없었다. 그리고 화장품회사의 특성(?)상 남자직원들보다는 여자직원들의 비중이 더 높았었는데, 이전 무대일을 할때에도 디자인 관련 부서에서 일했기에 여자직원들이 더 많은 환경이었다보니 자연스레 섞여서 생활을 했었고 그러다보니 커뮤니케이션 같은 부분에서는 전혀 어려움이 없었으나 코딩 및 개발 업무를 알고 있는 사람은 전혀 없어서 어떤한 문제가 생겼을 때 혼자서 해쳐나가야하는 어려움은 늘 존재했었고 같이 문제에 대해 고민해 줄 사람의 필요가 느껴졌었다. 당시 회사 사정상 여러 개발자를 두는것은 무리가 있었고 그러다 보니 배움과 공유에 대한 갈증이 생겼고 자연스럽게 커뮤니티활동과 스터디로 그 갈증을 푸는 계기가 되었다. 공부, 스터디처음부터 스터디를 시작한 것은 아니었다. 스터디에 대한 정보도 없었고 그러한 것들이 활발히 진행되고 있는 것도 모르는 상황이었다. 그래서 처음에는 익숙한 컴퓨터학원을 통해 부족하다고 생각했던 개발에 대한 부분들의 수업을 듣기 시작했다. 그렇게 몇가지 수업들을 들었으나 만족할 만한 실력향상은 나타나지 않았던것 같다. 그러던중 우연히 '하코사'라는 커뮤니티를 접하게 되었고 스터디들이 활발히 진행되고 있는 것을 알게 되었다. 필자와 같은 고민을 하는 분들이 많이 있었으며 자신의 어려움을 질문하고 답을 얻어가고 함께 공부하는 커뮤니티였다. 그렇게 여러가지 정보를 얻어가던 중에 한 살롱에 참여하게 되었고 그곳에서 들은 이야기들은 지금까지 내가 알고 있던 내용들과는 많이 다른 내용들이었다. ‘프론트엔드개발자가 되어야지’, ‘지금 하고 있는 업무에서 추가적인 것들을 배우면서 커리어를 쌓으면 할 수 있는 걸 거야’ 와 같은 막연한 계획들이 있었는데 그 계획들을 처음부터 다시 생각하게 되는 살롱이었다. 살롱 : 18세기 중반 프랑스에서 지성인과 예술가가 모여 토론을 펼치고 지식을 나누던 사교 모임 살롱에 참여하기 전까지는 프론트엔드 개발자로 전향을 하려면 지금 하던 퍼블리셔 업무에서 추가적으로 약간의 자바스크립트를 배우고 동적인 UI개발을 더 익히면 되겠지 라는 수준이었는데 참여하고 난 후에는 생각이 완전히 바뀌었다. 우선 퍼블리셔와 프론트엔드개발자는 겹치는 부분도 물론 있었지만 근본적으로 다른 직군에 속해 있는 것이라서 추구하는 방향도 다르고 그렇기에 공부해야 하는 방향 자체도 다르다는 것이었다. 대략적으로 퍼블리셔거 보여지는 뷰단에서 UI적인 개발을 주로 한다면 프로트엔드개발자는 프로든단에서 DATA를 다루어 보여지는 뷰단을 선계해 가는 느낌이다. 그렇다보니 접근하는 방식에서부터 차이가 있고 생각하는 방법도 다르게 해야 올바르게 개발자로 거듭날 수 있다는 생각이 들었다. 책 집필스터디에 참여그렇게 살롱다녀와서 거기서 알게된 인연으로 정말 좋은 기회인 책집필을 위한 스터디에 참여하는 기회가 찾아왔다.Vue.js에 관한 책을 집할 하면서 그 내용들을 가지고 구현해 보고 스터디였는데 피자는 당시 Vue.js는 당연히 처음접하였고 프레임워크언어자체가 대한 개념 및 개발을 처음 시작하는 단계였다. 그래서인지 스터디에서 배우는 하나하나가 너무나 값진 경험이었다. 처음 배우는 내용들이다보니 질문도 많았고 이것저것 안되는 것들도 그리고 모르는 것들도 많았는데 집필하시는 분들에게는 이부분이 오히려 도움이 많이 되었다고 하셨다. 서로에게 여러가지를 주고 받을수 있는 윈윈이었으니 잘 마무리 되었다. ㅎㅎㅎ 스터디가 끝나고 간단한 메모어플과 게시판어플을 구현해볼수 있었다. 현재는 책은 무시히 출판되었고 필자는 간단하게나마 추천사로 책 한부분에 남을수 있어서 좋았다. 궁금해 하실 분들을 위해 책제목을 남겨본다. 책 제목은 &quot;커피한잔 마시며 끝내는 Vue.js&quot; 이다. 그렇게 Vue.js 스터디를 끝나마치고 더 배워야 한다는 생각에 git스터디, javajscript스터디에 참여하게 되었고 그러다보니 필자에게 맞는 새로운 스터디를 기획해서 스터디를 진행하게 되었다. 현재는 JS ES6를 중점적으로 스터디를 하고 잇으며 8월 31일에 마지막 스터디 모임을 앞두고 있는 상황이다. 이번 스터디에 함께한 스터디원분들 중 많은 분들이 다음 스터디로 함께 했으면 좋겠다는 의사를 밝혀주셔서 현재는 함께 기획하고 있는 중에 있다. 이렇게 회사 생활을 하면서 커뮤니티와 많은 스터디들을 통해서 부족한 것들을 채우고 발전해나가는 시간들을 가실 수 있었던 것에 대해서는 긍적적으로 생각한다. 마치며지난 1년 6개월 동안 LSP에 지내면서 함께한 모든 분들에게 감사의 인사를 전하고 싶다.비록 더 많은 시간들을 함께 하지는 못하지만 어디에서든지 각자의 몫을 하며 빛나고 있기를 소망한다.","link":"/2019/08/29/Retrospective-20190829/"},{"title":"1. 프로그레시브 프레임워크 Vue.js - part 1","text":"Vue.js 철저입문 책을 읽으면서 간단하게 정리해 보고자 한다. Vue.js는 뷰 레이어에 특화된 라이브러리이다. MVVM패턴의 영향을 받은 설계를 채택하고 있어서 대규모 애플리케이션 개발에도 사용할 수 있습니다. 이러한 특징은 애플리케이션의 규모와 상관없이 어떠한 경우에도 단계적으로 유연한 적용이 가능해지는 프로그래시브 프레임워크라는 Vue.js의 설계사상에서 기인한다고 한다. 이 설계사상으로 인해 프로젝트 초기에는 최소한의 학습비용만으로 시험 적용이 가능하며 대규모 시스템에서는 단계적으로 필요한 기능및 라이브러리를 조합해 덧붙여 가는 독특한 스타일의 개발이 가능하다. Vue.js의 역사Vue.js는 2013년 에반유(Evan You)가 시작한 개인 프로젝트로 출발 2014년 2월 V0.8이 정식발표 2015년 5월에 PHP웹 애플리케이션 프레임워크인 라라벨에 표준 탑재된 것을 계기로 라라벨 커뮤니티에서 화제 2015년 10월 V1.0이 출시 2016년 10월 1일 V2.0이 출시 복잡해진 모던 웹 프론트엔드 개발모던 웹 프로트엔드 개발은 크게 고도화 되고 단일 페이지 애플리케이션(SPA)을 중심으로 프런트엔드 에서 복잡한 처리를 맡는 경우가 늘었으며 애플리케이션 데이터플로 설계, 라우팅, 유효성 체크 등 기존에는 백 엔드에서 맡았던 역할을 프런트 엔드가 맡게 됐다. 자바스크립트 역시 최근 몇년 사이 용도가 급격히 늘어났다. 이와 함께 업무와 관련된 개념과 도구가 함께 복잡해지는 경향을 보였다. 웹 탄생과 웹 기반 시스템의 발전웹(World Wide Web)은 지금부터 20년도 더 전인 1991년에 인터넷상에 처음 등장. 탄생 초기에는 문서 열람만을 목적으로 했으므로 당연히 지금 사용하는 SNS나 스프레드시트 같은 인터렉티브한 콘텐츠 는 구현이 불가능 했다. 1990년 후반부터 CSS와 자바스크립트가 웹 브라우저에 탑재됐다. 당시의 자바스크립트는 매우 빈약해 CSS와 함께 문서를 꾸미는 용도에 주로 사용 됐다. 비록 제약은 많았지만. 이들의 등장으로 웹페이지를 GUI 애플리케이션처럼 꾸밀 수 있게 됐다. CGI(Common Gateway Interface)로 대표되는 웹에서 사용되는 서버 사이드 프로그래밍 기술이 등장 웹 브라우저를 프리젠테이션 계층으로 삼는 웹기반 3계층 아키텍처 시스템이 등장 루비 온 레이즈로 대표되는 MVC기반 웹애플리케이션 프레임워크도 등장 당시 프런트엔드가 담당했던 기능은 css등을 이용한 시작적효과와 자바스크립트를 이용한 알림창, 입력을 받는 기능 정도가 고작이었다. Ajax의 등장프런트엔드의 기능은 보여주는 것에만 한정된다는 것이 상식이었던 적이 있다. 그러나 2005년에 구글이 지도 서비스 구글맵스를 출시하면서 이러한 상식이 뒤집어졌다. 같은 페이지 안에서 콘텐츠를 빠르고 인터랙티브하게 변화시키는 경쾌한 사용자 경험이 Ajax를 통해 가능해졌다. Ajax 의 등장 이후 클라이언트 사이드에서는 Ajax및 이를 이용한 DOM을 정교하게 조작하는 기능이 필요해졌다. 필요에 따라 등장한 jQuery등이 인기를 얻었다. 서버사이드 분야는 웹서버가 HTML 렌더링을 넘어 RESTful 기반 웹API 를 제공하게 됐다. 2000년대 말에는 HTML5와 ECMAScript를 중심으로 웹이 다시 크게 진화 Node.js가 등장하면서 웹프런트엔드 개발이 한층 복잡해졌다. HTML5의 등장HTML5는 2014년에 권고안이 나온 표준규격이다.그중 중요한 것은 Histrory API 인데 덕분에 페이지이동을 웹브라우저대신 자바스크립트로 핸들링할 수 있게 됐다. 이를 통해 화면이동없이 URL과 히스토리를 관리하며 전환할 수 있는 단일 페이지 애플리케이션을 만들수 있게 됐다. 이러한 변화에 따라 프리젠테이션 레이어의 프로그램이 서버사이드 에서 클라이언트 사이드로 옮겨오게 된다. 기존에는 HTML렌더링을 서버에서 수행했지만, 웹 API로 데이터를 받아올수 있게 되면서 클라이언트에서도 HTML 렌더링이 가능해졌기 때문이다. 이런 방식이 화면이동이 적기 때문에 더 뛰어난 사용자 경험을 제공할 수 있다. Node.js 와 자바스크립트 생태계의 진화2009년 에는 Node.js 가 등장 첫번째 변화는 자바스크립트 실행환경이 브라우저를 벗어난 것이다. Node.js 는 프런트엔드 개발과 테스트에 매우 유용한 환경이다. 두번째 변화는 패키지 관리자이자 패키지 리포지토리인 npm의 보급이다. 이에 따라 모듈(패키지)을 사용할수 있게 됐고 개발된 산출물을 다시 모듈화해 npm을 통해 배포하는 문화가 정착했다. ES2015 와 프로그래밍 언어로서의 진화웹 프런트엔드 개발이 고도화되던 와중에 문제가 된것이 자바스크립트의 빈약한 언어 기능이었다. 그래서 대대적인 규격 업데이트가 필요 했고 이에 ES2015(ES6) 가 등장했다.ES2015 는 자바스크립트 역사상 가장 큰 규모의 업데이트였다. 문법이 확장되고 const나 let등이 널리 쓰이게 되는 등 작성스타일에도 대대적인 변화가 있었다. 표준규격이 제안 됐다고 해서 곧바로 모든 브라우저에 구현이 적용되지는 않는다. 그러나 새로운 규격에는 기존의 불만을 해소할수 잇는 매력적인 것들이 많았고 그래서 이러한 규격을 브라우저에 구현해 사용하려는 움직임이 있었다.Babel 은 이러한 수요에 대응해 자바스크립트를 자바스크립트로 번역하는 컴파일러다. 차세대 문법을 따른 자바스크립트 코드를 아직 해당 규격이 구현되지 않은 브라우저에서 사용할 수 있는 자바스크립트 코드로 변화하는 것이다. React등 프런트엔드 라이브러리의 출현애플리케이션 데이터플로를 프런트엔드로 가져오는 등 설계 단계부터 개발 난이도를 상승시키는 것이 많았다. DOM을 웹 API와 연동시키는 것도 생각 없이 할수 있는 일이 아니다.애플리케이션을 구조화 할수 없는 jQury등을 사용해서는 구현하기가 어렵다 그러므로 MVC와 같은 애플리케이션구조를 지원하는 프레임워크가 필요해졌다. 그에따라 Backbone.js, AngularJS등 새로운 웹 애플리케이션 프레임워크 및 라이브러리가 속속 나타났다. 이런 상황에서 나타난 것이 페이스북이 개발한 React와 Flux 다.React는 뷰 라이브러리이고, Flux는 애플리케이션 아키텍처다. React 중심의 개발 스타일은 가상 DOM을 이용해 DOM 조작을 빠르게 수행했고, Flux 는 혼란스러워지기 쉬운 아케텍처에 방향을 제시해 큰 인기를 모았다. 현재 당면과제와 Vue.js모던 프런트 엔드 개발은 현재에 이르기까지 다음과 같은 변화와 새로운 문제점을 낳았다. HTML5 이후 웹이 애플리케이션 플랫폼으로 기능하게 되면서 API가 고도화 됨 Node.js 생태계의 발전과 개발 환경 구축의 난이도 증가 ES2015 이후 문법이 보강되면서 학습할 내용이 증가 React 이후 프런트 엔드 개발이 프레임워크화되면서 그에 따른 학습비용증가 정리하다보니 모던 프론트엔드 개발의 역사와 같이 나와있어서 생각보다 정리해야될 내용이 많았다.그래서 2파트로 나누어서 정리하기로 했다.","link":"/2019/11/08/Vue-study-1/"}],"tags":[{"name":"Learning-JavaScript","slug":"Learning-JavaScript","link":"/tags/Learning-JavaScript/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"편집기","slug":"편집기","link":"/tags/편집기/"},{"name":"주석","slug":"주석","link":"/tags/주석/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"맵","slug":"맵","link":"/tags/맵/"},{"name":"셋","slug":"셋","link":"/tags/셋/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"이터레이터","slug":"이터레이터","link":"/tags/이터레이터/"},{"name":"제너레이터","slug":"제너레이터","link":"/tags/제너레이터/"},{"name":"예외","slug":"예외","link":"/tags/예외/"},{"name":"에러","slug":"에러","link":"/tags/에러/"},{"name":"ERROR","slug":"ERROR","link":"/tags/ERROR/"},{"name":"try","slug":"try","link":"/tags/try/"},{"name":"catch","slug":"catch","link":"/tags/catch/"},{"name":"finally","slug":"finally","link":"/tags/finally/"},{"name":"함수","slug":"함수","link":"/tags/함수/"},{"name":"추상적사고","slug":"추상적사고","link":"/tags/추상적사고/"},{"name":"추상화","slug":"추상화","link":"/tags/추상화/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"날짜","slug":"날짜","link":"/tags/날짜/"},{"name":"시간","slug":"시간","link":"/tags/시간/"},{"name":"date","slug":"date","link":"/tags/date/"},{"name":"time","slug":"time","link":"/tags/time/"},{"name":"timezone","slug":"timezone","link":"/tags/timezone/"},{"name":"moment","slug":"moment","link":"/tags/moment/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"리터널","slug":"리터널","link":"/tags/리터널/"},{"name":"변수","slug":"변수","link":"/tags/변수/"},{"name":"상수","slug":"상수","link":"/tags/상수/"},{"name":"데이터타입","slug":"데이터타입","link":"/tags/데이터타입/"},{"name":"원시타입","slug":"원시타입","link":"/tags/원시타입/"},{"name":"템플릿문자열","slug":"템플릿문자열","link":"/tags/템플릿문자열/"},{"name":"개발도구","slug":"개발도구","link":"/tags/개발도구/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"babel","slug":"babel","link":"/tags/babel/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"제어문","slug":"제어문","link":"/tags/제어문/"},{"name":"if문","slug":"if문","link":"/tags/if문/"},{"name":"반복문","slug":"반복문","link":"/tags/반복문/"},{"name":"for문","slug":"for문","link":"/tags/for문/"},{"name":"스코프","slug":"스코프","link":"/tags/스코프/"},{"name":"호이스팅","slug":"호이스팅","link":"/tags/호이스팅/"},{"name":"scope","slug":"scope","link":"/tags/scope/"},{"name":"backup","slug":"backup","link":"/tags/backup/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"백업","slug":"백업","link":"/tags/백업/"},{"name":"객체","slug":"객체","link":"/tags/객체/"},{"name":"객체지향프로그래밍","slug":"객체지향프로그래밍","link":"/tags/객체지향프로그래밍/"},{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"클로저","slug":"클로저","link":"/tags/클로저/"},{"name":"컨텍스트","slug":"컨텍스트","link":"/tags/컨텍스트/"},{"name":"context","slug":"context","link":"/tags/context/"},{"name":"실행컨텍스트","slug":"실행컨텍스트","link":"/tags/실행컨텍스트/"},{"name":"명령어","slug":"명령어","link":"/tags/명령어/"},{"name":"commend","slug":"commend","link":"/tags/commend/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"블로그","slug":"블로그","link":"/tags/블로그/"},{"name":"comment","slug":"comment","link":"/tags/comment/"},{"name":"disqus","slug":"disqus","link":"/tags/disqus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"댓글","slug":"댓글","link":"/tags/댓글/"},{"name":"쿠팡","slug":"쿠팡","link":"/tags/쿠팡/"},{"name":"파트너스","slug":"파트너스","link":"/tags/파트너스/"},{"name":"쿠팡파트너스","slug":"쿠팡파트너스","link":"/tags/쿠팡파트너스/"},{"name":"ad","slug":"ad","link":"/tags/ad/"},{"name":"themes","slug":"themes","link":"/tags/themes/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"icarus테마","slug":"icarus테마","link":"/tags/icarus테마/"},{"name":"posting","slug":"posting","link":"/tags/posting/"},{"name":"Wiriting","slug":"Wiriting","link":"/tags/Wiriting/"},{"name":"post","slug":"post","link":"/tags/post/"},{"name":"scaffolds","slug":"scaffolds","link":"/tags/scaffolds/"},{"name":"setting","slug":"setting","link":"/tags/setting/"},{"name":"VScode","slug":"VScode","link":"/tags/VScode/"},{"name":"터미널","slug":"터미널","link":"/tags/터미널/"},{"name":"Terminal","slug":"Terminal","link":"/tags/Terminal/"},{"name":"gitbash","slug":"gitbash","link":"/tags/gitbash/"},{"name":"VisualStudioCode","slug":"VisualStudioCode","link":"/tags/VisualStudioCode/"},{"name":"설정","slug":"설정","link":"/tags/설정/"},{"name":"extension","slug":"extension","link":"/tags/extension/"},{"name":"확장프로그램","slug":"확장프로그램","link":"/tags/확장프로그램/"},{"name":"추천","slug":"추천","link":"/tags/추천/"},{"name":"설치방법","slug":"설치방법","link":"/tags/설치방법/"},{"name":"draft","slug":"draft","link":"/tags/draft/"},{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"마크다운","slug":"마크다운","link":"/tags/마크다운/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"세팅","slug":"세팅","link":"/tags/세팅/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"깃","slug":"깃","link":"/tags/깃/"},{"name":"깃허브","slug":"깃허브","link":"/tags/깃허브/"},{"name":"비동기","slug":"비동기","link":"/tags/비동기/"},{"name":"프라미스","slug":"프라미스","link":"/tags/프라미스/"},{"name":"콜백","slug":"콜백","link":"/tags/콜백/"},{"name":"단일스레드","slug":"단일스레드","link":"/tags/단일스레드/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"연산자","slug":"연산자","link":"/tags/연산자/"},{"name":"표현식","slug":"표현식","link":"/tags/표현식/"},{"name":"배열","slug":"배열","link":"/tags/배열/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"배열메서드","slug":"배열메서드","link":"/tags/배열메서드/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"뷰","slug":"뷰","link":"/tags/뷰/"},{"name":"프레임워크","slug":"프레임워크","link":"/tags/프레임워크/"},{"name":"스터디","slug":"스터디","link":"/tags/스터디/"},{"name":"회고","slug":"회고","link":"/tags/회고/"},{"name":"1년6개월","slug":"1년6개월","link":"/tags/1년6개월/"},{"name":"LSP","slug":"LSP","link":"/tags/LSP/"},{"name":"공부","slug":"공부","link":"/tags/공부/"}],"categories":[{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Learning-JavaScript","slug":"Study/Learning-JavaScript","link":"/categories/Study/Learning-JavaScript/"},{"name":"hexo","slug":"Programming/hexo","link":"/categories/Programming/hexo/"},{"name":"클로저","slug":"Study/클로저","link":"/categories/Study/클로저/"},{"name":"실행컨텍스트","slug":"Study/실행컨텍스트","link":"/categories/Study/실행컨텍스트/"},{"name":"git","slug":"Programming/git","link":"/categories/Programming/git/"},{"name":"SEO","slug":"Programming/hexo/SEO","link":"/categories/Programming/hexo/SEO/"},{"name":"comment","slug":"Programming/hexo/comment","link":"/categories/Programming/hexo/comment/"},{"name":"ad","slug":"Programming/hexo/ad","link":"/categories/Programming/hexo/ad/"},{"name":"themes","slug":"Programming/hexo/themes","link":"/categories/Programming/hexo/themes/"},{"name":"setting","slug":"Programming/hexo/setting","link":"/categories/Programming/hexo/setting/"},{"name":"Setting","slug":"Setting","link":"/categories/Setting/"},{"name":"posting","slug":"Programming/hexo/posting","link":"/categories/Programming/hexo/posting/"},{"name":"Markdown","slug":"Programming/Markdown","link":"/categories/Programming/Markdown/"},{"name":"backup","slug":"Programming/hexo/backup","link":"/categories/Programming/hexo/backup/"},{"name":"VScode","slug":"Setting/VScode","link":"/categories/Setting/VScode/"},{"name":"zsh","slug":"Setting/zsh","link":"/categories/Setting/zsh/"},{"name":"SSH","slug":"Setting/SSH","link":"/categories/Setting/SSH/"},{"name":"gitbash","slug":"Setting/VScode/gitbash","link":"/categories/Setting/VScode/gitbash/"},{"name":"Extension","slug":"Setting/VScode/Extension","link":"/categories/Setting/VScode/Extension/"},{"name":"Vue.js 철저입문","slug":"Study/Vue-js-철저입문","link":"/categories/Study/Vue-js-철저입문/"},{"name":"회고","slug":"회고","link":"/categories/회고/"}]}