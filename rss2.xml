<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mishka&#39;s Blog</title>
    <link>http://mishka86.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>미슈카의 개발 블로그 입니다.</description>
    <pubDate>Fri, 08 Nov 2019 09:31:18 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>1. 프로그레시브 프레임워크 Vue.js - part 2</title>
      <link>http://mishka86.github.io/2019/11/08/Vue-study-1.1/</link>
      <guid>http://mishka86.github.io/2019/11/08/Vue-study-1.1/</guid>
      <pubDate>Fri, 08 Nov 2019 09:11:05 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Vue-js-의-특징&quot;&gt;&lt;a href=&quot;#Vue-js-의-특징&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 의 특징&quot;&gt;&lt;/a&gt;Vue.js 의 특징&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Vue.js&lt;/code&gt;는 그 자체로는 뷰만을 다루는 단순한 라이브러리다. Vue.js 본체 뿐만 아니라 관련 라이브러리도 Vue.js 공식 프로젝트의 일부로서 개발 및 관리 된다. 이 때문에 몇가지 라이브러리를 조합하면 마치 종합적인 &lt;strong&gt;프레임워크&lt;/strong&gt;처럼 사용 할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;낮은-학습-비용&quot;&gt;&lt;a href=&quot;#낮은-학습-비용&quot; class=&quot;headerlink&quot; title=&quot;낮은 학습 비용&quot;&gt;&lt;/a&gt;낮은 학습 비용&lt;/h3&gt;&lt;p&gt;Vue.js 가 제공하는 API는 매운 단순하다. UI를 구성하는 데는 HTML을 기반으로 하는 평범한 템플릿을 사용한다. HTML이나 자바스크립트에 이미 익숙하면 Vue.js 에 대해 특별히 더 배우지 않고서도 라이브러리를 사용할 수 있다. 기본적인 사용만 한다면 빌드 도구나 패키징, EC2015 이후 문법에 대한 지식이 없어도 바로 동작하는 코드를 작성할 수 있다. Vue.js 는 앞서 언급한 모던 웹 프런트 엔드 개발의 어려움을 잘 극복했다. HTML5 이후 고도화된 개발 스타일에 부응하면서도 개발 환경 구축이 쉬워서 개발을 바로 시작할 수 있으며 자바스크립트에 대한 사전지식과 라이브러리 고유의 문법을 학습하지 않아도 라이브러리를 사용할 수 있다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Vue-js-의-특징"><a href="#Vue-js-의-특징" class="headerlink" title="Vue.js 의 특징"></a>Vue.js 의 특징</h2><p><code>Vue.js</code>는 그 자체로는 뷰만을 다루는 단순한 라이브러리다. Vue.js 본체 뿐만 아니라 관련 라이브러리도 Vue.js 공식 프로젝트의 일부로서 개발 및 관리 된다. 이 때문에 몇가지 라이브러리를 조합하면 마치 종합적인 <strong>프레임워크</strong>처럼 사용 할 수 있다.</p><h3 id="낮은-학습-비용"><a href="#낮은-학습-비용" class="headerlink" title="낮은 학습 비용"></a>낮은 학습 비용</h3><p>Vue.js 가 제공하는 API는 매운 단순하다. UI를 구성하는 데는 HTML을 기반으로 하는 평범한 템플릿을 사용한다. HTML이나 자바스크립트에 이미 익숙하면 Vue.js 에 대해 특별히 더 배우지 않고서도 라이브러리를 사용할 수 있다. 기본적인 사용만 한다면 빌드 도구나 패키징, EC2015 이후 문법에 대한 지식이 없어도 바로 동작하는 코드를 작성할 수 있다. Vue.js 는 앞서 언급한 모던 웹 프런트 엔드 개발의 어려움을 잘 극복했다. HTML5 이후 고도화된 개발 스타일에 부응하면서도 개발 환경 구축이 쉬워서 개발을 바로 시작할 수 있으며 자바스크립트에 대한 사전지식과 라이브러리 고유의 문법을 학습하지 않아도 라이브러리를 사용할 수 있다.</p><a id="more"></a><h3 id="컴포넌트-지향을-통한-UI-구조화"><a href="#컴포넌트-지향을-통한-UI-구조화" class="headerlink" title="컴포넌트 지향을 통한 UI 구조화"></a>컴포넌트 지향을 통한 UI 구조화</h3><p>Vue.js 는 구조화해 <code>컴포넌트로 재사용</code>할 수 있다. UI 구성 요소를 컴포넌트로 만들면 시스템 전체를 컴포넌트의 집합 형태로 개발 할 수 있다. 개발에 컴포넌트를 적용하면 컴포넌트 분리에서 오는 유지보수성 개선 및 컴포넌트 재사용 등 여러 장점이 있다.</p><h3 id="리액티브-데이터-바인딩"><a href="#리액티브-데이터-바인딩" class="headerlink" title="리액티브 데이터 바인딩"></a>리액티브 데이터 바인딩</h3><p>Vue.js 는 DOM요소와 <strong>리액티브 데이터 바인딩</strong>을 통해 자바스크립트 데이터를 연결해 준다. <code>리액티브 데이터 바인딩</code>이란 HTML 템플릿 안에서 대상 DOM 요소에 바인딩 을 지정해 Vue.js 가 해당 데이터의 변화를 감지할 때마다 바인딩된 DOM 요소에 표시되는 내용도 함께 업데이트하는 것을 말한다. 값은 자바스크립트에서 DOM요소로 일방적으로 전달된다. 이것을 <strong>단방향 바인딩</strong>이라고 한다. 자바스크립트쪽에서 위치한 데이터 값이 변경되면 변경된 값이 웹 페이지에도 자동으로 반영되는 기능이다. input 요소등 사용자의 입력을 받는 DOM요소는 요소에서 받아온 데이터와 자바스크립트 데이터를 서로동기화하는 바인딩을 지정한다. 이런 경우 자바스크립트의 데이터 값이 변경될때마다 DOM요소의 표시 내용이 수정되며, 사용자의 입력이 감지될때마다 자바스크립트 데이터가 수정된다. 이런 방법으로 자바스크립트 데이터와 DOM요소 데이터의 동기화 상태를 유지한다. 이 방법은 자바스크립트와 DOM요소가 서로 최신 데이터를 주고받으므로 양방향 바인딩이라고 한다. 바인딩을 이용함으로써 귀찮은 표시 내용 업데이트 처리와 DOM 요소와 자바스크립트 간 데이터 동기화 상태 유지로부터 해당됐으며 데이터 중심 웹 애플리케이션 설계 및 구현이 가능해졌다.</p><h2 id="Vue-js의-설계사상"><a href="#Vue-js의-설계사상" class="headerlink" title="Vue.js의 설계사상"></a>Vue.js의 설계사상</h2><p>Vue.js는 사용성 면에서도 뛰어난 라이브러리지만, 성능적인 측면을 비롯해 다른 장점도 많은 라이브러리다. 그러나 이와 비슷한 장점이 많은 라이브러리도 있다. Vue.js 가 이런 다른 라이브러리와 분명이 차별화 되는 점이 있다. 바로 밑바탕이 되는 설계사상이다. Vue.js의 설계 밑 바탕에는 <code>프로그래시브 프레임워크(Progressive framework)</code> 라는 아이디어가 깔려있다.<br>‘프레임워크는 어떤 경우든지 규모와 상관없이 단계적으로 유연하게 사용할 수 있어야 한다.’ 라고 Vue.js를 만든 에반유가 처음 주창했다.</p><h3 id="프레임워크의-복잡성"><a href="#프레임워크의-복잡성" class="headerlink" title="프레임워크의 복잡성"></a>프레임워크의 복잡성</h3><p>웹 프런트 엔트 분야에는 React와 Angular 등 라이브러리와 프레임워크가 여러 가지 있다. 프레임워크는 애플리케이션 개발의 복잡성을 해소해주는 도구다. 그러나 애플리케이션과 마찬가지로 프레임워크에도 프레임워크 자체의 복잡성이 있다. 프레임워크라는 도구를 사용하려면 도구 자체의 복잡성에서 오는 비용과 애플리케이션 개발의 복잡성에서 오는 비용이 균형을 이루도록 적합한 프레임워크를 선택하는 것이 중요하다.</p><h3 id="요구-사항의-변화를-수용할수-있는-프레임워크"><a href="#요구-사항의-변화를-수용할수-있는-프레임워크" class="headerlink" title="요구 사항의 변화를 수용할수 있는 프레임워크"></a>요구 사항의 변화를 수용할수 있는 프레임워크</h3><p>사이트 및 애플리케이션의 요규사항은 끊임없이 변화한다. 프레임워크도 이렇게 변화하는 요구사항에 맞춰 가치를 제공하려면 그만큼 유연하지 않으면 안 된다. 애플리케이션이 최초 완성되고 나면 변화하는 요구사항에 대응하기 위해 애플리케이션의 규모가 지족해서 커지게 마련이다. 대부분 애플리케이션 개발을 지원하는 라이브러리나 도구를 추가로 도입해 새로운 비즈니스 요구사항을 만족시키게 된다. 그러나 이렇게 새로운 요소를 덧붙이는 방법은 생각대로 되지 않는 경우가 많다. 웹 프런트엔드 생태계는 최근 끊임없이 변화하고 있기 때문에 애플리케이션에 도입한 프레임워크나 개발 환경이 얼마 지나지 않아 시대에 뒤떨어지게 되고 다시 어떤 프레임워크로 갈아타야 하는지조차 알 수 없는 상황에 직면하게 된다. 이런 상황에 대처하려면 요구 사항 변과에 단계적으로 대응해야 한다. 이러한 아이디어를 반영한 것이 바로 프로그래시브 프레임워크다. 프로그래시브 프레임워크는 무제를 해결할 수 있는 적합한 라이브러리를 적시에 도입해 문제를 해결한다. Vue.js는 <strong>뷰 계층에 초점을 맞춘 라이브러리</strong>다. Vue.js 프로젝트가 제공하는 부가적인 라이브러리와 개발환경 도구를 사용하면 프로그래시브 프레임워크가 된다.</p><h2 id="프로그레시브-프레임워크가-제공하는-단계적-영역"><a href="#프로그레시브-프레임워크가-제공하는-단계적-영역" class="headerlink" title="프로그레시브 프레임워크가 제공하는 단계적 영역"></a>프로그레시브 프레임워크가 제공하는 단계적 영역</h2><h3 id="선언적-렌더링"><a href="#선언적-렌더링" class="headerlink" title="선언적 렌더링"></a>선언적 렌더링</h3><p>이 영역은 선언적 DOM 렌더링과 관련된 영역이다. HTML 템플릿에 렌더링 대상을 선언적으로 기술해 데이터가 변경될 때마다 DOM을 반응적으로 렌더링하고 사용자 입력 데이터를 동기화 할 수 있다,<br>Vue.js 본체가 제공하는 기능이다.</p><h3 id="컴포넌트-시스템"><a href="#컴포넌트-시스템" class="headerlink" title="컴포넌트 시스템"></a>컴포넌트 시스템</h3><p>UI를 모듈화해 재사용할수 있게 해주는 영역 이 영역 역시 UI 를 컴포넌트로 만들어주는 Vue.js 본체가 제공하는 기능이다.</p><h3 id="클라이언트-사이드-라우팅"><a href="#클라이언트-사이드-라우팅" class="headerlink" title="클라이언트 사이드 라우팅"></a>클라이언트 사이드 라우팅</h3><p>단일 페이지 애플리케이션이 동작하기 위해 필요한 영역이다. 라우팅이란 간단히 말해 애플리케이션의 URL 설계, 지시와 같은 것이다. Vue.js의 공식 라우팅 라이브러리인 Vue Router를 사용하면 기존에 개발한 컴포넌트로 당일 페이지 애플리케이션을 만들 수 있다.</p><h3 id="대규모-상태관리"><a href="#대규모-상태관리" class="headerlink" title="대규모 상태관리"></a>대규모 상태관리</h3><p>컴포넌트 간에 상태를 고유하는 방법을 필요로 하는 영역이다. Vue.js의 공식 데이터플로 아키텍처를 따라 만든 상태관리 라이브러리인 VUEX 를 사용하면 이 영역의 문제를 해결할 수 있다, 기존 컴포넌트를 확장하는 형태로 상태를 중앙에서 관리 할 수 있다.</p><h3 id="빌드시스템"><a href="#빌드시스템" class="headerlink" title="빌드시스템"></a>빌드시스템</h3><p>웹 애플리케이션을 구성하는 컴포넌트 관리, 운영환경배포, 프로젝트 구성등과 관련된 영역이다. Vue.js의 공식 개발지원 도구를 이용해 이 영역의 문제를 해결할 수 있다, 프로젝트의 환경구축, 구성관리에 수고를 들이는 대신 개발에 집중할 수 있다. (Vue Cli)</p><h3 id="클라이언트-서버데이터-퍼시스턴스"><a href="#클라이언트-서버데이터-퍼시스턴스" class="headerlink" title="클라이언트-서버데이터 퍼시스턴스"></a>클라이언트-서버데이터 퍼시스턴스</h3><p>웹애프리케이션의 복잡한 데이터는 클라이언트 사이드와 서버사이트 양쪽 모두에서 퍼시스턴스 데이터로 유지돼야 한다. 이 책을 쓰는 시점에는 이러한 분야의 문제를 해결해 주는 Vue.js공식 라이브러리가 아직 없으며 서드파티 라이브러리 사용자들이 직접 작성한 라이브러리를 사용해 구현한다.</p><h2 id="Vue-js의-기반-기술"><a href="#Vue-js의-기반-기술" class="headerlink" title="Vue.js의 기반 기술"></a>Vue.js의 기반 기술</h2><h3 id="컴포넌트-시스템-1"><a href="#컴포넌트-시스템-1" class="headerlink" title="컴포넌트 시스템"></a>컴포넌트 시스템</h3><p>Vue.js는 컴포넌트를 쉽게 다루기 위한 라이브러리다. 컴포넌트 시스템에서 특기할 만한 기능은 단일 파일 컴포넌트다. Vue.js는 단일 파일에 HTML과 유사한 방식으로 컴포넌트를 작성할 수 있다. 이 파일은 .vue라는 독자적인 확장자를 사용한다. Vue.js 컴포넌트는 기존 웹 표준을 구성하는 기술과 유사한 형태로 정의되기 때문에 학습비용이 매우 낮은것이 특정이다. 파일하나에 컴포넌트의 모든 요소를 함께 담을 수 있다는 점은 큰 장점이다. 컴포넌트의 요점은 언어의 역할과는 별도로 기능이나 관심사를 기준으로 코드를 분리하는 것이기 때문이다. 하나의 관심사만을 같은 GUI 컴포넌트를 분리하려고 할때 HTML/CSS/JavaScript 3가지 요소를 하나의 파일로 합쳐 컴포넌트로 분리 할 수 있으므로 이해하기 쉽다.</p><h3 id="리액티브-시스템"><a href="#리액티브-시스템" class="headerlink" title="리액티브 시스템"></a>리액티브 시스템</h3><p>Vue.js의 리액티브 시스템은 옵저버 패턴을 기반으로 구현 좀더 쉽게 셜명하면 상태의 변화를 Vue.js가 감지해 자동으로 그 변화를 DOM에 반영하는 구조라고 할 수 있다. DOM 을 더욱 정교하고 잦은 비도로 조작해야 하는 애플리케이션에서는 데이터 바인딩이 매우 유용하다. 라이브러리에 이러한 기능이 없다면 값의 변화에 따라 변화해야 하는 곳을 직접 변경하거나 갑의 변경에 따른 사이드 이펙트를 완전히 파악하지 못하고 임시변통으로 틀어막게 되기 쉽다. 뒤에 설명할 계산 프로퍼티는 이러한 리액티브 시스템 덕을 가장 크게보는 사례다. 계산 프로퍼티란 값의 변화를 탐지해 자동으로 업데이트 되는 프로퍼티를 말한다. Vue.js 템플릿에서 빼놓을 수 없는 기능이다. 리액티브 시트템은 리액티브 프로퍼티와 와처가 한 쌍을 이뤄 구현된다.</p><h3 id="리액티브-시스템의-내부"><a href="#리액티브-시스템의-내부" class="headerlink" title="리액티브 시스템의 내부"></a>리액티브 시스템의 내부</h3><p>계산프로퍼티에서는 와처 내부의 게터가 계산 프로터티로 정의하는 함수 역할을 한다. 계산프로퍼티를 처음 참조하면 와처내부에 잇는 게터를 거쳐 리액티브 프ㄹ퍼티의 계산 결과가 와처에 캐싱되며 이와 함께 리액티브 프로퍼티의 의존관계 추적도 완료된다. 그 다음 이 계산 프로퍼티가 다시 참조될 때는 캐싱된 값을 반환해 계산 비용을 절약할 수 있다, 이후에 계산 프로퍼티에서 이 값이 의존하는 리액티브 프로퍼티의 일부가 대입 등의 이유로 변경되면 후크 처리를 통해 와처에 이 변경이 통지되면 내부 게터가 이 통지를 전달받아 프로퍼티 값을 다시 계산해 그 결과가 와처에 새로 캐싱된다. 반면 컴포넌트 렌더링에서는 와처 내부의 게터가 컴포넌트를 렌더링하는 함수 역할을 한다. 모든 컴포넌트가 와처를 갖고 있기 때문에 컴포넌트의 모든 데이터를 래액티브 프로퍼티로 모니터링 한다. 컴포넌트 렌더링은 모니터링 대상 중 어떤 리액티브 프로퍼티가 값이 변경됐다는 통지를 보내면 그때마다 와처의 게터가 실행돼 컴포넌트가 렌더링되는 구조다.</p><h3 id="렌더링시스템"><a href="#렌더링시스템" class="headerlink" title="렌더링시스템"></a>렌더링시스템</h3><p>Vue.js는 가장 DOM을 이용해 DOM을 고속으로 렌더링한다. 가상 DOM은 DOM을 간편하고 빠르게 제어하기 위한 기술이다. 더 편리하고 빠르게 다룰 수 있는 DOM 구조의 대체물을 만든 다음 이 대체물을 조작하고 그 결과를 실제 DOM에 반영한다. 다른라이브러리와 다른 점은 템플릿이 HTML과 유사해 개발이 쉽고 최적화가 잘 돼 있어 빠른 렌더링이 가능하다는 점이다.</p><h2 id="Vue-js의-생태계"><a href="#Vue-js의-생태계" class="headerlink" title="Vue.js의 생태계"></a>Vue.js의 생태계</h2><p>Vue.js는 뷰 계층에 초점을 맞춘 라이브러리이므로 엄밀히 말해 프레임워크는 아니다. 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능처럼 UI외적인 기능을 이용하는 웹애플리케이션을 개발하려면 추가 라이브러리가 필요하다. 웹애플리케이션 테스트 및 빌드, 개발 환경역시 직접 구축하지 않으면 안 된다.</p><ul><li>Vue Router : 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능을 제공하는 플러그인</li><li>Vuex : 대규모 웹 애플리케이션을 구축하기 위한 상태 관리 플러그인</li><li>Vue Loader : 컴포넌트의 고급 기능을 이용하기 위한 webpack 용 로더 라이브러리</li><li>Vue CLI : 웹 애플리케이션을 구축하기 위한 템플릿 프로젝트 생성 및 프로토타입을 추가 설정없이 빌드하기 위한 명령해</li><li>Vue DevToolls : Vue.js 애플리케이션을 브라우저의 개발자 도구로 디버깅할 수 있게 해주는 도구</li><li>Nuxt.js : 단일 페이지 애플리케이션과 서버 사이드 렌더링을 지원하는 Vue.js 애플리케이션을 개발하기 위한 프레임워크</li><li>Weex : Vue.js 문법을 사용해 IOS 및 안드로이드 애플리케이션을 개발할 수 있는 프레임워크</li><li>Onsen UI : 모바일 웹 애플리케이션을 개발하기 위한 프레임워크</li></ul><p>커뮤니티에서 추천 플러그인, 라이브러리, 도구 등의 정보를 얻을 수 있다.</p><ul><li>Awesome Vue : Vue.js와 관련된 오픈 소스 프로젝트나 Vue.js가 사용된 웹 사이트 및 애플리케이션 정보를 공유하는 사이트</li><li>Vue Curated : Vue.js 코어 팀에서 엄선한 플러그인, 라이브러리, 프레임워크 등을 검색 할수 있는 공식 사이트</li></ul><h2 id="Vue-js-첫걸음"><a href="#Vue-js-첫걸음" class="headerlink" title="Vue.js 첫걸음"></a>Vue.js 첫걸음</h2><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">DOCTYPE</span> <span class="hljs-attr">html</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue.js 시작하기<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">“https://unpkg.comvue@2.5.17”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">“app”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-javascript">  <span class="hljs-keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="hljs-xml">    template: ‘<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>’,</span></span><br><span class="line">    data : &#123; msg: ‘hello world!’ &#125;</span><br><span class="line">  &#125;).$mount(‘app’)</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Vue.js 참조문서 - 공식사이트 참고(<a href="https://vuejs.org" rel="external nofollow noopener noreferrer" target="_blank">https://vuejs.org</a>)</li><li>Vue.js 사용자 커뮤니티</li><li>Vue.js 포럼 : Vue.js 를 사용하다가 발생하는 트러블이나 질문 사항을 논의하는 사이트</li><li>Vue Land : Vue.js 사용자와 코어 팀 멤버 및 컨트리뷰터가 채팅을 커뮤니케이션 하는 커뮤니티</li><li>Vue.js 밋업 : 한국 Vue.js 사용자들이 Vue.js 지식과 정보를 공유하는 밋업 이벤트</li></ul>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/11/08/Vue-study-1.1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1. 프로그레시브 프레임워크 Vue.js - part 1</title>
      <link>http://mishka86.github.io/2019/11/08/Vue-study-1/</link>
      <guid>http://mishka86.github.io/2019/11/08/Vue-study-1/</guid>
      <pubDate>Fri, 08 Nov 2019 08:48:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;Vue.js 철저입문&lt;/strong&gt; 책을 읽으면서 간단하게 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;Vue.js는 &lt;strong&gt;뷰 레이어에 특화&lt;/strong&gt;된 라이브러리이다. &lt;strong&gt;MVVM패턴&lt;/strong&gt;의 영향을 받은 설계를 채택하고 있어서 대규모 애플리케이션 개발에도 사용할 수 있습니다. 이러한 특징은 애플리케이션의 규모와 상관없이 어떠한 경우에도 단계적으로 유연한 적용이 가능해지는 &lt;code&gt;프로그래시브 프레임워크&lt;/code&gt;라는 Vue.js의 설계사상에서 기인한다고 한다. 이 설계사상으로 인해 프로젝트 초기에는 최소한의 학습비용만으로 시험 적용이 가능하며 대규모 시스템에서는 단계적으로 필요한 기능및 라이브러리를 조합해 덧붙여 가는 독특한 스타일의 개발이 가능하다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>Vue.js 철저입문</strong> 책을 읽으면서 간단하게 정리해 보고자 한다.</p><p>Vue.js는 <strong>뷰 레이어에 특화</strong>된 라이브러리이다. <strong>MVVM패턴</strong>의 영향을 받은 설계를 채택하고 있어서 대규모 애플리케이션 개발에도 사용할 수 있습니다. 이러한 특징은 애플리케이션의 규모와 상관없이 어떠한 경우에도 단계적으로 유연한 적용이 가능해지는 <code>프로그래시브 프레임워크</code>라는 Vue.js의 설계사상에서 기인한다고 한다. 이 설계사상으로 인해 프로젝트 초기에는 최소한의 학습비용만으로 시험 적용이 가능하며 대규모 시스템에서는 단계적으로 필요한 기능및 라이브러리를 조합해 덧붙여 가는 독특한 스타일의 개발이 가능하다.</p><a id="more"></a><h2 id="Vue-js의-역사"><a href="#Vue-js의-역사" class="headerlink" title="Vue.js의 역사"></a>Vue.js의 역사</h2><p>Vue.js는 2013년 <code>에반유(Evan You)</code>가 시작한 개인 프로젝트로 출발</p><blockquote><ul><li>2014년 2월 <strong>V0.8</strong>이 정식발표</li><li>2015년 5월에 PHP웹 애플리케이션 프레임워크인 <strong>라라벨</strong>에 표준 탑재된 것을 계기로 라라벨 커뮤니티에서 화제</li><li>2015년 10월 <strong>V1.0</strong>이 출시</li><li>2016년 10월 1일 <strong>V2.0</strong>이 출시</li></ul></blockquote><h2 id="복잡해진-모던-웹-프론트엔드-개발"><a href="#복잡해진-모던-웹-프론트엔드-개발" class="headerlink" title="복잡해진 모던 웹 프론트엔드 개발"></a>복잡해진 모던 웹 프론트엔드 개발</h2><p>모던 웹 프로트엔드 개발은 크게 고도화 되고 <code>단일 페이지 애플리케이션(SPA)</code>을 중심으로 프런트엔드 에서 복잡한 처리를 맡는 경우가 늘었으며 애플리케이션 데이터플로 설계, 라우팅, 유효성 체크 등 기존에는 백 엔드에서 맡았던 역할을 프런트 엔드가 맡게 됐다. 자바스크립트 역시 최근 몇년 사이 용도가 급격히 늘어났다. 이와 함께 업무와 관련된 개념과 도구가 함께 복잡해지는 경향을 보였다.</p><h2 id="웹-탄생과-웹-기반-시스템의-발전"><a href="#웹-탄생과-웹-기반-시스템의-발전" class="headerlink" title="웹 탄생과 웹 기반 시스템의 발전"></a>웹 탄생과 웹 기반 시스템의 발전</h2><p>웹(World Wide Web)은 지금부터 20년도 더 전인 <strong>1991년</strong>에 인터넷상에 처음 등장. 탄생 초기에는 문서 열람만을 목적으로 했으므로 당연히 지금 사용하는 SNS나 스프레드시트 같은 인터렉티브한 콘텐츠 는 구현이 불가능 했다. 1990년 후반부터 CSS와 자바스크립트가 웹 브라우저에 탑재됐다. 당시의 자바스크립트는 매우 빈약해 CSS와 함께 문서를 꾸미는 용도에 주로 사용 됐다. 비록 제약은 많았지만. 이들의 등장으로 웹페이지를 GUI 애플리케이션처럼 꾸밀 수 있게 됐다.</p><ul><li>CGI(Common Gateway Interface)로 대표되는 웹에서 사용되는 서버 사이드 프로그래밍 기술이 등장</li><li>웹 브라우저를 프리젠테이션 계층으로 삼는 웹기반 3계층 아키텍처 시스템이 등장</li><li>루비 온 레이즈로 대표되는 MVC기반 웹애플리케이션 프레임워크도 등장</li></ul><p>당시 프런트엔드가 담당했던 기능은 css등을 이용한 시작적효과와 자바스크립트를 이용한 알림창, 입력을 받는 기능 정도가 고작이었다.</p><h2 id="Ajax의-등장"><a href="#Ajax의-등장" class="headerlink" title="Ajax의 등장"></a>Ajax의 등장</h2><p>프런트엔드의 기능은 보여주는 것에만 한정된다는 것이 상식이었던 적이 있다. 그러나 2005년에 구글이 지도 서비스 구글맵스를 출시하면서 이러한 상식이 뒤집어졌다. 같은 페이지 안에서 콘텐츠를 빠르고 인터랙티브하게 변화시키는 경쾌한 사용자 경험이 <strong>Ajax</strong>를 통해 가능해졌다. Ajax 의 등장 이후 클라이언트 사이드에서는 Ajax및 이를 이용한 DOM을 정교하게 조작하는 기능이 필요해졌다.</p><ul><li>필요에 따라 등장한 <strong>jQuery</strong>등이 인기를 얻었다.</li><li>서버사이드 분야는 웹서버가 HTML 렌더링을 넘어 <strong>RESTful 기반</strong> 웹API 를 제공하게 됐다.</li><li>2000년대 말에는 <strong>HTML5</strong>와 <strong>ECMAScript</strong>를 중심으로 웹이 다시 크게 진화</li><li><strong>Node.js</strong>가 등장하면서 웹프런트엔드 개발이 한층 복잡해졌다.</li></ul><h2 id="HTML5의-등장"><a href="#HTML5의-등장" class="headerlink" title="HTML5의 등장"></a>HTML5의 등장</h2><p>HTML5는 2014년에 권고안이 나온 표준규격이다.<br>그중 중요한 것은 <code>Histrory API</code> 인데 덕분에 페이지이동을 웹브라우저대신 자바스크립트로 핸들링할 수 있게 됐다. 이를 통해 화면이동없이 URL과 히스토리를 관리하며 전환할 수 있는 단일 페이지 애플리케이션을 만들수 있게 됐다. 이러한 변화에 따라 프리젠테이션 레이어의 프로그램이 서버사이드 에서 클라이언트 사이드로 옮겨오게 된다. 기존에는 HTML렌더링을 서버에서 수행했지만, 웹 API로 데이터를 받아올수 있게 되면서 클라이언트에서도 HTML 렌더링이 가능해졌기 때문이다. 이런 방식이 화면이동이 적기 때문에 더 뛰어난 사용자 경험을 제공할 수 있다.</p><h2 id="Node-js-와-자바스크립트-생태계의-진화"><a href="#Node-js-와-자바스크립트-생태계의-진화" class="headerlink" title="Node.js 와 자바스크립트 생태계의 진화"></a>Node.js 와 자바스크립트 생태계의 진화</h2><p>2009년 에는 <strong>Node.js</strong> 가 등장</p><ul><li>첫번째 변화는 자바스크립트 실행환경이 브라우저를 벗어난 것이다. Node.js 는 프런트엔드 개발과 테스트에 매우 유용한 환경이다.</li><li>두번째 변화는 패키지 관리자이자 패키지 리포지토리인 <strong>npm</strong>의 보급이다.</li></ul><p>이에 따라 모듈(패키지)을 사용할수 있게 됐고 개발된 산출물을 다시 모듈화해 npm을 통해 배포하는 문화가 정착했다.</p><h2 id="ES2015-와-프로그래밍-언어로서의-진화"><a href="#ES2015-와-프로그래밍-언어로서의-진화" class="headerlink" title="ES2015 와 프로그래밍 언어로서의 진화"></a>ES2015 와 프로그래밍 언어로서의 진화</h2><p>웹 프런트엔드 개발이 고도화되던 와중에 문제가 된것이 자바스크립트의 빈약한 언어 기능이었다. 그래서 대대적인 규격 업데이트가 필요 했고 이에 <code>ES2015(ES6)</code> 가 등장했다.<br>ES2015 는 자바스크립트 역사상 가장 큰 규모의 업데이트였다. 문법이 확장되고 <code>const</code>나 <code>let</code>등이 널리 쓰이게 되는 등 작성스타일에도 대대적인 변화가 있었다. 표준규격이 제안 됐다고 해서 곧바로 모든 브라우저에 구현이 적용되지는 않는다. 그러나 새로운 규격에는 기존의 불만을 해소할수 잇는 매력적인 것들이 많았고 그래서 이러한 규격을 브라우저에 구현해 사용하려는 움직임이 있었다.<br><strong>Babel</strong> 은 이러한 수요에 대응해 자바스크립트를 자바스크립트로 번역하는 컴파일러다. 차세대 문법을 따른 자바스크립트 코드를 아직 해당 규격이 구현되지 않은 브라우저에서 사용할 수 있는 자바스크립트 코드로 변화하는 것이다.</p><h2 id="React등-프런트엔드-라이브러리의-출현"><a href="#React등-프런트엔드-라이브러리의-출현" class="headerlink" title="React등 프런트엔드 라이브러리의 출현"></a>React등 프런트엔드 라이브러리의 출현</h2><p>애플리케이션 데이터플로를 프런트엔드로 가져오는 등 설계 단계부터 개발 난이도를 상승시키는 것이 많았다. DOM을 웹 API와 연동시키는 것도 생각 없이 할수 있는 일이 아니다.<br>애플리케이션을 구조화 할수 없는 jQury등을 사용해서는 구현하기가 어렵다 그러므로 MVC와 같은 애플리케이션구조를 지원하는 프레임워크가 필요해졌다. 그에따라 <strong>Backbone.js</strong>, <strong>AngularJS</strong>등 새로운 웹 애플리케이션 프레임워크 및 라이브러리가 속속 나타났다. 이런 상황에서 나타난 것이 페이스북이 개발한 <strong>React</strong>와 <strong>Flux</strong> 다.<br><code>React</code>는 뷰 라이브러리이고, <code>Flux</code>는 애플리케이션 아키텍처다. React 중심의 개발 스타일은 <strong>가상 DOM</strong>을 이용해 DOM 조작을 빠르게 수행했고, Flux 는 혼란스러워지기 쉬운 아케텍처에 방향을 제시해 큰 인기를 모았다.</p><h2 id="현재-당면과제와-Vue-js"><a href="#현재-당면과제와-Vue-js" class="headerlink" title="현재 당면과제와 Vue.js"></a>현재 당면과제와 Vue.js</h2><p>모던 프런트 엔드 개발은 현재에 이르기까지 다음과 같은 변화와 새로운 문제점을 낳았다.</p><ul><li>HTML5 이후 웹이 애플리케이션 플랫폼으로 기능하게 되면서 API가 고도화 됨</li><li>Node.js 생태계의 발전과 개발 환경 구축의 난이도 증가</li><li>ES2015 이후 문법이 보강되면서 학습할 내용이 증가</li><li>React 이후 프런트 엔드 개발이 프레임워크화되면서 그에 따른 학습비용증가</li></ul><p>정리하다보니 모던 프론트엔드 개발의 역사와 같이 나와있어서 생각보다 정리해야될 내용이 많았다.<br>그래서 2파트로 나누어서 정리하기로 했다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/11/08/Vue-study-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Github SSH key 생성 및 적용하기</title>
      <link>http://mishka86.github.io/2019/10/18/ssh-setting/</link>
      <guid>http://mishka86.github.io/2019/10/18/ssh-setting/</guid>
      <pubDate>Fri, 18 Oct 2019 06:56:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;많은 Git 서버들은 SSH 공개키로 인증을 합니다. 또한 Github 연결시마다 계정정보를 입력해야 하는 번거로운을 제거해 준다. 이번에 입사한 회사에서도 서버에서 SSH를 사용해서 인증하는 시스템을 가지고 있어서 이 기회에 세팅을하면서 적용방법을 정리해 보았다.&lt;/p&gt;
&lt;h2 id=&quot;SSH-공개키-생성&quot;&gt;&lt;a href=&quot;#SSH-공개키-생성&quot; class=&quot;headerlink&quot; title=&quot;SSH 공개키 생성&quot;&gt;&lt;/a&gt;SSH 공개키 생성&lt;/h2&gt;&lt;p&gt;일단 공개키를 사용하려면 공개키를 만들어야 한다. 그 전에 공개키가 있는지 확인이 필요하다. 기본적으로 사용자의 SSH키들은 사용자의 &lt;code&gt;~/.ssh&lt;/code&gt; 디텍토리에 저장한다. 디텍토리의 파일을 살펴서 공개키가 있는지 확인 할 수 있다. &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>많은 Git 서버들은 SSH 공개키로 인증을 합니다. 또한 Github 연결시마다 계정정보를 입력해야 하는 번거로운을 제거해 준다. 이번에 입사한 회사에서도 서버에서 SSH를 사용해서 인증하는 시스템을 가지고 있어서 이 기회에 세팅을하면서 적용방법을 정리해 보았다.</p><h2 id="SSH-공개키-생성"><a href="#SSH-공개키-생성" class="headerlink" title="SSH 공개키 생성"></a>SSH 공개키 생성</h2><p>일단 공개키를 사용하려면 공개키를 만들어야 한다. 그 전에 공개키가 있는지 확인이 필요하다. 기본적으로 사용자의 SSH키들은 사용자의 <code>~/.ssh</code> 디텍토리에 저장한다. 디텍토리의 파일을 살펴서 공개키가 있는지 확인 할 수 있다. </p><a id="more"></a><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">cd</span> ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>보통 <code>id_dsa</code>나 <code>id_rsa</code>라고 되어 있다. 그 중 <code>.pub</code> 파일이 <strong>공개키</strong>이고 다른 파일은 <strong>개인키</strong> 입니다.<br>이 파일이 없거나 .ssh 디텍토리가 없으면 <code>ssh-keygen</code> 프로그램으로 키를 생성하여 준다.</p><h3 id="터미널-실행하여-다음-명령어를-실행"><a href="#터미널-실행하여-다음-명령어를-실행" class="headerlink" title="터미널 실행하여 다음 명령어를 실행"></a>터미널 실행하여 다음 명령어를 실행</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>적은 이메일을 레이블로 사용해서 새 SSH 키를 작성한다는 메세지가 출력됩니다.(아래와 같은 메세지가 나온다면 성공입니다.)</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Generating public/private rsa key pair.</span><br></pre></td></tr></table></figure><h3 id="SSH-Key-저장위치-설정"><a href="#SSH-Key-저장위치-설정" class="headerlink" title="SSH Key 저장위치 설정"></a>SSH Key 저장위치 설정</h3><p>“키를 저정할 파일을 입력하십시오” 라는 프로프트가 표시되면 Enter를 누르십시오.(기본위치로 지정)</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Enter a file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><h3 id="SSH-Key-비밀번호-설정"><a href="#SSH-Key-비밀번호-설정" class="headerlink" title="SSH Key 비밀번호 설정"></a>SSH Key 비밀번호 설정</h3><p>비밀번호 없이 설정할경우 엔터 두번을 눌러주면된다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): [Type a passphrase]</span><br><span class="line">&gt; Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><h2 id="SSH-Key-등록"><a href="#SSH-Key-등록" class="headerlink" title="SSH Key 등록"></a>SSH Key 등록</h2><p>생성한 SSH Key를 등록해 봅시다</p><h3 id="터미널을-실행하여-아래-명령어를-실행하여-백그라운드에서-ssh-agent를-시작"><a href="#터미널을-실행하여-아래-명령어를-실행하여-백그라운드에서-ssh-agent를-시작" class="headerlink" title="터미널을 실행하여 아래 명령어를 실행하여 백그라운드에서 ssh-agent를 시작"></a>터미널을 실행하여 아래 명령어를 실행하여 백그라운드에서 ssh-agent를 시작</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">eval</span> <span class="hljs-string">"<span class="hljs-variable">$(ssh-agent -s)</span>"</span></span><br><span class="line">&gt; Agent pid 59566</span><br></pre></td></tr></table></figure><h3 id="ssh의-config-파일에-아래-text를-입력"><a href="#ssh의-config-파일에-아래-text를-입력" class="headerlink" title="ssh의 config 파일에 아래 text를 입력"></a>ssh의 config 파일에 아래 text를 입력</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.ssh/config</span><br></pre></td></tr></table></figure><blockquote><p>Host * AddKeysToAgent yes<br> UseKeychain yes<br> IdentityFile ~/.ssh/id_rsa</p></blockquote><h3 id="아래-명령어를-입력하여-SSH-Key-값을-ssh-agent에-추가"><a href="#아래-명령어를-입력하여-SSH-Key-값을-ssh-agent에-추가" class="headerlink" title="아래 명령어를 입력하여 SSH Key 값을 ssh-agent에 추가"></a>아래 명령어를 입력하여 SSH Key 값을 ssh-agent에 추가</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><h2 id="SSH-Key를-Github-계정에-추가"><a href="#SSH-Key를-Github-계정에-추가" class="headerlink" title="SSH Key를 Github 계정에 추가"></a>SSH Key를 Github 계정에 추가</h2><p>Github 로그인후 우측상단 메뉴에서 <code>Setting</code>을 클릭<br><img src="/img/github-setting.png" width="200px"></p><p>좌측의 <strong>Personal settings</strong> 메뉴 중에 <code>SSH and GPG keys</code> 클릭<br><img src="/img/personal-setting.png" width="200px"></p><p><code>New SSH Key</code>를 눌러서 Title과 Key를 입력후 <code>Add SSH Key</code> 버튼을 눌러준다.</p><p>Key 에는 아래명령어를 사용해서 .pub 의 공개키를 입력해 준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><blockquote><p><strong>id_rsa.pub 예시</strong><br>ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU<br>GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3<br>Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA<br>t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En<br>mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx<br>NrRFi9wrf+M7Q== <a href="mailto:schacon@agadorlaptop.local" rel="external nofollow noopener noreferrer" target="_blank">schacon@agadorlaptop.local</a></p></blockquote><p>Github SSH key 생성 및 적용하기를 해보았다. Github 연결시 계정정보를 입력해야 하는 번거로움에서 해방돠었다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/10/18/ssh-setting/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mac os에 zsh 세팅하기</title>
      <link>http://mishka86.github.io/2019/09/27/zsh-setting/</link>
      <guid>http://mishka86.github.io/2019/09/27/zsh-setting/</guid>
      <pubDate>Fri, 27 Sep 2019 00:58:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번에 직장을 옮기면서 맥북 유저로 돌아왔다. 퍼블리싱작업을 할때는 별로 신경쓰지 않았던 작업환경들이 개발을 하게되고 맥북을 가지면서 조금더 편한 것들을 찾게 되었다. 그중에 하나로 &lt;code&gt;zsh&lt;/code&gt;을 적용해 보았다.&lt;/p&gt;
&lt;h2 id=&quot;ZSH-란&quot;&gt;&lt;a href=&quot;#ZSH-란&quot; class=&quot;headerlink&quot; title=&quot;ZSH 란?&quot;&gt;&lt;/a&gt;ZSH 란?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Z 셸(Z shell, zsh)&lt;/strong&gt;은 상호작용 로그인 셸이자 셸 스크립트를 위한 강력한 명령 줄 &lt;strong&gt;인터프리터&lt;/strong&gt;로 사용할 수 있는 유닉스 셸이다.&lt;br&gt;&lt;strong&gt;Zsh&lt;/strong&gt;는 bash, ksh, tcsh의 일부 기능을 포함하여 수많은 개선 사항이 갖추어진 &lt;strong&gt;확장형 본 셸&lt;/strong&gt;이다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/Z_%EC%85%B8&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;위키백과&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번에 직장을 옮기면서 맥북 유저로 돌아왔다. 퍼블리싱작업을 할때는 별로 신경쓰지 않았던 작업환경들이 개발을 하게되고 맥북을 가지면서 조금더 편한 것들을 찾게 되었다. 그중에 하나로 <code>zsh</code>을 적용해 보았다.</p><h2 id="ZSH-란"><a href="#ZSH-란" class="headerlink" title="ZSH 란?"></a>ZSH 란?</h2><blockquote><p><strong>Z 셸(Z shell, zsh)</strong>은 상호작용 로그인 셸이자 셸 스크립트를 위한 강력한 명령 줄 <strong>인터프리터</strong>로 사용할 수 있는 유닉스 셸이다.<br><strong>Zsh</strong>는 bash, ksh, tcsh의 일부 기능을 포함하여 수많은 개선 사항이 갖추어진 <strong>확장형 본 셸</strong>이다. <a href="https://ko.wikipedia.org/wiki/Z_%EC%85%B8" rel="external nofollow noopener noreferrer" target="_blank">위키백과</a></p></blockquote><a id="more"></a><h2 id="ZSH-기능-살펴보기"><a href="#ZSH-기능-살펴보기" class="headerlink" title="ZSH 기능 살펴보기"></a>ZSH 기능 살펴보기</h2><ul><li>경로 자동 추론</li><li>타이핑 교정</li><li>명령어 추천</li><li>다양한 플러그인</li><li>이쁜 디자인이 핵심이다 ㅋㅋㅋ</li></ul><p>개발속도를 올려줄 수 있는 간편한 기능들이 많이 있다. </p><h2 id="ZSH-설치"><a href="#ZSH-설치" class="headerlink" title="ZSH 설치"></a>ZSH 설치</h2><p>본격적으로 ZSH를 설치 해보자<br>먼저 macOS 용 패키지 관리자인 <code>Homebrew</code>를 설치한다.<br>설치방법은 <a href="https://brew.sh/index_ko" rel="external nofollow noopener noreferrer" target="_blank">Homebrew 사이트</a>에 자세히 나와있으니 이번 포스팅에서는 생략한다.</p><p>먼저 아래 명령으로 zsh 가 설치되어있나 확인작업을 해준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zsh --version</span><br><span class="line">zsh 5.7.1</span><br></pre></td></tr></table></figure><p>설치되어 있지 않다면 아래의 명령으로 설치를 해준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh</span><br></pre></td></tr></table></figure><p>설치가 끝났다면 기본 쉘을 chsh을 사용하여 변경해준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s `<span class="hljs-built_in">which</span> zsh`</span><br></pre></td></tr></table></figure><h2 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h2><p><a href="https://ohmyz.sh/" rel="external nofollow noopener noreferrer" target="_blank">Oh My Zsh</a>는 ZSH 구성 관리를 위한 오픈 소스 커뮤니티 중심 프레임 워크 입니다. 여기에는 수천가지의 유용한 기능, 도우미, 플러그인, 테마 및 몇가지 소리가 제공됩니다. </p><figure class="highlight bash hljs"><figcaption><span>curl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh -c <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash hljs"><figcaption><span>wget</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="hljs-string">"<span class="hljs-variable">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure><p>ZSH 설치가 완료되었다. 이렇게만 설치하고 사용하여도 상관없지만 이왕 설치한 김에 몇가지 편리한 기능들을 추가로 세팅해보기로 했다.</p><h2 id="iTerm2-설치"><a href="#iTerm2-설치" class="headerlink" title="iTerm2 설치"></a>iTerm2 설치</h2><p><a href="https://www.iterm2.com/" rel="external nofollow noopener noreferrer" target="_blank">iTerm2</a>는 터미널의 부족한 기능들을 보안해주는 <code>터미널 에뮬레이터</code>이다. iTerm2에서 제공하는 많은 기능들 중에 유용한 기능들은 아래와 같다.</p><blockquote><ul><li>자동완성 기능 (Cmd + ;)</li><li>터미널 분할 창 기능 (Split Panes)</li><li>터미널 내에서 찾기 기능</li><li>마우스 없이 복사와 붙여넣기</li><li>더 많은 기능 살펴보기 : <a href="https://www.iterm2.com/features.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.iterm2.com/features.html</a></li></ul></blockquote><p>iTerm2 설치는 <a href="https://www.iterm2.com/" rel="external nofollow noopener noreferrer" target="_blank">iTerm2홈페이지</a>에서 다운로드 받은 후에 프로그램을 어플리케이션으로 옮겨주기만 하면된다.</p><h2 id="iTerm2-테마설치-선택"><a href="#iTerm2-테마설치-선택" class="headerlink" title="iTerm2 테마설치(선택)"></a>iTerm2 테마설치(선택)</h2><p><a href="https://github.com/mbadolato/iTerm2-Color-Schemes#installation-instructions" rel="external nofollow noopener noreferrer" target="_blank">iTerm Color Schemes</a>에 접속하여 컬러 스킨을 다운로드 받는다.<br>다운을 받으면 iTerm2를 실행하여 <code>cmd + ,</code>를 눌러서 환경설정 창을 띄워준다. Profile &gt; colors 메뉴에 들어가서 <code>Color Presets</code>를 눌러서 하단의 imports를 누른다. 다운로드 받은 폴더 schemes의 테마 중 원하는 테마를 선택한다.(취향존중)</p><h2 id="ZSH-테마-설치"><a href="#ZSH-테마-설치" class="headerlink" title="ZSH 테마 설치"></a>ZSH 테마 설치</h2><p>많은 테마들 중에 필자는 <a href="https://github.com/denysdovhan/spaceship-prompt" rel="external nofollow noopener noreferrer" target="_blank"><strong>Spaceship ZSH</strong></a> 테마를 설치해 보았다.</p><p>아래 명령어를 사용해서 설치를 진행한다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 복사</span></span><br><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/denysdovhan/spaceship-prompt.git <span class="hljs-string">"<span class="hljs-variable">$ZSH_CUSTOM</span>/themes/spaceship-prompt"</span></span><br><span class="line"><span class="hljs-comment"># 심볼릭링크(심볼릭 링크는 원본파일을 가리키도록 링크만 시켜둔 것 - 윈도우의 바로가기)</span></span><br><span class="line">ln -s <span class="hljs-string">"<span class="hljs-variable">$ZSH_CUSTOM</span>/themes/spaceship-prompt/spaceship.zsh-theme"</span> <span class="hljs-string">"<span class="hljs-variable">$ZSH_CUSTOM</span>/themes/spaceship.zsh-theme"</span></span><br></pre></td></tr></table></figure><p><strong>.zshrc</strong> 파일에서 <strong>ZSH_THEME</strong> 내용을 변경해준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br><span class="line">또는 open ~/.zshrc</span><br></pre></td></tr></table></figure><p>해당 내용을 실행</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>이렇게 테마 적용시 폰트가 깨져서 원하던 모습을 볼수 없을 경우 폰트 설치를 진행하여 준다.</p><h2 id="Powerline-fonts-설치"><a href="#Powerline-fonts-설치" class="headerlink" title="Powerline fonts 설치"></a>Powerline fonts 설치</h2><p>자세한 설치 방법은 <a href="https://github.com/powerline/fonts" rel="external nofollow noopener noreferrer" target="_blank">Powerline fonts</a>을 참고 하기 바라며 간단한 설치 방법을 공유 합니다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 복사</span></span><br><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/powerline/fonts.git --depth=1</span><br><span class="line"><span class="hljs-comment"># 설치</span></span><br><span class="line"><span class="hljs-built_in">cd</span> fonts</span><br><span class="line">./install.sh</span><br><span class="line"><span class="hljs-comment"># 지우기</span></span><br><span class="line"><span class="hljs-built_in">cd</span> ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure><p>설치가 완료되면 아까와 같이 iTerm2 에서 설정을 <code>cmd + ,</code>를 눌러 환경설정에서 Profiles &gt; Text 에서 Powerline폰트를 선택주면된다.<br><strong>ZSH</strong>로 터미널과 조금 더 친해져 보자~!!</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/09/27/zsh-setting/#disqus_thread</comments>
    </item>
    
    <item>
      <title>지난 1년6개월의 회고</title>
      <link>http://mishka86.github.io/2019/08/29/Retrospective-20190829/</link>
      <guid>http://mishka86.github.io/2019/08/29/Retrospective-20190829/</guid>
      <pubDate>Thu, 29 Aug 2019 02:44:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번에 정들었던 &lt;strong&gt;&lt;code&gt;(주)라이프스타일프로젝트(이하 LSP)&lt;/code&gt;&lt;/strong&gt; 를 떠나면서 그동안의 회사생활 및 1년6개월 동안의 생활을 회고해보고 달라진 점들을 정리해본다. 사실 지금 글을 쓰고있는 &lt;code&gt;오늘(8월29일)&lt;/code&gt;이 마지막 출근날이다.&lt;/p&gt;
&lt;h2 id=&quot;뜻밖의-연락&quot;&gt;&lt;a href=&quot;#뜻밖의-연락&quot; class=&quot;headerlink&quot; title=&quot;뜻밖의 연락&quot;&gt;&lt;/a&gt;뜻밖의 연락&lt;/h2&gt;&lt;p&gt;현재 다니고있고 곧 퇴사(8월31일부)하게 되는 LSP와의 인연은 &lt;code&gt;2018년 2월&lt;/code&gt;에 시작됐다.&lt;br&gt;그 당시 이직을 준비하고 있는 상태였던 필자는 취업사이트에 이력서를 올려놓고 여러군데에 면접을 보고 있는 상황이었다.&lt;br&gt;그러던중 지금의 회사 인사팀에서 먼저 필자의 이력서를 보고 연락이 왔다. 그당시 회사명은 &lt;code&gt;(주)유앤김파트너스&lt;/code&gt; 였다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번에 정들었던 <strong><code>(주)라이프스타일프로젝트(이하 LSP)</code></strong> 를 떠나면서 그동안의 회사생활 및 1년6개월 동안의 생활을 회고해보고 달라진 점들을 정리해본다. 사실 지금 글을 쓰고있는 <code>오늘(8월29일)</code>이 마지막 출근날이다.</p><h2 id="뜻밖의-연락"><a href="#뜻밖의-연락" class="headerlink" title="뜻밖의 연락"></a>뜻밖의 연락</h2><p>현재 다니고있고 곧 퇴사(8월31일부)하게 되는 LSP와의 인연은 <code>2018년 2월</code>에 시작됐다.<br>그 당시 이직을 준비하고 있는 상태였던 필자는 취업사이트에 이력서를 올려놓고 여러군데에 면접을 보고 있는 상황이었다.<br>그러던중 지금의 회사 인사팀에서 먼저 필자의 이력서를 보고 연락이 왔다. 그당시 회사명은 <code>(주)유앤김파트너스</code> 였다.</p><a id="more"></a><p>그때까지만 해도 이력서를 넣지 않은 곳에서 직접적으로 연락이 온적은 없어서 있단 신기했고 또 그 당시 회사 주력브랜드였던 <code>미프(미남프로젝트)</code>의 제품을 우연히 정글의 법칙에서 김병만이 사용하는 것을 본 후라 그런지 더욱 신기했었다.</p><p>그렇게 면접제의를 받고 면접을 보게 되엇는데 1:3의 면접이었다. 면접관으로는 지금 같이 일하고 있는 팀장님, 인사담당자, 부사장님 이렇게 세분이 들어오셨었다. 몇가지 기술적인 질문이 있었으나 크게 어려운 질문은 없었고 상당히 즐거운 분위기에서 면접은 마무리되었다. 기억나는게 한가지 있는데 면접 마지막에 언제 연락을 줄 수 있냐는 필자의 질문에 회사측에서 필자가 첫번째 면접자라고 시간이 조금 걸릴것 같다고 했는데 그 대답을 듣고 필자가 호기롭게 <code>&quot;첫번째가 가장좋은거 아시죠??&quot;</code>하며 너스레를 떨었던 것이 기억이 난다. ㅎㅎㅎ 지금 생각해도 참….. 그 덕분인지는 모르겠지만 면접 다음날 바로 연락이 왔는데 다른 사람을 추가면접보지 않고 바로 필자를 합격자로 정했다는 연락이었다. 연봉제안도 필자가 제시했던 금액보다 좋은 조건을 제시해주어서 여러가지 망설임이 있었지만 입사를 결정하게 되었다.</p><h2 id="두근두근-첫-출근"><a href="#두근두근-첫-출근" class="headerlink" title="두근두근 첫 출근"></a>두근두근 첫 출근</h2><p>입사는 설이 지나고였다. 명절을 보내고 새로운 마음으로 회사에 첫 출근을 하였다. 부서는 <code>크리에이티브팀</code>이었고, 필자를 제외한 모든 부서원들은 디자이너들이었다. 필자의 업무는 기존에 계시던 분이 인수인계를 해주셨는데, 회사가 원래는 판교에서 지금의 역삼역근터로 이사를 오면서 거리도 멀어지고 건강도 안좋아지셔서 어쩔수 없이 퇴사를 하게 되었다고 하셨다.</p><p>그렇게 인수인계 받은 기존의 사이트는 <code>카페24 쇼핑몰 솔루션</code>을 통해 작업이 되어있었고 대부분이 이미지로 코딩이 되어있는 상태였다. 기존에 계시던분이 원래 디자이너 출신이어서 간단하게 코딩이 이루어져 있었다. 추후에 대대적인 리뉴얼이 이루어졌다.<br>그때까지만 해도 필자는 카페25 쇼핑몰 솔루션은 로그인만 해서 보았던게 전부였고 그 전에 하드코딩을 했었어서 카페25를 통한 코딩에 막연한 두려움을 약간을 가지고 있었으나 기존에 하던것에서 약간의 환경의 변화만 있었을 뿐 어려움 없이 적응 할 수 있었다.<br>또한 인수인계를 해주고 떠나시는 분을 제외하고는 회사에서 코딩 및 개방을 할 수 있는 사람이 한 사람도 없어서 막막하기도 하였다.</p><h2 id="하면된다"><a href="#하면된다" class="headerlink" title="하면된다."></a>하면된다.</h2><p>짧은 인수인계 기간이 끝나고 본격적으로 홀로 업무가 시작되었다.<br>그때 급한 업무를 처음으로 처리했던 기억이 나는데 기존에 계시던 분도 처음하는 일이었도 필자도 처음 듣는 업무여서 약간 당황했덨던 기억이난다. 업무내용은 그 때 당시 미프 모바일 사이트를 패키징하여 어플출시를 앞두고 있었는데 그 어플 출시를 위해서 애플 개발자 등록을 해야하고 결재를 해야되는데 그 단계에서 애플과 메일을 주고받고 전화를 받고 거기에서 받은 인증번호를 다시 입력하고 하는 등의 복잡한 프로세스가 있었는데 전에 계신던 분도 몇번 시도를 하다가 중간에 문제가 생겨서 해결을 못하시고 퇴사를 하시면서 필자에게 넘어왔던 업무였다. 중간에 무엇을 잘못했는지 중간 프로세스에서 막혀있는 상태였고 그렇게 상당한 시간이 흘러서 앱스토어 어플 출시 자체가 기약없이 미뤄지고 있는 상황이었다. 필자도 처음 겪는 업무여서 현재의 상황과 구글링 그리고 앱스토어의 문의를 통해 예상보다 빠르고 쉽게 앱스토어 어플 출시를 이루어낼 수 있었다. 오랜기간 멈춰져있던 업무를 필자가 잘 마무리 해서 입사한 후에 업무에 적응하는데 큰 도움이 되었던 사건이었다.</p><h2 id="일을-하면서"><a href="#일을-하면서" class="headerlink" title="일을 하면서"></a>일을 하면서</h2><p>1년6개월 동안 LSP를 다니면서 많은 것들을 배우고 성장하는 시간이었다. 회사의 기초가 화장품제조 및 판매이다보니 쇼핑몰 사이트의 개발과 운영에 대해 많은 것들을 배우게 되었고 쇼핑몰의 기초가 되는 카페24 쇼핑몰 솔루션에 대한 깊은 이해를 가질수 있었다. 그와 더불어 기존에 다니넌 에이전시와는 다르게 여유시간들을 갖게되어 아무래도 별도의 클라이언트가 있는것이 아니라 자사의 제품들만 다루기 때문에 일정과 같은 부분에서 회사 내부에 사정에 맞게 조율이 가능한 부분이 있었다. 많은 커뮤니티활동과 더불어 학원에도 다닐수 있는 기회가 있었고 스터디에도 참여해서 많은 것들을 배우는 시간을 가질 수 있었다.</p><p>필자는 크리에이티브팀에 소속되어있었다. 암묵적으로 <code>디자인팀</code>으로 불리운다 그 이유는 앞에서 잠깐 언급했듯이 필자를 제외한 모든 팀원이 디자이너로 구성되어있기 때문이었다. 필자도 퍼블려서로 전향하기 이전에는 무대디자인을 하였기에 디자이너들과의 소통 및 협업에는 큰 문제가 없었다. 그리고 화장품회사의 특성(?)상 남자직원들보다는 여자직원들의 비중이 더 높았었는데, 이전 무대일을 할때에도 디자인 관련 부서에서 일했기에 여자직원들이 더 많은 환경이었다보니 자연스레 섞여서 생활을 했었고 그러다보니 커뮤니케이션 같은 부분에서는 전혀 어려움이 없었으나 코딩 및 개발 업무를 알고 있는 사람은 전혀 없어서 어떤한 문제가 생겼을 때 혼자서 해쳐나가야하는 어려움은 늘 존재했었고 같이 문제에 대해 고민해 줄 사람의 필요가 느껴졌었다. 당시 회사 사정상 여러 개발자를 두는것은 무리가 있었고 그러다 보니 배움과 공유에 대한 갈증이 생겼고 자연스럽게 커뮤니티활동과 스터디로 그 갈증을 푸는 계기가 되었다.</p><h2 id="공부-스터디"><a href="#공부-스터디" class="headerlink" title="공부, 스터디"></a>공부, 스터디</h2><p>처음부터 스터디를 시작한 것은 아니었다. 스터디에 대한 정보도 없었고 그러한 것들이 활발히 진행되고 있는 것도 모르는 상황이었다. 그래서 처음에는 익숙한 컴퓨터학원을 통해 부족하다고 생각했던 개발에 대한 부분들의 수업을 듣기 시작했다. 그렇게 몇가지 수업들을 들었으나 만족할 만한 실력향상은 나타나지 않았던것 같다. 그러던중 우연히 <code>&#39;하코사&#39;</code>라는 커뮤니티를 접하게 되었고 스터디들이 활발히 진행되고 있는 것을 알게 되었다. 필자와 같은 고민을 하는 분들이 많이 있었으며 자신의 어려움을 질문하고 답을 얻어가고 함께 공부하는 커뮤니티였다. 그렇게 여러가지 정보를 얻어가던 중에 한 <code>살롱</code>에 참여하게 되었고 그곳에서 들은 이야기들은 지금까지 내가 알고 있던 내용들과는 많이 다른 내용들이었다. ‘프론트엔드개발자가 되어야지’, ‘지금 하고 있는 업무에서 추가적인 것들을 배우면서 커리어를 쌓으면 할 수 있는 걸 거야’ 와 같은 막연한 계획들이 있었는데 그 계획들을 처음부터 다시 생각하게 되는 살롱이었다. </p><blockquote><p>살롱 : 18세기 중반 프랑스에서 지성인과 예술가가 모여 토론을 펼치고 지식을 나누던 사교 모임</p></blockquote><p>살롱에 참여하기 전까지는 프론트엔드 개발자로 전향을 하려면 지금 하던 퍼블리셔 업무에서 추가적으로 약간의 자바스크립트를 배우고 동적인 UI개발을 더 익히면 되겠지 라는 수준이었는데 참여하고 난 후에는 생각이 완전히 바뀌었다. 우선 퍼블리셔와 프론트엔드개발자는 겹치는 부분도 물론 있었지만 근본적으로 다른 직군에 속해 있는 것이라서 추구하는 방향도 다르고 그렇기에 공부해야 하는 방향 자체도 다르다는 것이었다. 대략적으로 퍼블리셔거 보여지는 뷰단에서 UI적인 개발을 주로 한다면 프로트엔드개발자는 프로든단에서 DATA를 다루어 보여지는 뷰단을 선계해 가는 느낌이다. 그렇다보니 접근하는 방식에서부터 차이가 있고 생각하는 방법도 다르게 해야 올바르게 개발자로 거듭날 수 있다는 생각이 들었다. </p><h2 id="책-집필스터디에-참여"><a href="#책-집필스터디에-참여" class="headerlink" title="책 집필스터디에 참여"></a>책 집필스터디에 참여</h2><p>그렇게 살롱다녀와서 거기서 알게된 인연으로 정말 좋은 기회인 책집필을 위한 스터디에 참여하는 기회가 찾아왔다.<br><code>Vue.js</code>에 관한 책을 집할 하면서 그 내용들을 가지고 구현해 보고 스터디였는데 피자는 당시 Vue.js는 당연히 처음접하였고 프레임워크언어자체가 대한 개념 및 개발을 처음 시작하는 단계였다. 그래서인지 스터디에서 배우는 하나하나가 너무나 값진 경험이었다. 처음 배우는 내용들이다보니 질문도 많았고 이것저것 안되는 것들도 그리고 모르는 것들도 많았는데 집필하시는 분들에게는 이부분이 오히려 도움이 많이 되었다고 하셨다. 서로에게 여러가지를 주고 받을수 있는 윈윈이었으니 잘 마무리 되었다. ㅎㅎㅎ 스터디가 끝나고 간단한 메모어플과 게시판어플을 구현해볼수 있었다. 현재는 책은 무시히 출판되었고 필자는 간단하게나마 추천사로 책 한부분에 남을수 있어서 좋았다. 궁금해 하실 분들을 위해 책제목을 남겨본다. 책 제목은 <code>&quot;커피한잔 마시며 끝내는 Vue.js&quot;</code> 이다.</p><p>그렇게 Vue.js 스터디를 끝나마치고 더 배워야 한다는 생각에 git스터디, javajscript스터디에 참여하게 되었고 그러다보니 필자에게 맞는 새로운 스터디를 기획해서 스터디를 진행하게 되었다. 현재는 JS ES6를 중점적으로 스터디를 하고 잇으며 8월 31일에 마지막 스터디 모임을 앞두고 있는 상황이다. 이번 스터디에 함께한 스터디원분들 중 많은 분들이 다음 스터디로 함께 했으면 좋겠다는 의사를 밝혀주셔서 현재는 함께 기획하고 있는 중에 있다.</p><p>이렇게 회사 생활을 하면서 커뮤니티와 많은 스터디들을 통해서 부족한 것들을 채우고 발전해나가는 시간들을 가실 수 있었던 것에 대해서는 긍적적으로 생각한다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지난 1년 6개월 동안 LSP에 지내면서 함께한 모든 분들에게 감사의 인사를 전하고 싶다.<br>비록 더 많은 시간들을 함께 하지는 못하지만 어디에서든지 각자의 몫을 하며 빛나고 있기를 소망한다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/08/29/Retrospective-20190829/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 16. Math</title>
      <link>http://mishka86.github.io/2019/08/17/Learning-JavaScript-chapter16/</link>
      <guid>http://mishka86.github.io/2019/08/17/Learning-JavaScript-chapter16/</guid>
      <pubDate>Fri, 16 Aug 2019 15:20:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;Math 객체는 애플리케이션을 개발하면서 자주 사용하게 될 수학 함수를 담고 있습니다.(전문적인 숫자 분석이 필요하다면 별도의 라이브러리를 찾아야 한다.)&lt;br&gt;자바스크립트의 숫자는 모두 &lt;strong&gt;IEEE 755 64비트 부동소수점 숫자&lt;/strong&gt;이다.&lt;/p&gt;
&lt;h2 id=&quot;숫자-형식&quot;&gt;&lt;a href=&quot;#숫자-형식&quot; class=&quot;headerlink&quot; title=&quot;숫자 형식&quot;&gt;&lt;/a&gt;숫자 형식&lt;/h2&gt;&lt;p&gt;자바스크립트는 다양한 숫자 형식을 지원하지는 못한다. 10진수 형식, 고정 소수점 형식, 지수 형식이 몇가지 있는 정도이다.&lt;br&gt;숫자를 2진수, 8진수, 16진수로 나타낼 수도 있다.&lt;/p&gt;
&lt;p&gt;자바스크립트의 숫자 형식 메서드는 모두 숫자가 아니라 &lt;strong&gt;문자열을 반환&lt;/strong&gt;한다. 해당 형식에 필요한 각종 기호를 온전히 표현하려면 반드시 문자열이어야 하기 때문이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Math 객체는 애플리케이션을 개발하면서 자주 사용하게 될 수학 함수를 담고 있습니다.(전문적인 숫자 분석이 필요하다면 별도의 라이브러리를 찾아야 한다.)<br>자바스크립트의 숫자는 모두 <strong>IEEE 755 64비트 부동소수점 숫자</strong>이다.</p><h2 id="숫자-형식"><a href="#숫자-형식" class="headerlink" title="숫자 형식"></a>숫자 형식</h2><p>자바스크립트는 다양한 숫자 형식을 지원하지는 못한다. 10진수 형식, 고정 소수점 형식, 지수 형식이 몇가지 있는 정도이다.<br>숫자를 2진수, 8진수, 16진수로 나타낼 수도 있다.</p><p>자바스크립트의 숫자 형식 메서드는 모두 숫자가 아니라 <strong>문자열을 반환</strong>한다. 해당 형식에 필요한 각종 기호를 온전히 표현하려면 반드시 문자열이어야 하기 때문이다.</p><a id="more"></a><h3 id="고정-소수점"><a href="#고정-소수점" class="headerlink" title="고정 소수점"></a>고정 소수점</h3><p>소수점 뒤 자리수를 지정하는 형식을 원한다면 <code>toFixed()</code>를 사용</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-number">19.51</span>;</span><br><span class="line">x.toFixed(<span class="hljs-number">3</span>)   <span class="hljs-comment">// "19.510"</span></span><br><span class="line">x.toFixed(<span class="hljs-number">2</span>)   <span class="hljs-comment">// "19.51"</span></span><br><span class="line">x.toFixed(<span class="hljs-number">0</span>)   <span class="hljs-comment">// "20"</span></span><br></pre></td></tr></table></figure><p>숫자는 버림이 아니라 반올림으로 나타난다.</p><h3 id="지수-표기법"><a href="#지수-표기법" class="headerlink" title="지수 표기법"></a>지수 표기법</h3><p>지수 표기법이 필요할 때는 <code>toExponential()</code>을 사용<br>toFixed()와 마찬가지로 반올림한 결과가 출력. 매개변수로 넘긴 정밀도에 따라 소수점 쥐의 숫자가 몇 개 나타날지 정해진다.</p><h3 id="고정-전체-자리수"><a href="#고정-전체-자리수" class="headerlink" title="고정 전체 자리수"></a>고정 전체 자리수</h3><p>소수점이 어디 나타나는 관계없이 숫자 몇 개로 표현하느냐가 중요하다면 <code>toPrecision()</code>을 사용<br>출력 결과는 반올림된 숫자이며 전체 자리수는 매개변수로 넘긴 자릿수와 일치</p><h3 id="다른-진수"><a href="#다른-진수" class="headerlink" title="다른 진수"></a>다른 진수</h3><p>2진수나 8진수, 16 진수 표현을 원한다면 <code>toString()</code>에 기수를 매개변수로 쓰면 된다.</p><h3 id="고급-숫자-형식"><a href="#고급-숫자-형식" class="headerlink" title="고급 숫자 형식"></a>고급 숫자 형식</h3><p>다양한 형식으로 숫자를 표시해야 한다면 한계에 부딪힌다.</p><blockquote><p>수천자리의 아주 큰 숫자<br>괄호를 쓰는 등, 음수 표현을 다르게 해야하는 경우<br>공학 표기법<br>milli-, micro-, kilo-, mega- 등의 SI 접두사가 필요한 경우</p></blockquote><p>위와같은 경우 Numeral.js를 사용하는 것을 권한다.</p><h2 id="상수"><a href="#상수" class="headerlink" title="상수"></a>상수</h2><p>Math 객체에는 몇 가지 중요한 상수가 프로퍼티로 내장돼 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.E    <span class="hljs-comment">//자연로그의 밑수</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.PI   <span class="hljs-comment">//원주율</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Math</span>.SQRT1_2    <span class="hljs-comment">//1/2의 제곱근</span></span><br><span class="line"></span><br><span class="line">etc</span><br></pre></td></tr></table></figure><h2 id="대수-함수"><a href="#대수-함수" class="headerlink" title="대수 함수"></a>대수 함수</h2><h3 id="거듭제곱"><a href="#거듭제곱" class="headerlink" title="거듭제곱"></a>거듭제곱</h3><p>제곱 관련 기본 함수는 <code>Math.pow</code>이며 제곱근, 세제곱근,e의 거듭제곱 등 자주 쓰이는 연산에는 간편 함수가 있습니다.</p><h2 id="로그-함수"><a href="#로그-함수" class="headerlink" title="로그 함수"></a>로그 함수</h2><p>자연로그 함수는 <code>Math.log</code></p><h2 id="기타-함수"><a href="#기타-함수" class="headerlink" title="기타 함수"></a>기타 함수</h2><h2 id="의사-난수-생성"><a href="#의사-난수-생성" class="headerlink" title="의사 난수 생성"></a>의사 난수 생성</h2><p>자바스크립트에서 의사 난수를 생성할 때는 <code>Math.random()</code>을 사용합니다. 이 함수는 0이상 1 미만의 숫자를 반환합니다.</p><h2 id="삼각함수-쌍곡선함수"><a href="#삼각함수-쌍곡선함수" class="headerlink" title="삼각함수, 쌍곡선함수"></a>삼각함수, 쌍곡선함수</h2>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/08/17/Learning-JavaScript-chapter16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 15. 날짜와 시간</title>
      <link>http://mishka86.github.io/2019/08/16/Learning-JavaScript-chapter15/</link>
      <guid>http://mishka86.github.io/2019/08/16/Learning-JavaScript-chapter15/</guid>
      <pubDate>Fri, 16 Aug 2019 14:41:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;자바스크립트의 Date객체는 원래 넷스케이프 프로그래머 캔스미스가 만들었는데, 사실 자바의 java.util.Date을 가져온 것이다. 세계는 타임존으로 나뉘어 있습니다. 타임존은 모두 &lt;strong&gt;UTC(Coordinated Universal Time)&lt;/strong&gt;를 기준으로 한 시차로 나뉩니다.&lt;br&gt;UTC는 때때로 그리니치 표준시, 즉 &lt;strong&gt;GMT(Greenwich Mean Time)&lt;/strong&gt;라고 불리기도 합니다.&lt;/p&gt;
&lt;p&gt;자바스크립트에서 Date 인스턴스는 모두 유닉스 시간 원점으로 부터 몇 밀리초가 지났는지 나타내는 숫자입니다.&lt;br&gt;자바스크립트는 보통 이 숫자를 사람이 읽기 편한 그리고리력 날짜로 변환합니다. 숫자형 표현이 필요하면 &lt;code&gt;valueOf()&lt;/code&gt; 메서드를 쓰면됩니다.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; d = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.lod(d);              &lt;span class=&quot;hljs-comment&quot;&gt;//타임존이 들어간 그레고리력 날짜&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(d.valueOf());    &lt;span class=&quot;hljs-comment&quot;&gt;//유닉스 타임스탬프&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>자바스크립트의 Date객체는 원래 넷스케이프 프로그래머 캔스미스가 만들었는데, 사실 자바의 java.util.Date을 가져온 것이다. 세계는 타임존으로 나뉘어 있습니다. 타임존은 모두 <strong>UTC(Coordinated Universal Time)</strong>를 기준으로 한 시차로 나뉩니다.<br>UTC는 때때로 그리니치 표준시, 즉 <strong>GMT(Greenwich Mean Time)</strong>라고 불리기도 합니다.</p><p>자바스크립트에서 Date 인스턴스는 모두 유닉스 시간 원점으로 부터 몇 밀리초가 지났는지 나타내는 숫자입니다.<br>자바스크립트는 보통 이 숫자를 사람이 읽기 편한 그리고리력 날짜로 변환합니다. 숫자형 표현이 필요하면 <code>valueOf()</code> 메서드를 쓰면됩니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br><span class="line"><span class="hljs-built_in">console</span>.lod(d);              <span class="hljs-comment">//타임존이 들어간 그레고리력 날짜</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(d.valueOf());    <span class="hljs-comment">//유닉스 타임스탬프</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Date-객체-만들기"><a href="#Date-객체-만들기" class="headerlink" title="Date 객체 만들기"></a>Date 객체 만들기</h2><p>Date 객체는 네 가지 방법으로 만들 수 있습니다.</p><blockquote><p>매개변수 없이 호출하면 현재 날짜에 해당하는 Date 객체를 반환<br>문자열을 제공하면 자바스크립트는 그 문자열을 해석해서 그에 맞는 날짜를 반환<br>숫자를 넣으면 유닉스 타임스탬프로 해석<br>타임스탬프로 입력하는 방법</p></blockquote><h2 id="Moment-js"><a href="#Moment-js" class="headerlink" title="Moment.js"></a>Moment.js</h2><p>Moment.js에는 타임존을 지원하는 버전과 지원하지 않는 버전 두 가지가 있습니다.</p><p>CDN을 통한 사용</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.4.0/moment-timezone.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>노드를 사용할 때는 npm install –save moment-timezone 명령으로 Moment.js를 설치하고 require 명령으로 스크립트를 불러올 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> moment = reqire(<span class="hljs-string">'moment-timezone'</span>);</span><br></pre></td></tr></table></figure><h2 id="날짜-형식"><a href="#날짜-형식" class="headerlink" title="날짜 형식"></a>날짜 형식</h2><p>Moment.js 의 format 메서드를 써서 날짜를 원하는 형식으로 만들 수 있습니다.<br>자세한 사항은 Moment.js 온라인 문서를 참고 합시다.</p><h2 id="날짜-구성-요소"><a href="#날짜-구성-요소" class="headerlink" title="날짜 구성 요소"></a>날짜 구성 요소</h2><p>Date 인스턴스의 각 구성 요소에 접근 할 때는 다음 메서드를 사용합니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.UTC(<span class="hljs-number">1815</span>, <span class="hljs-number">9</span> ,<span class="hljs-number">10</span>));</span><br><span class="line"></span><br><span class="line">d.getFullYear()</span><br><span class="line">d.getMonth()</span><br><span class="line">d.getDate()</span><br><span class="line">d.getDay()</span><br><span class="line">d.getHours()</span><br><span class="line">d.getMinutes()</span><br><span class="line">d.getSeconds()</span><br><span class="line">d.getMilliseconds()</span><br></pre></td></tr></table></figure><h2 id="날짜-비교"><a href="#날짜-비교" class="headerlink" title="날짜 비교"></a>날짜 비교</h2><p>날짜 A와 날짜 B 중 너느쪽이 더 앞인가 하는 단순 날짜 비교는 자바스크립트에 내장된 비교 연산자를 통해 할 수 있다.<br>Date 인스턴스는 날짜를 숫자로 저장 하므로, 숫자에 쓸 수 있는 비교 연산자를 그대로 쓰면 된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1996</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2009</span>, <span class="hljs-number">4</span>, <span class="hljs-number">27</span>);</span><br><span class="line">d1 &gt; d2  <span class="hljs-comment">// false</span></span><br><span class="line">d1 &lt; d2  <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="날짜-연산"><a href="#날짜-연산" class="headerlink" title="날짜 연산"></a>날짜 연산</h2><p>날짜는 숫자이므로 날짜에서 날짜를 빼면 몇 밀리초가 지났는지 알 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> msDiff = d2 -d1;</span><br></pre></td></tr></table></figure><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><blockquote><p>자바스크립트의 날자는 1970년 1월 1일 UTC로부터 몇 밀리초가 지났는지 나타내는 숫자입니다.<br>날짜를 생성할 때는 타임존이 유의 하여야 한다.<br>날짜 형식을 자유롭게 바꿀 수 있어야 한다면 Moment.js를 사용하면 된다.</p></blockquote>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/08/16/Learning-JavaScript-chapter15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 14. 비동기적 프로그래밍</title>
      <link>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter14/</link>
      <guid>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter14/</guid>
      <pubDate>Fri, 02 Aug 2019 15:28:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;사용자의 행동은 전적으로 &lt;strong&gt;비동기적&lt;/strong&gt;이다. 사용자가 언제 클릭할지, 터치할지, 또는 타이핑 할지 프로그래머는 전혀 알수 없기 때문이다. 하지만 비동기적 실행이 사용자입력 하나 때문에 필요한 것은 아니다.&lt;/p&gt;
&lt;p&gt;자바스크립트 애플리케이션은 &lt;code&gt;단일 스레드&lt;/code&gt;에서 동작한다.&lt;br&gt;즉 자바스크립트는 한 번에 한가지 일만 할 수 있다. 이러한 자바스크립트의 본질 때문에 비동기적 프로그램밍이 필요하다.&lt;/p&gt;
&lt;p&gt;자바스크립트에는 매우 일찍부터 비동기적 실행 메커니즘이 존재 했지만, 자바스크립트의 인기가 높아지고 소프트웨어가 복잡해짐에 따라 비동기적 프로그래밍에 필요한 장치들이 추가 되었다.&lt;/p&gt;
&lt;p&gt;자바스크립트의 비동기적 프로그래밍에는 뚜렷이 구분되는 &lt;code&gt;세가지 패러다임&lt;/code&gt;이 있습니다.&lt;br&gt;처음에는 &lt;strong&gt;콜백&lt;/strong&gt; 그 뒤로 &lt;strong&gt;프라미스&lt;/strong&gt; 마지막은 &lt;strong&gt;제너레이터&lt;/strong&gt; 입니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>사용자의 행동은 전적으로 <strong>비동기적</strong>이다. 사용자가 언제 클릭할지, 터치할지, 또는 타이핑 할지 프로그래머는 전혀 알수 없기 때문이다. 하지만 비동기적 실행이 사용자입력 하나 때문에 필요한 것은 아니다.</p><p>자바스크립트 애플리케이션은 <code>단일 스레드</code>에서 동작한다.<br>즉 자바스크립트는 한 번에 한가지 일만 할 수 있다. 이러한 자바스크립트의 본질 때문에 비동기적 프로그램밍이 필요하다.</p><p>자바스크립트에는 매우 일찍부터 비동기적 실행 메커니즘이 존재 했지만, 자바스크립트의 인기가 높아지고 소프트웨어가 복잡해짐에 따라 비동기적 프로그래밍에 필요한 장치들이 추가 되었다.</p><p>자바스크립트의 비동기적 프로그래밍에는 뚜렷이 구분되는 <code>세가지 패러다임</code>이 있습니다.<br>처음에는 <strong>콜백</strong> 그 뒤로 <strong>프라미스</strong> 마지막은 <strong>제너레이터</strong> 입니다.</p><a id="more"></a><p>제너레이터 자체는 비동기적 프로그래밍을 전혀 지원하지 않는다.<br>제너레이터를 비동기적으로 사용하려면 프라미스나 특수한 콜백과 함께 사용해야 한다.</p><p>사용자 입력 외에, 비동기적 테크닉을 사용해야 하는 경우는 크게 세가지가 있다.</p><blockquote><p>Ajax 호출을 비롯한 네트워크 요청<br>파일을 읽고 쓰는 등의 파일시스템 작업<br>의도적으로 시간 지연을 사용하는 기능(알람 등)</p></blockquote><h2 id="비유"><a href="#비유" class="headerlink" title="비유"></a>비유</h2><p>어떤 음식점은 당신이 줄을 서서 기다리지 않도록, 당신의 전화번호를 받아서 자리가 나면 전화를 해줍니다. 이런 음심적은 <strong>콜백</strong>과 비슷하다. 자리가 나면 당신이 알 수 있도록 하는 수단을 당신이 음식점 주인에게 넘겨준다. 음식점은 다른 손님을 대접하면 되고 당신은 다른 일을 하면된다. 어느쪽도 서로를 기다리지 않는다.</p><p>다른 음식점은 자리가 났을 때 진동하는 호출기를 당신에게 넘겨준다. 이런 음식점은 <strong>프라미스</strong>와 비슷하다.<br>자리가 나면 당신이 알수 있도록 하는 수단을 음식점에서 당신에게 넘겨준다.</p><h2 id="콜백"><a href="#콜백" class="headerlink" title="콜백"></a>콜백</h2><p>콜백은 자바스크립트에서 <code>가장 오래된 비동기적 메커니즘</code>이다. 콜백은 간단히 말해 나중에 호출할 함수이다.<br>콜백 함수 자체에는 특별할 것이 전혀 없다. 콜백 함수도 <strong>일반적인 자바스크립트 함수일 뿐이다.</strong><br>콜백함수는 일반적으로 다른 함수에 넘기거나 객체의 프로퍼티로 사용한다. 드물게는 배열에 넣어서 쓸 때도 있다.<br>항상 그런건 아니지만 콜백은 보통 익명 함수로 사용한다.</p><p>비동기적 실행의 가장 큰 목적이자 중요한 요점은 어떤 것도 차단하지 않는다는 것이다.<br>자바스크립트는 싱글 스레드를 사용하기 때문에 우리가 컴퓨터에 60초동안 대기한 후 코드를 실행하라고 지시한다면 그 실행이 동기적으로 이루어 진다면 프로그램이 멈추고 사용자 입력을 받아들이지도 않고 화면도 업데이트 하지 않을것이다.<br>비동기적 테크닉은 프로그램이 이런 식으로 멈추는 일을 막아준다.</p><h2 id="오류-우선-콜백"><a href="#오류-우선-콜백" class="headerlink" title="오류 우선 콜백"></a>오류 우선 콜백</h2><p>콜백을 사용하면 예외 처리가 어려워지므로 콜백과 관련된 에러를 처리할 방법의 표준이 필요했다.<br>이에 따라 나타난 패턴이 콜백의 첫 번째 매개변수에 에러 객체를 쓰자는 것이었다.<br>에러가 null이나 undefined이면 에러가 없는 것입니다.<br>오류 우선 콜백을 다룰 때 가장 먼저 생각할 것은 에러 매개변수를 체크하고 그에 맞게 반응하는 겁니다.</p><p>노드에는 파일 콘텐츠를 읽는다고 할 때 오류 우선 콜백을 사용한다면 다음과 같다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> fname = <span class="hljs-string">'may_or_may_nor_exist.txt'</span>;</span><br><span class="line"></span><br><span class="line">fs.readFile(fname, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`error reading file $(fname): <span class="hljs-subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`$(fname) contents: $(data)`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>콜백에서 가장 먼저 하는 일은 err이 참 같은 값인지 확인 하는 것이다.<br>err이 참 같은 값이라면 파일을 읽는 데 문제가 있다는 뜻이므로 콘솔에 오류를 보고하고 즉시 빠져나온다.<br>오류 우선 콜백을 사용할 때는 에러 객체를 체크해야 하고, 빠져 나와야 한다는 사실을 기억해야 한다.<br>콜백을 사용하는 함수는 대개 콜백이 성공적이라고 가정하고 만들어 진다. 그런데 콜백이 실패 했으니 빠져나가지 않으면 오류를 예약하는 것이나 다름 없다.<br>물론, 콜백을 만들 때 실패하는 경우도 염두에 두고 만들었다면 에러를 기록 하기만 하고 계속 진행해도 된다.<br>프라미스를 사용하지 않으면 오류우선 콜백은 노드 개발의 표준이나 다름 없다.</p><h2 id="콜백-헬"><a href="#콜백-헬" class="headerlink" title="콜백 헬"></a>콜백 헬</h2><p>콜백을 사용해 비동기적으로 실행할 수 있긴 하지만 <code>현실적인 단점</code>이 있다. 한 번에 여러가지를 기다려야 한다면 콜백을 관리하기가 상당히 어려워진다. 중괄호에 둘러싸여 끝없이 중청된 삼각형의 코드 블록들을 프로그래머들은 <code>콜백 헬</code>이라고 부른다. 가장 골치 아픈것은 에러 처리이다.</p><p>비동기적 코드가 늘어나면 늘어날수록 버그가 없고 관리하기 쉬운 코드를 작성하기는 매우 어렵다 그래서 <strong>프라미스</strong>가 등장했다.</p><h2 id="프라미스"><a href="#프라미스" class="headerlink" title="프라미스"></a>프라미스</h2><p>프라미스는 콜백의 단점을 해결하려는 시도 속에서 만들어졌다.<br>프라미스가 <strong>콜백을 대체하는 것은 아니다.</strong> 사실 프라미스에서도 콜백을 사용한다.<br>프라미스는 콜백을 예측 가능한 패턴으로 사용 할수 있게 하며, 프라미스 없이 콜백만 사용했을 때 나타날수 있는 엉뚱한 현상이나 찾기 힘든 버그를 상당수 해결한다.</p><p>프라미스의 기본 개념은 프라미스 기반 함수를 호출하면 그 함수는 <code>Promise 인스턴스를 반환</code>한다.<br>프라미스는 <strong>성공(resolve)</strong>하거나 <strong>실패(reject)</strong>하거나 단 두가지 뿐이다.<br>프라미스는 성공 혹은 실패 둘 중 하나만 일어난다고 확신할 수 있다.<br>성공한 프라미스가 나중에 실패하는 일 같은건 절대 없다. 또한 성공이든 실패든 단 한번만 일어난다.<br>프라미스가 성공하거나 실패하면 그 프라미스를 <code>결정</code> 됐다고 한다.</p><p>프라미스는 객체이므로 어디든 전달할 수 있다는 점도 콜백에 비해 간편한 장점이다.<br>비동기적 처리를 여기서 하지 않고 다른 함수에서 처리하게 하고 싶다면 프라미스를 넘기기만 하면 된다.</p><h2 id="프라미스-만들기"><a href="#프라미스-만들기" class="headerlink" title="프라미스 만들기"></a>프라미스 만들기</h2><p>프라미스는 쉽게 만들 수 있다.<br>resolve와 reject 콜백이 있는 함수로 새 Promise 인스턴스를 만들기만 하면 된다.</p><h2 id="프라미스-사용"><a href="#프라미스-사용" class="headerlink" title="프라미스 사용"></a>프라미스 사용</h2><p>프라미스는 비동기적 작업이 성공 또는 실패하도록 확정하는 매우 안전하고 잘 정의된 매커니즘을 제공하지만 현재는 진행 상황을 전혀 알려주지 않는다. 즉 프라미스는 완료되거나 파기 될뿐 <strong>‘50% 진행됐다’</strong> 라는 개념은 아예 없다.<br><code>Q</code> 같은 프라미스 라이브러리에는 진행 상황을 보고하는 기능이 있고 나중에 언젠가는 도입될 수도 있지만 지금 당장은 없다.</p><h2 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트"></a>이벤트</h2><p>이벤트는 자바스크립트에서 자주 사용된다. 이벤트의 개념은 간단하다.<br>이벤트가 일어나면 이벤트 발생을 담당하는 객체에서 이벤트가 일어났음을 알린다,<br>필요한 이벤트는 모두 주시 할수 있다.(콜백을 통해서)</p><h2 id="프라미스-체인"><a href="#프라미스-체인" class="headerlink" title="프라미스 체인"></a>프라미스 체인</h2><p>프라미스에는 체인으로 연결 할수 있다는 장점이 있다. 즉, <strong>프라미스가 완료되면 다른 프라미스를 반환하는 함수를 즉시 호출</strong> 할수 있다. 프라미스 체인을 사용하면 모든 단계에서 에러를 캐치할 필요는 없다. 체인 어디에서든 에러가 생기면 체인 전체가 멈추고 catch핸들러가 동작한다.</p><h2 id="결정되지-않는-프라미스-방지하기"><a href="#결정되지-않는-프라미스-방지하기" class="headerlink" title="결정되지 않는 프라미스 방지하기"></a>결정되지 않는 프라미스 방지하기</h2><p>프라미스는 비동기적 코드를 단순화하고 콜백이 두 번 이상 실행되는 문제를 방지한다.<br>하지만 resolve나 reject를 호출하는 걸 잊어서 프라미스가 결정되지 않는 문제까지 자동으로 해결하지는 못한다.<br>에러가 일어나지 않으므로 찾기 매우 어렵다. 복잡한 시스템에서 결정되지 않은 프라미스는 그냥 잊혀질 수 있다.</p><p>결정되지 않는 프라미스를 방지하는 한 가지 방법은 타임아웃을 거는 것이다.<br>출분한 시간이 지났는데도 프라미스가 결정되지 않으며 자동으로 실패하게 만들 수 있다.</p><figure class="highlight javascript hljs"><figcaption><span>프라미스에 타임아웃을 거는 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTimeout</span>(<span class="hljs-params">fn, timeout</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(timeout === <span class="hljs-literal">undefined</span>) timeout = <span class="hljs-number">1000</span>; <span class="hljs-comment">//타임아웃 기본값 </span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">const</span> tid = setTimeout(reject, timeout,</span><br><span class="line">                <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"promise timed out"</span>));</span><br><span class="line">            fn(...args)</span><br><span class="line">                .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;</span><br><span class="line">                    clearTimeout(tid);</span><br><span class="line">                    resolve(...args);</span><br><span class="line">                &#125;)</span><br><span class="line">                .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;</span><br><span class="line">                    clearTimeout(tid);</span><br><span class="line">                    reject(...args)</span><br><span class="line">                &#125;);    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프라미스를 반환하는 함수를 호출하는 프라미스를 반환하는 함수를 반환하는 함수 ??<br>프라미스에 타임아웃을 걸기 위해서는 함수를 반환하는 함수가 필요하다.</p><h2 id="제너레이터"><a href="#제너레이터" class="headerlink" title="제너레이터"></a>제너레이터</h2><p>제너레이터는 원래 동기적인 성격을 가졌지만 프라미스와 결합하면 비동기 코드를 효율적으로 관리 할 수 있다.<br>비동기 코드에서 가장 어려운 부분은 동기적인 코드에 비해 <strong>만들기가 어렵다</strong>는 점이다.</p><p>프로그램에서 어떤 부분을 동시에 실행할 수 있고 또 어떤 부분은 동시에 실행 할수 없는지 판단하는 것이 중요하다.</p><h2 id="제너레이터-실행기와-예외처리"><a href="#제너레이터-실행기와-예외처리" class="headerlink" title="제너레이터 실행기와 예외처리"></a>제너레이터 실행기와 예외처리</h2><p><code>제너레이터 실행기</code>를 쓰면 try/catch를 써서 예외 처리를 할수 있다는 것도 중요한 장점이다.<br>콜백이나 프라미스를 사용하면 예외 처리가 쉽지 않다. 콜백에서 일으킨 예외는 그 콜백 밖에서 캐치할 수 없다.<br>제너레이터 실행기는 <strong>비동기적으로 실행</strong>하면서도 동기적인 동작 방식을 유지하므로 <strong>try/catch문</strong>과 함께 쓸수 있다.</p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><blockquote><p>자바스크립트의 비동기적 실행은 콜백을 통해 이루어진다.<br>프라미스를 콜백 대신 사용할수 잇는건 아니다. 프라미스 역시 콜백을 사용한다.<br>프라미스는 콜백이 여러번 호출되는 문제를 해결했다.<br>콜백을 여러번 호출해야 한다면 이벤트와 결합하는 방법을 생각 할수 있다.(프라미스도 함께 쓸 수 있다.)<br>프라미스는 반드시 결정된다는 보장은 없다. 프라미스의 타임아웃을 걸어 이문제를 해결 할수 있다.<br>프라미스는 체인으로 연결할 수 있다.<br>프라미스와 제너레이터 실행기를 결합하면 비동기적 실행의 장점을 그대로 유지하면서도 동기적인 사고방식으로 문제를 해결할 수 있다,<br>제너레이터를 써서 동기적인 사고방식으로 문제를 해결할 때는 프로그래의 어느 부분을 동시에 실행 할수 있는지 잘 살펴야 한다. 동시에 실행 할수 있는 부분은 Promise.all을 써서 실행해라<br>제너레이터 실행기를 직점 만드는 고생을 하지말고 co나 Koa를 써라<br>노드 스타일 콜백을 프라미스로 바꾸는 고생도 필요없다  Q를 써라<br>제너레이터 실행기를 쓰면 예외 처리도 익숙한 방식으로 할 수 있다.</p></blockquote>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 13. 함수와 추상적 사고</title>
      <link>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter13/</link>
      <guid>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter13/</guid>
      <pubDate>Fri, 02 Aug 2019 15:20:45 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;서브루틴으로서의-함수&quot;&gt;&lt;a href=&quot;#서브루틴으로서의-함수&quot; class=&quot;headerlink&quot; title=&quot;서브루틴으로서의 함수&quot;&gt;&lt;/a&gt;서브루틴으로서의 함수&lt;/h2&gt;&lt;p&gt;서브루틴은 아주 오랜 된 개념이며 복잡한 코드를 간단하게 만드는 기초적인 수단입니다.&lt;br&gt;서브루틴은 프로시저, 루틴, 서브프로그램, 매크로 등 다양한 이름으로 불립니다. 이들은 모두 매우 단순하고 &lt;strong&gt;범용적인 호출 할수 있는 한 단위&lt;/strong&gt;를 일컫는 말이다.&lt;/p&gt;
&lt;h2 id=&quot;함수로서의-함수&quot;&gt;&lt;a href=&quot;#함수로서의-함수&quot; class=&quot;headerlink&quot; title=&quot;함수로서의 함수&quot;&gt;&lt;/a&gt;함수로서의 함수&lt;/h2&gt;&lt;p&gt;순수함수 - 순수함수에서는 입력이 같으면 결과도 반드시 같다.&lt;br&gt;순수함수에는 부수효과가 없어야 한다.&lt;br&gt;함수도 객체다. 자바스크립트 함수는 Function 객체의 인스턴스이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="서브루틴으로서의-함수"><a href="#서브루틴으로서의-함수" class="headerlink" title="서브루틴으로서의 함수"></a>서브루틴으로서의 함수</h2><p>서브루틴은 아주 오랜 된 개념이며 복잡한 코드를 간단하게 만드는 기초적인 수단입니다.<br>서브루틴은 프로시저, 루틴, 서브프로그램, 매크로 등 다양한 이름으로 불립니다. 이들은 모두 매우 단순하고 <strong>범용적인 호출 할수 있는 한 단위</strong>를 일컫는 말이다.</p><h2 id="함수로서의-함수"><a href="#함수로서의-함수" class="headerlink" title="함수로서의 함수"></a>함수로서의 함수</h2><p>순수함수 - 순수함수에서는 입력이 같으면 결과도 반드시 같다.<br>순수함수에는 부수효과가 없어야 한다.<br>함수도 객체다. 자바스크립트 함수는 Function 객체의 인스턴스이다.</p><a id="more"></a><h2 id="변수로서의-함수"><a href="#변수로서의-함수" class="headerlink" title="변수로서의 함수"></a>변수로서의 함수</h2><blockquote><p>함수를 가리키는 변수를 만들어 별명을 정할 수 있다,<br>배열에 함수를 넣을 수 있습니다. 물론 다른 타입의 데이터와 섞일 수 있습니다.<br>함수를 객체의 프로퍼티로 사용할 수 있습니다.<br>함수를 함수에 전달 할 수 잇습니다.<br>함수가 함수를 반환 할 수 있습니다.<br>함수를 매개변수로 받는 함수를 반환하는 것도 물론 가능합니다.</p></blockquote><h2 id="배열-안의-함수"><a href="#배열-안의-함수" class="headerlink" title="배열 안의 함수"></a>배열 안의 함수</h2><p>배열을 사용하면 작업 단계를 언제든 쉽게 바꿀 수 있다는 장점이 있다.<br>어떤 작업을 빼야 한다면 배열에서 제거하기만 하면되고, 추가할 작업이 있다면 배열에 추가하기만 하면 된다.</p><h2 id="함수의-함수-전달"><a href="#함수의-함수-전달" class="headerlink" title="함수의 함수 전달"></a>함수의 함수 전달</h2><p>함수에 함수를 전달하는 다른 용도는 <code>비동기적 프로그래밍</code>입니다. 이런 용도로 전달하는 함수를 보통 <code>콜백</code>이라 부르며 약자로 cb를 쓸때가 많습니다. 콜백 함수는 <strong>자신을 감싼 함수가 실행을 마쳤을때 호출</strong>됩니다.<br>함수에 함수를 전달하는 대표적인 사례가 콜백이긴 하지만 그게 전부는 아니다.<br>함수는 동작이고, 함수를 받은 함수는 그 동작을 활용할 수 있다.</p><h2 id="함수를-반환하는-함수"><a href="#함수를-반환하는-함수" class="headerlink" title="함수를 반환하는 함수"></a>함수를 반환하는 함수</h2><p>매개변수 여러개를 받는 함수를 매개변수 하나만 받는 함수로 바꾸는 것을 <code>커링</code> 이라고 부른다.<br>커링이라는 이름은 이 패턴을 만든 미국의 수학자 하스켈 커리의 이름을 딴것이다.</p><h2 id="재귀"><a href="#재귀" class="headerlink" title="재귀"></a>재귀</h2><p>재귀 역시 널리 쓰이며 함수를 활용하는 중요한 패턴입니다, <code>재귀</code>란 <strong>자기 자신을 호출하는 함수</strong> 입니다.<br>같은 일을 반복하면서 그 대상이 점차 줄어드는 상황에서 재귀를 유용하게 활용 할 수 있습니다.<br>재귀 함수에는 <strong>종료조건</strong>이 있어야 합니다. 종료 조건이 없다면 자바스크립트 인터프리터에서 스택이 너무 깊다고 판단할 때까지 재귀 호출을 계속하다가 프로그램이 멈춥니다.</p><h2 id="함수형프로그래밍"><a href="#함수형프로그래밍" class="headerlink" title="함수형프로그래밍"></a>함수형프로그래밍</h2><p>어떤 방법이 ‘더 좋은’ 방법인가? 이 질문에 정확한 답은 없다. 여러가지 상황에 맞추어 사용하면된다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 12. 이터레이터와 제너레이터</title>
      <link>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter12/</link>
      <guid>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter12/</guid>
      <pubDate>Fri, 02 Aug 2019 15:07:02 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;이터레이터&quot;&gt;&lt;a href=&quot;#이터레이터&quot; class=&quot;headerlink&quot; title=&quot;이터레이터&quot;&gt;&lt;/a&gt;이터레이터&lt;/h2&gt;&lt;p&gt;이터레이터는 ‘지금 어디있는지’ 파악할 수 있도록 돕는다는 면에서 일종의 &lt;strong&gt;책갈피&lt;/strong&gt;와 비슷한 개념이다. 배열은 이터러블 객체의 좋은 예이다. 책에 여러 페이지가 있는 것처럼 배열에는 여러 요소가 들어 있으므로 책에 책갈피를 끼울수 있듯 &lt;code&gt;배열에는 이터레이터&lt;/code&gt;를 사용 할 수 있다.&lt;/p&gt;
&lt;p&gt;next메서드는 더이상 진행 할것이 없으면 undefined가 되지만 next는 계속 호출 할 수 있습니다.&lt;br&gt;물론 그렇다고 결과가 바뀌는건 아니다.&lt;/p&gt;
&lt;p&gt;이터레이터는 &lt;code&gt;모두 독립적&lt;/code&gt;입니다. 즉 새 이터레이터를 만들 때마다 처음에서 시작합니다.&lt;br&gt;그리고 각각 다른 요소를 가리키는 이터레이터 여러 개를 동시에 사용할 수도 있습니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="이터레이터"><a href="#이터레이터" class="headerlink" title="이터레이터"></a>이터레이터</h2><p>이터레이터는 ‘지금 어디있는지’ 파악할 수 있도록 돕는다는 면에서 일종의 <strong>책갈피</strong>와 비슷한 개념이다. 배열은 이터러블 객체의 좋은 예이다. 책에 여러 페이지가 있는 것처럼 배열에는 여러 요소가 들어 있으므로 책에 책갈피를 끼울수 있듯 <code>배열에는 이터레이터</code>를 사용 할 수 있다.</p><p>next메서드는 더이상 진행 할것이 없으면 undefined가 되지만 next는 계속 호출 할 수 있습니다.<br>물론 그렇다고 결과가 바뀌는건 아니다.</p><p>이터레이터는 <code>모두 독립적</code>입니다. 즉 새 이터레이터를 만들 때마다 처음에서 시작합니다.<br>그리고 각각 다른 요소를 가리키는 이터레이터 여러 개를 동시에 사용할 수도 있습니다.</p><a id="more"></a><h2 id="이터레이션-프로토콜"><a href="#이터레이션-프로토콜" class="headerlink" title="이터레이션 프로토콜"></a>이터레이션 프로토콜</h2><p>이터레이터는 그 자체로 크게 쓸모가 있다기보다는 더 쓸모 있는 동작이 가능해지도록 한다는데 의미가 있다.<br>이터레이터 프로토콜은 모든 객체를 이터러블 객체로 바꿀 수 있습니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line">    add(message)&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.messages.push(&#123; message, <span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">Date</span>.now() &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="hljs-built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span>.this.messages.valus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이터레이션 프로토콜은 클래스에 심볼 메서드 Symbol.iterator가 있고 이 메서드가 이터레이터처럼 동작하는 객체, 즉 value와 done프로퍼티가 있는 개체를 반환하는 next메서드를 가진 객체를 반환한다면 그 클래스의 <code>인스턴스는 이터러블 객체</code>라는 뜻입니다.</p><h2 id="제너레이터"><a href="#제너레이터" class="headerlink" title="제너레이터"></a>제너레이터</h2><p>제너레이터란 이터레이터를 사용해 <code>자신의 실행을 제어하는 함수</code>입니다. 일반적인 함수는 매개변수를 받고 값을 반환하지만 호출자는 매개변수 외에는 함수의 실행을 제어할 방법이 전혀 없습니다.<br>함수를 호출하면 그 함수가 종료될 때까지 제어권을 완전히 넘기는 겁니다. 하지만 제너레이터에서는 그렇지 않다.</p><h3 id="제너레이터의-도입된-새로운-개념"><a href="#제너레이터의-도입된-새로운-개념" class="headerlink" title="제너레이터의 도입된 새로운 개념"></a>제너레이터의 도입된 새로운 개념</h3><blockquote><p>제너레이터는 언제든 호출자에게 제어권을 넘길 수 있습니다.<br>제너레이터는 호출한 즉시 실행되지는 않습니다. 대신 이터레이터를 반환하고, 이터레이터의 next 메서드를 호출함에 따라 실행됩니다.</p></blockquote><p>이 두가지 예외를 제외하면 일반적인 함수와 같습니다.</p><p>제너레이터를 만들때는 function키워드 뒤에 <strong>애스터리스크(*)</strong>를 붙입니다.<br>제너레이터에서는 return 외에 <em>yield 키워드</em>를 쓸 수 있습니다.</p><h2 id="yield-표현식과-양방향통신"><a href="#yield-표현식과-양방향통신" class="headerlink" title="yield 표현식과 양방향통신"></a>yield 표현식과 양방향통신</h2><p>통신은 yield 표현식을 통해 이뤄진다.<br>표현식은 값으로 평가되고 yield는 표현식이므로 반드시 어떤 값으로 평가 됩니다.<br>yield표현식의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수 입니다. </p><p>제너레이터를 시행했을 때 일어나는 일을 묘사한것 책 참고</p><h2 id="제너레이터와-return"><a href="#제너레이터와-return" class="headerlink" title="제너레이터와 return"></a>제너레이터와 return</h2><p>yield문은 설령 제너레이터의 마지만 문이더라도 제너레이터를 끝내지 않습니다.<br>제너레이터에서 return문은 사용하면 그 위치와 관계없이 done은 true가 되고, value 프로퍼티는 return이 반환하는 값이 됩니다.</p><blockquote><p>제너레이터에서 중요한 값을 return으로 반환하려 하지 마십시오.<br>제너레이터가 반환하는 값을 사용하려 할 때는 yield를 써야 하고 return은 제너레이터를 중간에 종료하는 목적으로만 사용해야 합니다.</p></blockquote><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>이터레이터는 배열이나 객체처럼 여러 가지 값을 제공할 수 잇는 컬렉션의 동작 방식을 <code>표준화</code>했습니다.<br>이터레이터로 할 수 있는 일은 <code>ES6 이전에도 모두 할 수 있었으므로</code> 어떤 기능이 추가된 것은 아니다.<br>중요하면서도 자주 사용하는 패턴을 표준화했다는데 의미가 있다.</p><p>제너레이터를 사용하면 함수를 훨씬 더 유연하고 효율적으로 사용 할 수 있다.<br>제너레이터는 모든 연산을 지연시켰다가 필요할 때만 수행하게 만들 수 있다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 11. 예외와 에러 처리</title>
      <link>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter11/</link>
      <guid>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter11/</guid>
      <pubDate>Fri, 02 Aug 2019 15:02:48 GMT</pubDate>
      <description>
      
        &lt;p&gt;견고하고 품질 좋은 소프트웨어를 만드는 첫 번째 단계는 에러가 일어날 수 있다는 사실을 받아들이는 것이다.&lt;br&gt;두 번째 단계는 에러를 예상하고 타당한 방법으로 처리하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;예외처리&lt;/code&gt;는 에러를 컨트롤 하는 매커니즘이다.&lt;br&gt;에러처리라고 하지 않고 예외처리라고 하는 이유는 예상치 못한 상황에 대처하는 방식이기 때문이다.&lt;/p&gt;
&lt;h2 id=&quot;Error-객체&quot;&gt;&lt;a href=&quot;#Error-객체&quot; class=&quot;headerlink&quot; title=&quot;Error 객체&quot;&gt;&lt;/a&gt;Error 객체&lt;/h2&gt;&lt;p&gt;자바스크립트에는 내장된 Error 객체가 있고 이 객체는 에러 처리에 간편하게 사용할 수 있다.&lt;br&gt;Error 인스턴스를 만들면서 에러 메세지를 지정할 수 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; err = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Error&lt;/span&gt;(‘invalid email’);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>견고하고 품질 좋은 소프트웨어를 만드는 첫 번째 단계는 에러가 일어날 수 있다는 사실을 받아들이는 것이다.<br>두 번째 단계는 에러를 예상하고 타당한 방법으로 처리하는 것이다.</p><p><code>예외처리</code>는 에러를 컨트롤 하는 매커니즘이다.<br>에러처리라고 하지 않고 예외처리라고 하는 이유는 예상치 못한 상황에 대처하는 방식이기 때문이다.</p><h2 id="Error-객체"><a href="#Error-객체" class="headerlink" title="Error 객체"></a>Error 객체</h2><p>자바스크립트에는 내장된 Error 객체가 있고 이 객체는 에러 처리에 간편하게 사용할 수 있다.<br>Error 인스턴스를 만들면서 에러 메세지를 지정할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(‘invalid email’);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="try-catch와-예외처리"><a href="#try-catch와-예외처리" class="headerlink" title="try/catch와 예외처리"></a>try/catch와 예외처리</h2><p>에러를 캐치하면 프로그램은 멈추지 않는다. 에러를 기록하고 계속 진행 할 수 있다.<br>문제가 해결된것은 아니다. 최소한 앞뒤 사정을 모르고 그냥 멈추는 일은 막을 수 있다.</p><p>실행 흐름은 에러가 일어나는 즉시 catch 블록으로 이동<br>try블록안에 쓸수 있는 문의 숫자에 제한은 없다.<br>에러가 일어나지 않으면 catch블록은 실행 되지 않는다.</p><h2 id="예외처리와-호출스택"><a href="#예외처리와-호출스택" class="headerlink" title="예외처리와 호출스택"></a>예외처리와 호출스택</h2><p>완료되지 않은 함수가 쌓이는 것을 호출스택이라고 부른다.<br>에러는 캐치될때까지 호출스택을 따라 올라간다.<br>에러는 호출스택 어디에서든 캐치 할수 있다.</p><h2 id="try-…-catch-…-finally"><a href="#try-…-catch-…-finally" class="headerlink" title="try … catch … finally"></a>try … catch … finally</h2><p>finally블록은 에러가 일어나든 일어나지 않든 반드시 호출된다.</p><blockquote><p>예외 처리하는 데에도 비용이 발생한다.<br>프로그램을 일부러 멈추려 하는게 아니라며 예외를 일으켰으면 반드시 캐치해야 한다.<br>예외처리는 예상 할수 없는 상화에 대비한 마지노선이다.<br>예상 할수 있는 에러는 조건문으로 처리하는 것이 최선이다.</p></blockquote>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/08/03/Learning-JavaScript-chapter11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 10. 맵과 셋</title>
      <link>http://mishka86.github.io/2019/08/02/Learning-JavaScript-chapter10/</link>
      <guid>http://mishka86.github.io/2019/08/02/Learning-JavaScript-chapter10/</guid>
      <pubDate>Fri, 02 Aug 2019 14:57:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;ES6에서 도입 &lt;code&gt;맵&lt;/code&gt;은 &lt;strong&gt;키와 값을 연결&lt;/strong&gt;한다는 점에서 객체와 비슷&lt;br&gt;&lt;code&gt;셋&lt;/code&gt;은 &lt;strong&gt;중복을 허용하지 않는다&lt;/strong&gt;는 점만 제외하면 배열과 비슷&lt;/p&gt;
&lt;h2 id=&quot;맵&quot;&gt;&lt;a href=&quot;#맵&quot; class=&quot;headerlink&quot; title=&quot;맵&quot;&gt;&lt;/a&gt;맵&lt;/h2&gt;&lt;p&gt;키와값을 연결할때 객체를 사용하면 발생하는 단점&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;프로토타입 체인 때문에 의도하지 않은 연결이 생길 수 있다.&lt;br&gt;객체 안에 연결된 키와 값이 몇 개나 되는지 쉽게 알아낼 수 있는 방법이 없다.&lt;br&gt;키는 반드시 문자열이나 심볼이어야 하므로 객체를 키로 써서 값과 연결 할수 없다.&lt;br&gt;객체는 프로퍼티 순서를 전혀 보장하지 않는다.&lt;br&gt;Map 객체는 이들 결함을 모두 해결, 키와 값을 연결할 목적이라면 객체보다 나은 선택이다.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>ES6에서 도입 <code>맵</code>은 <strong>키와 값을 연결</strong>한다는 점에서 객체와 비슷<br><code>셋</code>은 <strong>중복을 허용하지 않는다</strong>는 점만 제외하면 배열과 비슷</p><h2 id="맵"><a href="#맵" class="headerlink" title="맵"></a>맵</h2><p>키와값을 연결할때 객체를 사용하면 발생하는 단점</p><blockquote><p>프로토타입 체인 때문에 의도하지 않은 연결이 생길 수 있다.<br>객체 안에 연결된 키와 값이 몇 개나 되는지 쉽게 알아낼 수 있는 방법이 없다.<br>키는 반드시 문자열이나 심볼이어야 하므로 객체를 키로 써서 값과 연결 할수 없다.<br>객체는 프로퍼티 순서를 전혀 보장하지 않는다.<br>Map 객체는 이들 결함을 모두 해결, 키와 값을 연결할 목적이라면 객체보다 나은 선택이다.</p></blockquote><a id="more"></a><p>set()메서드를 써서 사용자 역할을 할당<br>역할을 알아볼때는 get()메서드<br>맵에 존재하지 않는 키에 get을 호출하면 undefined를 반환한다.<br>맵에 키가 존재하는지 확인하는 has()메서드<br>맵에 이미 존재하는 키에 set()을 호출하면 값이 교체<br>size프로퍼티는 맵의 요소 숫자를 반환<br>keys()메서드는 맵의 키를 반환<br>values()메서드는 값을 반환<br>entries()메서드는 첫 번째 요소가 키이고 두 번째 요소가 값인 배열을 각각 반환</p><p>이터러블 객체보다 배열이 필요하다면 확산연산자(…)를 사용<br>맵의 요소를 지울때는 delete()메서드<br>맵의 요소를 모두 지울때는 clear()메서드</p><h2 id="위크맵"><a href="#위크맵" class="headerlink" title="위크맵"></a>위크맵</h2><p>다음 차이점을 제외하면 Map과 완전히 같다.<br><code>키는 반드시 객체</code>여야 한다.<br>WeekMap의키는 가비지 콜렉션에 포함될 수 있다.<br>WeekMap은 이터러블이 아니며 clear() 메서드도 없다.</p><h2 id="셋"><a href="#셋" class="headerlink" title="셋"></a>셋</h2><p>셋은 중복을 허용하지 않는 데이터 집합이다.</p><p>사용자역할을 추가할 때는 add()메서드 - 추가하려는 것이 이미 있다면 아무일도 일어나지 않는다.</p><p>size프로퍼티는 셋의 요소 숫자를 반환<br>역할을 제거할 때는 delete()메서드 - 제거에 성공하면 true를 반환, 그렇지 않다면 false를 반환</p><h2 id="위크셋"><a href="#위크셋" class="headerlink" title="위크셋"></a>위크셋</h2><p>위크셋은 객체만 포함 할 수 있다. 가비지 콜렉션의 대상이된다.<br>이터러블이 아니다. 위크셋의 실제 용도는 주어진 객체가 셋안에 존재하는지 아닌지를 알아보는 것 뿐이라고 해도 과언이 아니다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/08/02/Learning-JavaScript-chapter10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 9. 객체와 객체지향 프로그래밍</title>
      <link>http://mishka86.github.io/2019/08/02/Learning-JavaScript-chapter9/</link>
      <guid>http://mishka86.github.io/2019/08/02/Learning-JavaScript-chapter9/</guid>
      <pubDate>Fri, 02 Aug 2019 14:47:43 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;객체&quot;&gt;&lt;a href=&quot;#객체&quot; class=&quot;headerlink&quot; title=&quot;객체&quot;&gt;&lt;/a&gt;객체&lt;/h2&gt;&lt;p&gt;배열과 마찬가지로 자바스크립트 객체 역시 컨테이너지만, 크게 보면 다음 두 가지 측면에서 배열과 다릅니다.&lt;br&gt;배열은 값을 가지며 각 값에는 숫자형 인덱스가 있습니다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있습니다.&lt;br&gt;배열에는 순서가 있습니다. 즉 arr[0] 는 항상 arr[1]보다 앞에 있습니다. 반면 &lt;code&gt;객체에는 그런 순서가 보장 되지 않습니다.&lt;/code&gt;&lt;br&gt;obj.a가 obj.b보다 앞에 있다고 말할 수는 없습니다.&lt;/p&gt;
&lt;p&gt;프로퍼티는 &lt;strong&gt;키(문자열 또는 심볼)과 값&lt;/strong&gt;으로 구성됩니다. 객체의 특징은 키를 통해 프로퍼티에 접근할 수 있다는 점입니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h2><p>배열과 마찬가지로 자바스크립트 객체 역시 컨테이너지만, 크게 보면 다음 두 가지 측면에서 배열과 다릅니다.<br>배열은 값을 가지며 각 값에는 숫자형 인덱스가 있습니다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있습니다.<br>배열에는 순서가 있습니다. 즉 arr[0] 는 항상 arr[1]보다 앞에 있습니다. 반면 <code>객체에는 그런 순서가 보장 되지 않습니다.</code><br>obj.a가 obj.b보다 앞에 있다고 말할 수는 없습니다.</p><p>프로퍼티는 <strong>키(문자열 또는 심볼)과 값</strong>으로 구성됩니다. 객체의 특징은 키를 통해 프로퍼티에 접근할 수 있다는 점입니다.</p><a id="more"></a><h2 id="프로퍼티나열"><a href="#프로퍼티나열" class="headerlink" title="프로퍼티나열"></a>프로퍼티나열</h2><p>프로퍼티 나열에서 기억해야 할 것은 순서가 보장되지 않는다는 점입니다.<br>객체프로퍼티에는 순서가 없습니다.</p><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><p>Object.keys는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> SYM = <span class="hljs-built_in">Symbol</span>();</span><br><span class="line"><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">c</span>:<span class="hljs-number">3</span>, [SYM]:<span class="hljs-number">4</span>; &#125;</span><br><span class="line"><span class="hljs-built_in">Object</span>.keys(o).forEach(<span class="hljs-function"><span class="hljs-params">prop</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;prop&#125;</span>: <span class="hljs-subst">$&#123;o&#123;prop&#125;</span>&#125;`</span>));</span><br></pre></td></tr></table></figure><p>객체의 프로퍼티 키를 배열로 가져와야 할때는 object.keys가 편리합니다. </p><h2 id="객체지향-프로그래밍"><a href="#객체지향-프로그래밍" class="headerlink" title="객체지향 프로그래밍"></a>객체지향 프로그래밍</h2><p><code>객체지향 프로그래밍(OOP)</code>은 컴퓨터 과학에서 전통적인 패러다임입니다.<br>OOP의 개념중 일부는 1950년대부터 있었지만 , 시뮬러 67과 스몰토크가 등장하면서 OOP의 형태가 갖춰지기 시작했습니다.<br>OOP의 기본아이디어는 단순하고 직관적이다. 객체는 데이터와 기능을 논리적으로 묶어 놓은겁니다.<br>OOP는 우리가 사물을 이해하는 자연스러운 방식을 반영하도록 설계됐습니다. 또한 OOP는 사물에 관해 추상적으로, 구체적으로 생각할 수 있게 합니다.</p><blockquote><p>클래스는 어떤자동차 처럼 추상적이고 범용적인 것<br>인스턴스는 특정자동차 처럼 구체적이고 한정적인 것<br>메서드는 기능<br>클래스 메서드는 클래스에 속하지만 특정 인스턴스에 묶이지는 않는 기능<br>oop는 클래스를 계층적으로 분류하는 수단도 제공합니다.</p></blockquote><h2 id="클래스와-인스턴스-생성"><a href="#클래스와-인스턴스-생성" class="headerlink" title="클래스와 인스턴스 생성"></a>클래스와 인스턴스 생성</h2><figure class="highlight javascript hljs"><figcaption><span>클래스 문법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;</span><br><span class="line">     <span class="hljs-keyword">let</span> = a </span><br><span class="line">    <span class="hljs-keyword">constructor</span>(b)&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.a = b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> Car(<span class="hljs-number">3</span>); </span><br><span class="line"><span class="hljs-built_in">console</span>.log(c.a)</span><br></pre></td></tr></table></figure><p>클래스를 만들때 사용한 this 키워드는 나중에 만들 인스턴스의 <code>플레이스 홀더</code>입니다.<br>메서드를 <strong>호출하는 시점</strong>에서 this가 무엇인지 알 수 있게 됩니다.</p><h2 id="클래스는-함수다"><a href="#클래스는-함수다" class="headerlink" title="클래스는 함수다"></a>클래스는 함수다</h2><p>class 키워드를 도입하기 전까지 클래스를 만든다는 것은 곧 클래스 생성자로 사용할 함수를 만든다는 의미였다.<br>class 문법이 훨씬 더 직관적이고 단순하긴 하지만, 사실 class 는 단축 문법일 뿐이며 자바스크립트의 클래스 자체가 바뀐것은 아니다.<br>따라서 클래스 자체를 이해하는 것이 중요하다.<br><strong>클래스는 사실 함수일 뿐이다.</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Es5Car</span> </span>&#123;&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Es6Car</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>클래스가 바뀐것이 아니라 간편한 새 문법이 생겼을 뿐이다.</p><h2 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h2><p>클래스의 인스턴스에서 사용할 수 있는 메서드라고 하면 그건 프로토타입 메서드를 말하는 것이다.</p><blockquote><p>최근에는 프로토타입 메서드를 #으로 표시하는 표기법이 널리 쓰입니다.<br>Car.prototype.shift 를 Car#shift 로 표기한다.</p></blockquote><p>모든 함수에는 <code>prototype</code>이라는 특별한 <code>프로퍼티가</code> 있다.<br>일반적인 함수에서는 프로토타입을 사용할 일이 없지만<br>객체 생성자로 동작하는 함수에서는 프로토타입이 대단히 중요하다.<br>함수의 prototype 프로퍼티가 중요해지는 시점은 new 키워드로 새 인스턴스를 만들었을 때이다<br>new키워드로 만든 새 객체는 생성자의 prototype프로퍼티에 접근할 수 있습니다.<br>객체 인스턴스는 생성자의 prototype프로퍼티를 <code>__proto__프로퍼티</code>에 저장합니다.</p><p>프로토타입에서 중요한 것은 <code>동적 디스패치</code>하는 매커니즘입니다.<br>여기서 디스패치는 메서드호출과 같은의미입니다.<br>객체의 프로퍼티나 메서드에 접근하려 할 때 그런 프로퍼티나 메서드가 존재하지 않으면<br>자바스크립트는 객체의 프로토타입에서 해당 프로퍼티나 메서드를 찾습니다.</p><p>클래스의 인스턴스는 모두 같은 프로토타입을 공유하므로 프로토타입에 프로퍼티나 메서드가 있다면<br>해당 클래스의 인스턴스는 모두 그 프로퍼티나 메서드에 접근 할 수 있습니다.</p><p>인스턴스에서 메서드나 프로퍼티를 정의하면 프로토타입에 있는 것을 가리는 효과가 있습니다.<br>자바스크립트는 먼저 인스턴스를 체크하고 거기에 없으면 프로토타입을 체크하기 때문이다.</p><h2 id="정적메서드"><a href="#정적메서드" class="headerlink" title="정적메서드"></a>정적메서드</h2><p>특정인스턴스에 적용되지 않는다.<br>정적메서드에서 this는 인스턴스가 아니라 클래스자체에 묶인다.<br>일반적으로 정적 메서드에는 this대신 클래스 이름을 사용하는 것이 좋은습관이다.<br>정적메서드는 클래스에 관련되지만 인스턴스와는 관련이 없는 범용적인 작업에 사용된다.</p><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>클래스의 인스턴스는 클래스의 기능을 모두 상속한다. 상속은 한 단계로 끝나지 않는다.<br>객체의 프로토타입에서 메서드를 찾지 못하면 자바스크립트는 프로토타입의 프로토타입을 검색한다.<br>조건에 맞는 프로토타입을 찾을 때까지 프로토타입 체인을 거슬러 올라갑니다.<br>조건에 맞는 프로토타입을 찾지 못하면 에러를 일으킨다.</p><p>extends키워드는 Car를 Vehicle의 서브클래스로 만듭니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super() 는 슈퍼클래스의 생성자를 호출하는 함수이다.<br>서브클래스에서는 이 함수를 반드시 호출해야 한다. 호출하지 않으면 에러가 난다. 상속은 단방향이다.</p><h2 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h2><p>디형성이란? 객체지향 언어에서 여러 슈퍼클래스의 멤버인 인스턴스를 가리키는 말이다.</p><p>자바스크립트는 믹스인 방법을 사용한다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/08/02/Learning-JavaScript-chapter9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo 포스팅 스타일 설정하기</title>
      <link>http://mishka86.github.io/2019/07/29/hexo-post-setting/</link>
      <guid>http://mishka86.github.io/2019/07/29/hexo-post-setting/</guid>
      <pubDate>Mon, 29 Jul 2019 04:55:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;hexo를 통해 포스팅을 하다보니 테마커스텀에 대한 욕구가 스멀스멀 솟아올랐다. ㅎㅎㅎ;;&lt;br&gt;메인 이미지도 그리고 아이콘이나 위젯들의 위치도 이곳 저곳 옮겨보기도 하면서&lt;br&gt;나름 나만의 스타일로 하나씩 바꿔나가는 재미가 있었다,&lt;/p&gt;
&lt;p&gt;아래 내용들은 현재 제가 사용하고 있는 icarus 테마를 기준으로 작성한것입니다.&lt;br&gt;다른 테마에서는 다른 방법이 있을 수 있습니다.&lt;/p&gt;
&lt;p&gt;그렇게 블로그를 조금씩 꾸미고 여러가지 포스팅들도 올리고 하다가 한 가지 의문이 생겼다.&lt;br&gt;바로 포스트 리스트에서 사용하는 위젯들을 &lt;code&gt;_config.yml&lt;/code&gt; 에서 설정으로 잡아 주었는데&lt;br&gt;포스트 상세페이지에서도 똑같이 노출이 되다보니 포스트 본문의 가로 넓이가 너무 적게 보인다는 점이었다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>hexo를 통해 포스팅을 하다보니 테마커스텀에 대한 욕구가 스멀스멀 솟아올랐다. ㅎㅎㅎ;;<br>메인 이미지도 그리고 아이콘이나 위젯들의 위치도 이곳 저곳 옮겨보기도 하면서<br>나름 나만의 스타일로 하나씩 바꿔나가는 재미가 있었다,</p><p>아래 내용들은 현재 제가 사용하고 있는 icarus 테마를 기준으로 작성한것입니다.<br>다른 테마에서는 다른 방법이 있을 수 있습니다.</p><p>그렇게 블로그를 조금씩 꾸미고 여러가지 포스팅들도 올리고 하다가 한 가지 의문이 생겼다.<br>바로 포스트 리스트에서 사용하는 위젯들을 <code>_config.yml</code> 에서 설정으로 잡아 주었는데<br>포스트 상세페이지에서도 똑같이 노출이 되다보니 포스트 본문의 가로 넓이가 너무 적게 보인다는 점이었다.</p><a id="more"></a><p>그래서 <code>_config.yml</code>에 있는 설정들을 하나씩 뜯어보고 해당 기능이 있는지 찾아보았지만<br>원하는 기능은 없는것 같아서 기운없이 여러 블로그를 돌아다니고 있는 도중에 내가 사용하는 테마를 같이 사용하는<br>블로그에서 리스트와 포스트 상세페이지에 스타일이 다른 것을 발견하고는 다시 이것 저것 세팅을 바꿔보고<br>해당 블로그와 코드도 비교해 보면서 방법을 찾기 시작했다.</p><p>그러던 중 정말 우연히 내 포스트와 다른 점을 발견하게 됐고 방법을 찾았다.<br>나와 같은 필요를 느끼고 있는 분들을 위해 그 방법을 간단하게 정리해 보고자 한다.</p><p>우선 포스팅방법이 궁금하신 분들은 지난번에 작성한 <strong><a href="https://mishka86.github.io/2019/06/18/hexo-writing/">hexo 포스팅 방법</a></strong>을 참고하면 됩니다. </p><p>여러가지 실험끝에 발견한 방법은 그러한 세팅이 따로 존재하는 것이 아니라 포스팅을 작성할때<br><strong><a href="https://mishka86.github.io/2019/06/18/hexo-writing/#%EB%A8%B8%EB%A6%AC%EB%A7%90-Front-matter">머리말(Front matter)</a></strong>에 해당 파일의 정보를 입력해주면 되는 것이었다.</p><p>머리말은 지난 포스트에서 설명했듯이 포스트 생성시 포스트 최상단에 자동으로 생성이 됩니다.<br>저자는 이곳에 카테고리,태그,썸네일등을 지정하여 포스트마다 다르게 노출되는 값들을 입력하는 곳이라 생각하였고<br>머리말을 이용하여 위젯이나 레이아웃을 변경할 수 있을것이라고는 미처 생각하지 못했었다.<br>그렇게 한참 다른 곳을 해메이다가 우연히 머리말의 입력값이 다른 것을 발견하고는 유레카를 외쳤다.</p><p>저자는 포스트작성시 머리글에 카탈로그,카테고리,태그 클라우드 위젯을 추가하고 싶었고<br>포스팅 우측에 고정으로 놓고 싶었다. 그래서 아래와 같은 설정을 머리말에 추가해 주었다.</p><figure class="highlight markdown hljs"><figcaption><span>머리말</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toc: true</span><br><span class="line">widgets:</span><br><span class="line"><span class="hljs-bullet">  - </span>type: toc</span><br><span class="line"><span class="hljs-code">    position: right</span></span><br><span class="line"><span class="hljs-bullet">  - </span>type: category</span><br><span class="line"><span class="hljs-code">    position: right</span></span><br><span class="line"><span class="hljs-bullet">  - </span>type: tagcloud</span><br><span class="line"><span class="hljs-code">    position: right</span></span><br><span class="line">sidebar:</span><br><span class="line">  right:</span><br><span class="line"><span class="hljs-code">    sticky: true</span></span><br></pre></td></tr></table></figure><p>하나씩 옵션을 살펴보면</p><figure class="highlight markdown hljs"><figcaption><span>머리말</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">toc: true</span><br><span class="line"><span class="hljs-section"># 카탈로그 옵션을 사용하기 위해 true옵션을 사용하였다.</span></span><br><span class="line"></span><br><span class="line">widgets:</span><br><span class="line"><span class="hljs-bullet">  - </span>type: toc</span><br><span class="line"><span class="hljs-code">    position: right</span></span><br><span class="line"><span class="hljs-bullet">  - </span>type: category</span><br><span class="line"><span class="hljs-code">    position: right</span></span><br><span class="line"><span class="hljs-bullet">  - </span>type: tagcloud</span><br><span class="line"><span class="hljs-code">    position: right  </span></span><br><span class="line"><span class="hljs-section"># 위젯의 타입을 지정하여주고 위치를 오른쪽으로 지정하였다.   </span></span><br><span class="line"></span><br><span class="line">sidebar:</span><br><span class="line">  right:</span><br><span class="line"><span class="hljs-code">    sticky: true</span></span><br><span class="line"><span class="hljs-section"># sticky 옵션은 true로 하여 우측에 고정을 시켜주었다.</span></span><br></pre></td></tr></table></figure><p>위와 같은 내용들을 머리말에 추가하여 원하는 스타일로 꾸밀 수 있었다. 그리고 매번 포스팅을 할때<br>위의 내용을 작성하면 번거롭기 때문에 <strong><a href="https://mishka86.github.io/2019/06/18/hexo-writing/#%EC%8A%A4%EC%BA%90%ED%8F%B4%EB%93%9C-Scaffolds">스캐폴드</a></strong>에 해당내용을 추가해서 자동으로 추가되게 세팅하였다.</p><p>이상으로 hexo 포스팅 스타일 설정하기 포스팅을 마칩니다. 해당글로 많은 분들이 조금이나마 쉽게 hexo 블로그를 접하고 꾸밀 수 있기를 바랍니다.<br>도움이 되었다면 댓글을 살포시 남겨주시면 감사하겠습니다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/07/29/hexo-post-setting/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 8. 배열과 배열처리</title>
      <link>http://mishka86.github.io/2019/07/13/Learning-JavaScript-chapter8/</link>
      <guid>http://mishka86.github.io/2019/07/13/Learning-JavaScript-chapter8/</guid>
      <pubDate>Fri, 12 Jul 2019 16:42:21 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;배열의-기초&quot;&gt;&lt;a href=&quot;#배열의-기초&quot; class=&quot;headerlink&quot; title=&quot;배열의 기초&quot;&gt;&lt;/a&gt;배열의 기초&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;배열은 객체와 달리 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다.&lt;/li&gt;
&lt;li&gt;자바스크립트의 배열은 비균질적입니다. 즉 한 배열의 요소가 모두 같은 데이터 타입일 필요는 없습니다. 배열은 다른 배열이나 객체도 포함 할 수 있습니다.&lt;/li&gt;
&lt;li&gt;배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근 할 때도 대괄호를 사용합니다.&lt;/li&gt;
&lt;li&gt;모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다.&lt;/li&gt;
&lt;li&gt;배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하며 배열을 자동으로 그 인덱스에 맞게 늘어나며, 빈자리는 undefined로 채워집니다.&lt;/li&gt;
&lt;li&gt;Array 생성자를 써서 배열을 만들수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="배열의-기초"><a href="#배열의-기초" class="headerlink" title="배열의 기초"></a>배열의 기초</h2><blockquote><ul><li>배열은 객체와 달리 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다.</li><li>자바스크립트의 배열은 비균질적입니다. 즉 한 배열의 요소가 모두 같은 데이터 타입일 필요는 없습니다. 배열은 다른 배열이나 객체도 포함 할 수 있습니다.</li><li>배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근 할 때도 대괄호를 사용합니다.</li><li>모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다.</li><li>배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하며 배열을 자동으로 그 인덱스에 맞게 늘어나며, 빈자리는 undefined로 채워집니다.</li><li>Array 생성자를 써서 배열을 만들수도 있습니다.</li></ul></blockquote><a id="more"></a><h2 id="배열요소-조작"><a href="#배열요소-조작" class="headerlink" title="배열요소 조작"></a>배열요소 조작</h2><p>배열 메서드 중 일부는 <strong>‘배열자체를 수정’</strong>하며, 다른 일부는 <strong>‘새 배열’</strong>을 반환합니다.<br>예) push는 배열자체를 수정하며, concat은 새 배열을 반환합니다.</p><h2 id="push-pop-shift-unshift-메서드"><a href="#push-pop-shift-unshift-메서드" class="headerlink" title="push, pop, shift, unshift 메서드"></a>push, pop, shift, unshift 메서드</h2><p><code>배열의 처음</code>은 첫 번째 요소, 즉 인덱스가 0인 요소<br><code>배열의 끝</code>은 인덱스가 가장 큰 요소, 즉 배열이 arr이라면 arr.length -1 인 요소<br>push 와 pop은 각각 배열의 끝에 요소를 추가하거나 제거합니다. (수정)<br>shift와 unshift는 각각 배열의 처음에 요소를 제거하거나 추가합니다. (수정)</p><h2 id="concat-메서드"><a href="#concat-메서드" class="headerlink" title="concat 메서드"></a>concat 메서드</h2><p>concat메서드는 배열의 끝에 여러요소를 추가한 사본을 반환<br>concat은 제공받은 배열을 한 번만 분해합니다.<br>배열안에 있는 배열을 다시 분해 하지는 않습니다. - 이해가 잘 안감</p><h2 id="slice-메서드"><a href="#slice-메서드" class="headerlink" title="slice 메서드"></a>slice 메서드</h2><p>배열의 일부만을 가져올때 사용합니다.<br>slice 메서드는 매개변수 두 개를 받습니다.<br>첫 번째 매개변수는 어디서부터 가져올지를 두 번째 매개변수는 어디까지 가져올지를(바로 앞 인덱스까지 가져옵니다.) 지정합니다.<br>두 번째 매개변수를 생략하면 배열의 마지막 까지 반환합니다.<br>음수인덱스를 사용하면 배열의 끝에서부터 요소를 셉니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];</span><br><span class="line">arr.slice(<span class="hljs-number">3</span>);      <span class="hljs-comment">// [4,5] arr은 바뀌지 않았습니다.</span></span><br><span class="line">arr.slice(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);    <span class="hljs-comment">// [3,4] arr은 바뀌지 않았습니다.</span></span><br><span class="line">arr.slice(<span class="hljs-number">-2</span>);     <span class="hljs-comment">// [4,5] arr은 바뀌지 않았습니다.</span></span><br><span class="line">arr.slice(<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>);   <span class="hljs-comment">// [2,4] arr은 바뀌지 않았습니다.</span></span><br><span class="line">arr.slice(<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>);  <span class="hljs-comment">// [4] arr은 바뀌지 않았습니다.</span></span><br></pre></td></tr></table></figure><h2 id="splice-메서드"><a href="#splice-메서드" class="headerlink" title="splice 메서드"></a>splice 메서드</h2><p>배열을 자유롭게 수정할 수 있습니다.<br>첫 번째 매개변수는 수정을 시작할 인덱스 이고, 두 번째 매개변수는 제거할 요소 숫자입니다.<br>아무요소도 제거하지 않을 때는 0을 넘깁니다. 나머지 매개변수는 배열에 추가될 요소입니다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];</span><br><span class="line">arr.splice(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);      <span class="hljs-comment">// [] arr은 이제 [1,2,3,4,5,7]입니다.</span></span><br><span class="line">arr.splice(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);          <span class="hljs-comment">// [] arr은 이제 [1,2,3,4,5,6,7]입니다.</span></span><br><span class="line">arr.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);            <span class="hljs-comment">// [2,3] arr은 이제 [1,4,5,6,7]입니다.</span></span><br><span class="line">arr.splice(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>)     <span class="hljs-comment">// [5] arr은 이제 [1,4,'a','b',6,7]입니다.</span></span><br></pre></td></tr></table></figure><h2 id="copyWithin-메서드"><a href="#copyWithin-메서드" class="headerlink" title="copyWithin 메서드"></a>copyWithin 메서드</h2><p>ES6에서 도입, 배열요소를 복사해서 다른 위치에 붙여넣고, 기존 요소를 덮어 씁니다.<br>첫 번째 매개변수는 복사한 요소를 붙여넣을 위치이고, 두 번째 매개변수는 복사를 시작할 위치, 세 번째 매개변수는 복사를 끝낼 위치입니다.(생략가능)<br>음수를 사용하면 배열의 끝에서부터 셉니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];</span><br><span class="line">arr.copyWithin(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);         <span class="hljs-comment">// arr은 이제 [1,3,4,4]입니다.</span></span><br><span class="line">arr.copyWithin(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);      <span class="hljs-comment">// arr은 이제 [1,3,1,3]입니다.</span></span><br><span class="line">arr.copyWithin(<span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-1</span>);    <span class="hljs-comment">// arr은 이제 [3,1,1,3]입니다.</span></span><br></pre></td></tr></table></figure><h2 id="fill-메서드"><a href="#fill-메서드" class="headerlink" title="fill 메서드"></a>fill 메서드</h2><p>ES6에서 도입, 정해진 값으로 배열을 채웁니다.<br>크기를 지정해서 배열을 생성하는 Array 생성자와 잘 어울립니다.<br>배열의 일부만 채우려 할때는 시작인덱스와 끝인덱스를 지정하면 된다.<br>음수인덱스도 사용 할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>).fill(<span class="hljs-number">1</span>);    <span class="hljs-comment">// arr이 [1,1,1,1,1]로 초기화 뙵니다.</span></span><br><span class="line">arr.fill(<span class="hljs-string">"a"</span>);                       <span class="hljs-comment">// arr은 이제 ["a","a","a","a","a"]입니다.</span></span><br><span class="line">arr.fill(<span class="hljs-string">"b"</span>,<span class="hljs-number">1</span>);                     <span class="hljs-comment">// arr은 이제 ["a","b","b","b","b"]입니다.</span></span><br><span class="line">arr.fill(<span class="hljs-string">"c"</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);                   <span class="hljs-comment">// arr은 이제 ["a","b","c","c","b"]입니다.</span></span><br><span class="line">arr.fill(<span class="hljs-number">5.5</span>, <span class="hljs-number">-4</span>);                   <span class="hljs-comment">// arr은 이제 ["a",5.5,5.5,5.5,5.5]입니다.</span></span><br><span class="line">arr.fill(<span class="hljs-number">0</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">-1</span>);                   <span class="hljs-comment">// arr은 이제 ["a",5.5,0,0,5.5]입니다.</span></span><br></pre></td></tr></table></figure><h2 id="reverse-메서드"><a href="#reverse-메서드" class="headerlink" title="reverse 메서드"></a>reverse 메서드</h2><p>배열의 요소의 순서를 반대로 바꿉니다.</p><h2 id="sort-메서드"><a href="#sort-메서드" class="headerlink" title="sort 메서드"></a>sort 메서드</h2><p>배열 요소의 순서를 정렬합니다. sort는 정렬 함수를 받을 수 있습니다.<br>일반적으로는 객체가 들어있는 배열을 정렬 할 수 없지만 정렬 함수를 사용하면 가능하다.</p><h2 id="배열검색"><a href="#배열검색" class="headerlink" title="배열검색"></a>배열검색</h2><h3 id="indexOf-lastIndexOf-메서드"><a href="#indexOf-lastIndexOf-메서드" class="headerlink" title="indexOf,lastIndexOf 메서드,"></a>indexOf,lastIndexOf 메서드,</h3><p>indecOf 메서드는 찾고자 하는 것과 정확히 일치(===)하는 첫 번째 요소의 인덱스를 반환<br>lastIndexOf 메서드는 배열의 끝에서부터 검색<br>배열의 일부분만 검색하려면 시작 인덱스를 지정할 수 있다.<br>indexOf 와 lastIndexOf는 일치하는 것을 찾지 못하면 -1 을 반환한다. </p><h3 id="findindex-메서드"><a href="#findindex-메서드" class="headerlink" title="findindex 메서드"></a>findindex 메서드</h3><p>findindex는 메서드는 보조함수를 써서 검색조건을 지정할 수 있다.<br>indexOf와 lastindexOf 처럼 일치하는 것을 찾지 못하면 -1을 반환<br>검색 시작할 인덱스를 지정 할 수 없고, 뒤에서 부터 찾을 수도 없다.</p><h3 id="find-메서드"><a href="#find-메서드" class="headerlink" title="find 메서드"></a>find 메서드</h3><p>조건에 맞는 요소의 인덱스가 아니라 요소 자체를 검색할 때 사용<br>검색 조건을 함수로 전달 할 수 있다.<br>조건에 맞는 요소가 없을 때는 undefined를 반환</p><h3 id="some-메서드"><a href="#some-메서드" class="headerlink" title="some 메서드"></a>some 메서드</h3><p>조건에 맞는 요소를 찾으면 즉시 검색을 멈추고 <code>true</code>를 반환<br>조건에 맞는 요소를 찾지 못하면 <code>false</code>를 반환</p><h3 id="every-메서드"><a href="#every-메서드" class="headerlink" title="every 메서드"></a>every 메서드</h3><p><strong>배열의 모든 요소</strong>가 조건에 맞아야 <code>true</code>를 반환 그렇지 않다면 <code>false</code>를 반환<br>조건에 맞지 않는 요소를 찾아야만 검색을 멈추고 false를 반환<br>조건에 맞지 않는 요소를 찾지 못하면 배열 전체를 검색</p><h2 id="map-과-filter-메서드"><a href="#map-과-filter-메서드" class="headerlink" title="map 과 filter 메서드"></a>map 과 filter 메서드</h2><p>map은 배열 요소를 변형합니다.<br>map 과 filter 는 사본을 반환하며 원래 배열을 바뀌지 않습니다.<br>콜백함수는 각 요소에서 호출 될 때 요소 자체와 요소인덱스, 배열전체를 매개변수로 받습니다.</p><p>fliter 는 필요한 것들만 남깁니다.<br>map과 마찬가지로 사본을 반환하며 새 배열에는 필요한 요소만 남습니다.<br>어떤 요소를 남길지 함수로 넘깁니다.</p><h2 id="reduce-메서드"><a href="#reduce-메서드" class="headerlink" title="reduce 메서드"></a>reduce 메서드</h2><p>map이 배열의 각 요소를 변형한다면 reduce는 배열 자체를 변형합니다.<br>reduce는 map과 filter를 비롯해 앞의 설명한 배열 메서드의 동작 대부분을 대신 할 수 있다.<br>reduce가 받는 첫번째 매개변수는 배열이 줄어드는 대상인 어큐뮬레이터 입니다.<br>두 번째 매개변수부터는 여태까지 설명한 콜백의 순서대로 현재배열요소, 현재인덱스, 배열 자체 입니다.</p><p>reduce는 초기값도 옵션으로 받을 수 있습니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>];</span><br><span class="line"><span class="hljs-keyword">const</span> sum = arr.reduce((a,x =&gt; a += x,<span class="hljs-number">0</span>));</span><br></pre></td></tr></table></figure><p>reduce의 콜백 함수는 매개변수로 누적값 a와 현재 배열요소 x를 받았습니다. 이 예제에서 누적값은 0으로 시작합니다.</p><p><strong>진행순서</strong></p><blockquote><ol><li>첫 번째 배열 요소 5에서 익명 함수를 호출합니다. a의 초깃값은 0이고 x의 값은 5입니다. 함수는 a와 x(5)의 합을 반환합니다. 이 값은 다음 단계에서 a의 값이 됩니다.</li><li>두 번째 배열 요소 7에서 함수를 호출합니다. a의 초깃값은 이전 단계에서 전달한 5이고, x의 값은 7입니다. 함수는 a와 x의 합 12를 반환합니다. 이 값은 다음 단계에서 a의 값이 됩니다.</li><li>세 번째 배열 요소 2에서 함수를 호출합니다. 이 단계에서 a는 12이고 x는 2 입니다. 함수는 a와 x의 합인 14를 반환합니다.</li><li>네 번째이자 마지막 배열 요소인 4에서 함수를 호출합니다 a는 14이고 x는 4입니다. 함수는 a와 x의 합인 18을 반환하며 이 값은 reduce의 값이고 sum에 할당 되는 값입니다.<br>누적값이 어떻게 변하는 지 생각하는 습관을 기르는게 좋다. </li></ol></blockquote><p>누적값이 undefined로 시작된다면 어떻게 될까? 누적갑이 제공되지 않으면 reduce는 첫 번째 배열요소를 초기값으로 보고 두 번째 요소에서부터 함수를 호출합니다.<br>배열의 첫 번재 요소가 그대로 초깃값이 될 수 있을때는 초깃값을 생략해도 됩니다.</p><p>reduce는 보통 숫자나 문자열 같은 원시값을 누적값으로 사용하지만 객체 또한 누적 값이 될 수 있고 이를 통해 아주 다양하게 활용할수 있다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/07/13/Learning-JavaScript-chapter8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 7. 스코프</title>
      <link>http://mishka86.github.io/2019/07/12/Learning-JavaScript-chapter7/</link>
      <guid>http://mishka86.github.io/2019/07/12/Learning-JavaScript-chapter7/</guid>
      <pubDate>Fri, 12 Jul 2019 12:40:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;스코프는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정합니다.&lt;/p&gt;
&lt;p&gt;변수가 존재하지 않으면 그 변수는 스코프안에 &lt;strong&gt;‘있지않음’&lt;/strong&gt;을 직관적으로 알수 있다.&lt;br&gt;즉 아직 선언하지 않은 변수나 함수가 종료되면서 존재하지 않게 된 변수는 분명 스코프안에 &lt;strong&gt;‘있지 않다’&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;스코프&lt;/code&gt;와 &lt;code&gt;존재&lt;/code&gt;를 구별해야 한다.&lt;br&gt;가시성이라고도 불리는 &lt;code&gt;스코프&lt;/code&gt;는 프로그램의 현재 실행 중인 부분, 즉 실행 컨텍스트에서 현재 보이고 접근 할 수 있는 식별자들을 말한다. 반면 &lt;code&gt;존재&lt;/code&gt;한다는 말은 식별자가 메모리에 할당된 무언가를 가리키고 있다는 뜻이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>스코프는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정합니다.</p><p>변수가 존재하지 않으면 그 변수는 스코프안에 <strong>‘있지않음’</strong>을 직관적으로 알수 있다.<br>즉 아직 선언하지 않은 변수나 함수가 종료되면서 존재하지 않게 된 변수는 분명 스코프안에 <strong>‘있지 않다’</strong></p><p><code>스코프</code>와 <code>존재</code>를 구별해야 한다.<br>가시성이라고도 불리는 <code>스코프</code>는 프로그램의 현재 실행 중인 부분, 즉 실행 컨텍스트에서 현재 보이고 접근 할 수 있는 식별자들을 말한다. 반면 <code>존재</code>한다는 말은 식별자가 메모리에 할당된 무언가를 가리키고 있다는 뜻이다.</p><a id="more"></a><h2 id="정적스코프와-동적스코프"><a href="#정적스코프와-동적스코프" class="headerlink" title="정적스코프와 동적스코프"></a>정적스코프와 동적스코프</h2><p>자바스크립트의 스코프는 <code>정적</code>이다. 소스코드만 봐도 변수가 스코프에 있는지 판단 할 수 있다.<br>다만 소스코드만 봐도 즉시 스코프를 분명히 알 수 있다는 뜻은 아니다.</p><h3 id="정적스코프"><a href="#정적스코프" class="headerlink" title="정적스코프"></a>정적스코프</h3><p>어떤 변수가 함수 스코프 안에 잇는지 함수를 <code>정의</code> 할 때 알 수 있다는 뜻 이다. <strong>호출할 때 알 수 있는 것은 아니다.</strong><br>자신이 정의 될 때 접근 할 수 있었던 식별자에는 여전히 접근 할 수 있지만, 호출 할 때 스코프에 있는 식별자에는 접근 할 수 없다.</p><h2 id="전역스코프"><a href="#전역스코프" class="headerlink" title="전역스코프"></a>전역스코프</h2><p>전역스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있다.<br>전역스코프에서 선언된 것들을 <code>전역변수(global)</code>라고 합니다.<br>전역스코프에 의존하는 것은 피해야한다.</p><h2 id="블록스코프"><a href="#블록스코프" class="headerlink" title="블록스코프"></a>블록스코프</h2><p><code>let</code> 과 <code>const</code> 는 식별자를 블록스코프에서 선언합니다.<br>블록스코프는 블록(문을 중괄호로 묶은것)의 스코프에서만 보이는 식별자를 의미한다.</p><h2 id="변수-숨기기"><a href="#변수-숨기기" class="headerlink" title="변수 숨기기"></a>변수 숨기기</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-comment">// 외부블록</span></span><br><span class="line">    <span class="hljs-keyword">let</span> x = <span class="hljs-string">'blue'</span>;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(x);       <span class="hljs-comment">// "blue"</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-comment">// 내부블록</span></span><br><span class="line">        <span class="hljs-keyword">let</span> x = <span class="hljs-number">3</span>;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(x)    <span class="hljs-comment">// "3"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(x);       <span class="hljs-comment">// "blue"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> x);    <span class="hljs-comment">// "undefined"; x는 스코프에 있지 않습니다.</span></span><br></pre></td></tr></table></figure><p>내부블럭의 x는 외부 블록에서 정의한 x와 이름만 같을 뿐 다른 변수이므로 외부 스코프의 x를 숨기는 효과가 있다.<br>실행 흐름이 내부 블록에 들어가 새 변수 x를 정의 하는 순간 두 변수는 모두 스코프안에 있다.(외부 변수가 숨겨짐)<br>변수의 이름이 같으므로 외부 스코프에 있는 변수에 접근할 방법이 없다.</p><h3 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h3><p>스코프가 계속 연결됨(중첩), 스코프안에 스코프가 있는 형태<br>내부 함수에서는 외부 함수의 변수에 접근이 가능하지만 외부 함수에서는 내부 함수의 변수에 접근 할수 없다.<br>모든 함수들은 전역 객체에 접근 할 수 있다.</p><h2 id="함수-클로저-정적스코프"><a href="#함수-클로저-정적스코프" class="headerlink" title="함수, 클로저, 정적스코프"></a>함수, 클로저, 정적스코프</h2><p><strong>클로저</strong>는 함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의 하는 경우, 스코프를 함수 주변으로 좁히는 것을 말한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> globalFunc;                   <span class="hljs-comment">// 정의 되지 않는 전역 함수</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> blockVar = <span class="hljs-string">"a"</span>            <span class="hljs-comment">// 블록 스코프에 있는 변수</span></span><br><span class="line">    globalFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(blockVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">globalFunc();                     <span class="hljs-comment">// "a"</span></span><br></pre></td></tr></table></figure><p>globalFunc는 블록 안에서 값을 할당받았습니다. 이 블록 스크로와 그 부모인 전역 스코프가 <code>클로저</code>를 형성합니다.<br>globalFunc를 어디서 호출하든 이 함수는 클로저에 들어있는 식별자에 접근 할수 있다.<br>globalFunc을 호출하면, 이 함수는 스코프에서 빠져나왔음에도 불구하고 blockVar에 접근 할 수 있습니다.</p><h2 id="즉시실행함수"><a href="#즉시실행함수" class="headerlink" title="즉시실행함수"></a>즉시실행함수</h2><p><strong>IIFE(즉시실행함수)</strong>는 함수를 선언하고 즉시 실행합니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 즉시실행함수 바디</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>IIFE의 장점은 내부에 있는 것들이 모두 자신만의 스코프를 가지지만 IIFE 자체는 함수이므로 그 <code>스코프 밖으로</code> 무언가를 내보낼 수 있는 것이다.</p><p>내부 변수는 IIFE안에 안전하게 보관되어 있으므로 손댈 방법이 없다.<br>ES6에서 블록스코프 변수를 도입하면서 IIFE가 필요한 경우가 줄긴 했지만 여전히 널리 쓰인다.<br>클로저를 만들고 클로저에서 무언가 반환 받을 때에는 유용하게 쓸 수 있다.</p><h2 id="함수스코프와-호이스팅"><a href="#함수스코프와-호이스팅" class="headerlink" title="함수스코프와 호이스팅"></a>함수스코프와 호이스팅</h2><p><code>var로 선언된 변수</code>들은 <code>함수스코프</code>라 불리는 스코프를 가진다.<br>var로 선언한 전역 변수는 명시적인 함수 안에 있지 않지만 함수 스코프와 똑같이 동작한다.</p><p>let으로 변수를 선언하면, 그 변수는 선언하지 전에는 존재하지 않습니다.<br>var로 선언한 변수는 현재 스코프 안이라면 어디서든 사용 할 수 있으며, 심지어 선언하기도 전에 사용할 수 있습니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> var1;</span><br><span class="line"><span class="hljs-keyword">let</span> var2 = <span class="hljs-literal">undefined</span>;</span><br><span class="line">var1;   <span class="hljs-comment">// undefined;</span></span><br><span class="line">var2;   <span class="hljs-comment">// undefinde;</span></span><br><span class="line">undefinedVar;    <span class="hljs-comment">// ReferenceError:undefinedVar is not defined</span></span><br></pre></td></tr></table></figure><p>let을 쓰면 변수를 선언하기 전에 사용하려 할때 에러가 일어 납니다.<br>반면 var로 변수를 선언하면 선언하기도 전에 사용 할 수 있습니다.</p><h3 id="호이스팅"><a href="#호이스팅" class="headerlink" title="호이스팅"></a>호이스팅</h3><p>var로 선언한 변수는 <code>호이스팅</code>이라는 메커니즘을 따릅니다.<br>자바스크립트는 함수나 전역스코프 전체를 살펴보고 var로 선언한 변수를 <code>맨 위</code>로 끌어올립니다.(여기서 중요한 것은 <strong>선언만 끌어올려진다는 것</strong>이며, 할당을 끌어 올려지지 않는다는 것이다.)</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 원래코드</span></span><br><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(x ===<span class="hljs-number">3</span>)&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 자바스크립트가 해석한 코드</span></span><br><span class="line"><span class="hljs-keyword">var</span> x;</span><br><span class="line">x = <span class="hljs-number">3</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(x === <span class="hljs-number">3</span>)&#123;</span><br><span class="line">    x = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>위의 예제를 보면 같은 함수나 전역스코프 안에서는 var로 <code>새 변수</code>를 만들수 없으며 let으로 가능 했던 변수숨김도 불가능하다.<br>(블록 안에서 두번째 var문을 썻지만 변수x는 하나뿐이다.)</p><h2 id="함수-호이스팅"><a href="#함수-호이스팅" class="headerlink" title="함수 호이스팅"></a>함수 호이스팅</h2><p>함수 선언도 스코프 맨 위로 끌어올려집니다.<br>따라서 함수를 언언하기 전에 호출 할 수 있습니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f();                   <span class="hljs-comment">// 'f'</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'f'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>단, 변수에 할당한 함수 표현식은 끌어올려지지 않습니다. 이들은 변수의 스코프 규칙을 그래도 따릅니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f();                   <span class="hljs-comment">// ReferrenceError: f 는 정의되지 않았습니다.</span></span><br><span class="line"><span class="hljs-keyword">let</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'f'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="사각지대"><a href="#사각지대" class="headerlink" title="사각지대"></a>사각지대</h2><p>스코프안에서 변수의 사각지대는 변수가 선언되기 전의 코드입니다. ES6 이전에 주의 해야한다.</p><h2 id="스트릭트-모드"><a href="#스트릭트-모드" class="headerlink" title="스트릭트 모드"></a>스트릭트 모드</h2><p>스트릭트 모드에서는 암시적 전역 변수를 허용하지 않습니다.<br>스트릭트 모드를 사용하려면 문자열 <strong>“use strict”(작은 따옴표도 가능)</strong> 하나만으로 이루언진 행을 <strong>코드 맨 앞</strong>에 쓰면 됩니다.<br>전역스코프에서 사용하면 스크립트 전체가 스트릭트 모드로 실행되고, 함수 안에서 사용하면 해당 함수만 스트릭트 모드로 실행됩니다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/07/12/Learning-JavaScript-chapter7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 6. 함수</title>
      <link>http://mishka86.github.io/2019/07/05/Learning-JavaScript-chapter6/</link>
      <guid>http://mishka86.github.io/2019/07/05/Learning-JavaScript-chapter6/</guid>
      <pubDate>Fri, 05 Jul 2019 14:28:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;함수(function)는 하나의 단위로 실행되는 문의 집합, 일종의 부속프로그램으로 볼 수도 있다.&lt;br&gt;함수를 호출 할 때는 이름 다음에 괄호를 쓴다.&lt;/p&gt;
&lt;h2 id=&quot;반환값&quot;&gt;&lt;a href=&quot;#반환값&quot; class=&quot;headerlink&quot; title=&quot;반환값&quot;&gt;&lt;/a&gt;반환값&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;함수 바디 안에 return키워드를 사용하면 함수를 즉시 종료하고 값을 반환한다.&lt;br&gt;return을 명시적으로 호출하지 안으면 반환값은 undefined가 됩니다.&lt;br&gt;함수는 어떤 타입의 값이라도 반환 할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>함수(function)는 하나의 단위로 실행되는 문의 집합, 일종의 부속프로그램으로 볼 수도 있다.<br>함수를 호출 할 때는 이름 다음에 괄호를 쓴다.</p><h2 id="반환값"><a href="#반환값" class="headerlink" title="반환값"></a>반환값</h2><blockquote><p>함수 바디 안에 return키워드를 사용하면 함수를 즉시 종료하고 값을 반환한다.<br>return을 명시적으로 호출하지 안으면 반환값은 undefined가 됩니다.<br>함수는 어떤 타입의 값이라도 반환 할 수 있습니다.</p></blockquote><a id="more"></a><h2 id="호출과-참조"><a href="#호출과-참조" class="headerlink" title="호출과 참조"></a>호출과 참조</h2><p>자바스크립트에서는 함수도 객체 따라서 다른개체와 마찬가지로 넘기거나 할당 할 수 있다. </p><blockquote><ul><li>함수 식별자 뒤에 괄호를 쓰면 자바스크립트는 함수를 <code>호출</code>한다. 그리고 함수를 호출한 표현식은 반환값이 된다.</li><li>괄호를 쓰지않으면 다른 값과 마찬가지로 함수를 <code>참조</code>하는 것이며, 그 함수 는 실행되지 않는다.</li></ul></blockquote><p>함수를 변수에 할당하면 <strong>다른 이름으로 함수를 호출</strong> 할 수 있다.<br>함수를 객체 프로퍼티에 할당 할 수도 있다. 배열 요소로 할당 할 수도 있다.</p><h2 id="함수와-매개변수"><a href="#함수와-매개변수" class="headerlink" title="함수와 매개변수"></a>함수와 매개변수</h2><p>함수를 호출하면서 정보를 전달 할때는 함수 매겨변수를 이용한다.<br>매개변수는 함수가 호출되기 전에는 존재하지 않는다는 점을 제외하면 일반적인 변수나 마찬가지이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">avg</span>(<span class="hljs-params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span>(a+b)/<span class="hljs-number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 함수 선언에서 a와b를 정해진 매개변수를 한 개 전달하든 같은 함수를 호출 하는 것이다.<br>다시 말해 어떤 함수를 그 함수에서 정해진 매개변수 숫자와 관계없이 몇 개의 매개 변수를 전달해도 됩니다.<br>정해진 매개변수에 값을 제공하지 않으면 암묵적을 undefined가 할당됩니다.</p><h2 id="매개변수-해체"><a href="#매개변수-해체" class="headerlink" title="매개변수 해체"></a>매개변수 해체</h2><p>매개변수도 해체 할 수 있다. 해체 할당과 마찬가지로 프로퍼티 이름은 반드시 유효한 식별자여야 하고,<br>들어오는 객체에 해당 프로퍼티가 없는 변수는 <code>undefined</code>를 할당받습니다.<br>확산 연산자를 써서 남는 매개변수를 이용 할 수 있습니다.<br>함수를 선언 할 때 확산 연산자는 <strong>반드시 마지막 매개변수</strong>여야 합니다.<br>확산 연산자 뒤에 다른 매개변수가 있으면 값 중 어디까지를 확산 매개변수에 할당 해야 하는지 판단 할 수 없어 에러를 일으킨다.</p><h2 id="매개변수-기본값"><a href="#매개변수-기본값" class="headerlink" title="매개변수 기본값"></a>매개변수 기본값</h2><p>ES6에서 추가, 일반적으로 매개변수에 값을 제공하지 않으면 <code>undefined</code>가 값으로 할당됩니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a,b= <span class="hljs-string">"default"</span>, c=<span class="hljs-number">3</span></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span> - <span class="hljs-subst">$&#123;b&#125;</span> - <span class="hljs-subst">$&#123;c&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>);    <span class="hljs-comment">// "5 - 6 - 7"</span></span><br><span class="line">f(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);      <span class="hljs-comment">// "5 - 6 - 3"</span></span><br><span class="line">f(<span class="hljs-number">5</span>);        <span class="hljs-comment">// "5 -default -3"</span></span><br><span class="line">f();         <span class="hljs-comment">// "undefined - default - 3"</span></span><br></pre></td></tr></table></figure><h2 id="객체의-프로퍼티인-함수"><a href="#객체의-프로퍼티인-함수" class="headerlink" title="객체의 프로퍼티인 함수"></a>객체의 프로퍼티인 함수</h2><p>객체의 프로퍼티인 함수를 메서드라고 불러서 일반적인 함수와 구별합니다.<br>ES6에서는 간편하게 메서드를 추가 할 수 있는 문법이 생겼다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> o = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Wallace'</span>,                        <span class="hljs-comment">// 원시 값 프로퍼티</span></span><br><span class="line">    bark: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Woof!'</span>; &#125;    <span class="hljs-comment">// 함수 프로퍼티(메서드)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ES6</span></span><br><span class="line"><span class="hljs-keyword">const</span> o = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Wallace'</span>,              <span class="hljs-comment">// 원시 값 프로퍼티</span></span><br><span class="line">    bark() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Woof!'</span>; &#125;    <span class="hljs-comment">// 함수 프로퍼티(메서드)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this키워드"><a href="#this키워드" class="headerlink" title="this키워드"></a>this키워드</h2><p>함수 바디 안에는 특별한 읽기 전용값이 this가 있다.<br>일반적으로 this는 객체의 프로퍼티인 함수에서 의미가 있다.<br>this는 함수를 어떻게 선언했느냐가 아니라 어떻게 호촐했느냐에 따라 달라진다는 것을 이해해야 한다.<br>중첩된 함수 안에서 this를 사용하려다 보면 혼랑을 야기한다. 이러한 문제해결을 위해 다른 변수에 this를 할당해서 사용한다.<br>ES6에서는 화살표함수를 써도 이 문제를 해결 할 수 있다.</p><h2 id="함수-표현식과-익명함수"><a href="#함수-표현식과-익명함수" class="headerlink" title="함수 표현식과 익명함수"></a>함수 표현식과 익명함수</h2><p>익명 함수에서는 함수에 식별자가 주어지지 않습니다.<br>함수 표현식은 함수를 선언하는 한 가지 방법일 뿐이며, 그 함수가 익명이 될 수도 있을 뿐이다.<br>함수 표현식은 식별자에 할당 할 수도 있고 즉시 호출 할 수도 있다. 함수 표현식은 함수 이름을 생략 할 수 있다는 점을 제외하면 함수 선언과 문법적으로 완전히 같다.</p><figure class="highlight javascript hljs"><figcaption><span>함수 표현식</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 기명함수</span></span><br><span class="line"><span class="hljs-keyword">const</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 익명함수</span></span><br><span class="line"><span class="hljs-keyword">const</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적인 함수 선언과 마찬가지로 <code>f()</code>로 함수를 호출 할 수 있다.<br>차이점은 먼저 함수 표현식으로 익명함수를 만들고 그 함수를 변수에 할당했다는 것이다.</p><p>익명함수는 어디든 쓸 수 있다.<br>다른 함수나 메서드의 매개변수로 넘길 수도 있고, 객체의 함수 프로퍼티가 될 수도 있다.<br>-재귀함수 </p><h2 id="컨택스트의-차이"><a href="#컨택스트의-차이" class="headerlink" title="컨택스트의 차이"></a>컨택스트의 차이</h2><p>함수선언이 표현식으로 사용됐다면 그건 <strong>함수 표현식</strong>, 표현식으로 사용되지 않았다면 함수 선언</p><h2 id="화살표-표기법"><a href="#화살표-표기법" class="headerlink" title="화살표 표기법"></a>화살표 표기법</h2><p>funtion이라는 단어와 중괄호 숫자를 줄이려고 고안된 단축문법</p><blockquote><ul><li>화살표 함수의 세가지 단축문법</li></ul><ol><li>function을 생략해도 됩니다.</li><li>함수에 매개변수가 단 하나 뿐이라면 괄호()도 생략 할 수 있습니다.</li><li>함수 바디가 표현식 하나라면 중괄호와 return문도 생략 할 수 있습니다.</li></ol></blockquote><p>화살표 함수는 <code>항상 익명</code>입니다. 변수에 할당 할수는 있지만 이름 붙은 함수를 만들 수는 없다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> f1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"hello!"</span>; &#125;</span><br><span class="line"><span class="hljs-comment">// 또는</span></span><br><span class="line"><span class="hljs-keyword">const</span> f1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">"hello!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>; &#125;</span><br><span class="line"><span class="hljs-comment">// 또는</span></span><br><span class="line"><span class="hljs-keyword">const</span> f2 = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-string">`Hello, $(name)!`</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> f3 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>) </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="hljs-comment">// 또는</span></span><br><span class="line"><span class="hljs-keyword">const</span> f3 = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure><p>화살표표기법은 단순한 단축문법에 그치는 것이 아니라 <code>함수형 프로그래밍</code>을 자바스크립트에 도입하는 중요한 열쇠이다.<br>또 다른 차이는 객체 생성자로 사용 할 수 없고, arguments 변수도 사용 할 수 없다. </p><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call, apply, bind"></a>call, apply, bind</h2><p>자바스크립트에서는 일반적인 방법 외에도, 함수를 어디서, 어떻게 호출 했느냐와 상관없이<br>this가 무엇인지 지정 할 수 있습니다.<br>call 메서드는 모든 함수에서 사용 할 수 있으며, this를 특정 값으로 지정할 수 있습니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> bruce = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Bruce"</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">const</span> madeline = &#123; <span class="hljs-attr">name</span> : <span class="hljs-string">"Madeline"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 이 함수는 어떤 객체에도 연결되지 않았지만 this를 사용합니다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, I'm <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet();                 <span class="hljs-comment">// "Hello, I'm undefined!" - this는 어디에도 묶이지 않았습니다.</span></span><br><span class="line">greet.call(bruce);       <span class="hljs-comment">// "Hello, I'm Bruce!" - this는 bruce 입니다.</span></span><br><span class="line">greet.call(madeline);    <span class="hljs-comment">// "Hello, I'm Madeline!" - this는 madeline 입니다.</span></span><br></pre></td></tr></table></figure><p>함수를 호출하면서 call를 사용하고 this로 사용할 객체를 넘기면 해당 함수가 주어진 객체의 메서드인 것처럼 사용 할 수 있다.<br>call의 첫번째 매개변수는 this로 사용할 값이고, 매개변수가 더 있으면 그 매개변수는 호출하는 함수로 전달된다.</p><p>apply는 함수 매개변수처리 방법만 제외하고 call과 같습니다.<br>call은 함수와 마찬가지로 매개변수를 직접 받지만 apply는 매개변수를 배열로 받습니다.</p><p>apply는 배열 요소를 함수 매개변수로 사용해야 할 때 유용하다.<br>ES6의 확장연산자(…)를 사용해도 apply와 같은 결과를 얻을 수 있다.</p><p>bind를 사용하면 함수의 함수의 <code>this값을 영구히 바꿀 수 있다</code>.bind에 매개변수를 넘기면 항상 그 매개변수를 받으면서 호출되는 새 함수를 만드는 효과가 있다.</p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/07/05/Learning-JavaScript-chapter6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 5. 표현식과 연산자</title>
      <link>http://mishka86.github.io/2019/07/05/Learning-JavaScript-chapter5/</link>
      <guid>http://mishka86.github.io/2019/07/05/Learning-JavaScript-chapter5/</guid>
      <pubDate>Fri, 05 Jul 2019 08:14:18 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 챕터에서는 표현식과 연산자에 대해 알아보는 챕터였다. 실습보다는 이론적인 부분들이 많았다.&lt;/p&gt;
&lt;h2 id=&quot;표현식&quot;&gt;&lt;a href=&quot;#표현식&quot; class=&quot;headerlink&quot; title=&quot;표현식&quot;&gt;&lt;/a&gt;표현식&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;값으로 평가될 수 있는 문&lt;/strong&gt; 즉 결과가 값인 문과, 표현식이 아닌 문의 차이를 이해한다.&lt;br&gt;표현식이 아닌 문은 일종의 &lt;code&gt;지시&lt;/code&gt;라고 생각 할 수있고, 표현식은 &lt;code&gt;무언가를 요청&lt;/code&gt;하는 것이라고 생각 할 수 있다.&lt;/p&gt;
&lt;p&gt;표현식은 값이 된다. 그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있다. 그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있다. 표현식이 아닌 문은 이런 식의 결합을 할 수 있다. &lt;/p&gt;
&lt;p&gt;표현식은 값이 되므로 할당에 쓸 수 있다. 즉 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 챕터에서는 표현식과 연산자에 대해 알아보는 챕터였다. 실습보다는 이론적인 부분들이 많았다.</p><h2 id="표현식"><a href="#표현식" class="headerlink" title="표현식"></a>표현식</h2><p><strong>값으로 평가될 수 있는 문</strong> 즉 결과가 값인 문과, 표현식이 아닌 문의 차이를 이해한다.<br>표현식이 아닌 문은 일종의 <code>지시</code>라고 생각 할 수있고, 표현식은 <code>무언가를 요청</code>하는 것이라고 생각 할 수 있다.</p><p>표현식은 값이 된다. 그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있다. 그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있다. 표현식이 아닌 문은 이런 식의 결합을 할 수 있다. </p><p>표현식은 값이 되므로 할당에 쓸 수 있다. 즉 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다.</p><a id="more"></a><h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><p>표현식이 값이 되는 것이라면 <strong>연산자</strong>는 <code>값을 만드는 행동</code>이라는 뜻이다.<br>연산자는 <code>하나 이상의 피연산자</code>가 있어야 결과를 낼 수 있다. 피연산자를 <em>매개변수</em>라 부르는 경우도 있다.</p><h3 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h3><table><thead><tr><th>연산자</th><th>설명</th><th>예제</th><th></th></tr></thead><tbody><tr><td>+</td><td>덧셈(문자열 병합에도 쓰임)</td><td>3 + 2</td><td>5</td></tr><tr><td>-</td><td>뺄셈</td><td>3 - 2</td><td>1</td></tr><tr><td>/</td><td>나눗셈</td><td>3/2</td><td>1.5</td></tr><tr><td>*</td><td>곱셈</td><td>3*2</td><td>6</td></tr><tr><td>%</td><td>나머지</td><td>3%2</td><td>1</td></tr><tr><td>-</td><td>단항 부정</td><td>-x</td><td>x의 부호를 바꿉니다. x가 5이면 -x는 -5입니다.</td></tr><tr><td>+</td><td>단항 플러스</td><td>+x</td><td>x가 숫자가 아니면 숫자로 변환을 시도합니다.</td></tr><tr><td>++</td><td>전위 증가</td><td>++x</td><td>x에 1을 더한 다음 평가합니다.</td></tr><tr><td>++</td><td>후위 증가</td><td>x++</td><td>x를 평가한 다음 1을 더합니다.</td></tr><tr><td>–</td><td>전위 감소</td><td>–x</td><td>x에서 1을 뺀 다름 평가합니다.</td></tr><tr><td>–</td><td>후위 감소</td><td>x–</td><td>x의 값을 평가한 다음 1을 뺍니다.</td></tr></tbody></table><p>뺄셈과 단항 부정은 같은 -기호를 사용<br>단항 부정이 먼저 이루어지고 그 다음에 뺄셈을 한다.<br>나머지 연산자는 나눗셈을 한 나머지를 반환</p><h3 id="증가연산자-감소연산자-–"><a href="#증가연산자-감소연산자-–" class="headerlink" title="증가연산자(++),감소연산자(–)"></a>증가연산자(++),감소연산자(–)</h3><blockquote><p>할당 연산자와 덧셈연산자,뺄셈 연산자를 하나로 합친거나 다름없다.<br>전위와 후위의 차이의 이해가 필요하다.</p></blockquote><p><code>전위 연산자</code>는 먼저 변수의 값을 바꾼 다음에 평가, <code>후위 연산자</code>는 값을 바꾸기 전에 평가한다.</p><h3 id="연산자-우선-순위"><a href="#연산자-우선-순위" class="headerlink" title="연산자 우선 순위"></a>연산자 우선 순위</h3><p>현재 자바스크립트에는 56개의 연산자가 있고, 우선순위를 기준으로 19개의 그룹으로 묶을 수 있다.<br>우선순위가 같은 연산자들은 오른쪽에서 왼쪽으로 또는 왼쪽에서 오른쪽으로 평가한다.<br><img src="/img/Priority.jpg" alt></p><h2 id="비교연산자"><a href="#비교연산자" class="headerlink" title="비교연산자"></a>비교연산자</h2><p>비교연산자는 이름처럼 두 개의 값을 비교한다.<br><strong>일치함(===)</strong>, <strong>동등함(==)</strong>, <strong>관계연산자</strong> 이렇게 세가지 타입으로 나뉜다.</p><blockquote><p>두 값이 같은 개체를 가리키거나, 같은 타입이고 값(원시타입)도 같다면 이 값을 <strong>일치</strong>한다고 한다.<br>두 값이 같은 개체를 가리키거나, 같은 값을 갖도록 변환할 수 있다면 두 값을 <strong>동등</strong>하다고 한다.<br>관계연산자에는 작다(&lt;), 작거나 같다(&lt;=), 크다(&gt;), 크거나 같다(&gt;=) 네가지가 있다.</p></blockquote><h2 id="숫자비교"><a href="#숫자비교" class="headerlink" title="숫자비교"></a>숫자비교</h2><blockquote><p>특별한 숫자형 값 NAN은 <strong>그 자신을 포함하여 무엇과도 같지 않다.</strong><br>숫자가 NAN인지 알아보려면 내장된 <strong>isNAN 함수</strong>를 사용해야한다.<br>자바스크립트의 숫자는 모두 <code>더블</code> 형식이다.</p></blockquote><h2 id="문자열-병합"><a href="#문자열-병합" class="headerlink" title="문자열 병합"></a>문자열 병합</h2><blockquote><p>+연산자는 <code>덧셈</code>과 <code>문자열 병합</code>에 모두 사용<br>자바스크립트는 <strong>피연산자의 타입</strong>을 보고 덧셈을 할지 문자열 병합을 할지 판단<br>덧셈과 문자열병합은 모두 <strong>왼쪽에서 오른쪽</strong>으로 평가합니다.<br>평가후 피연산자 중 <strong>하나라도 문자열</strong>이면 <code>문자열 병합</code>을 수행<br>두 값이 <strong>모두 숫자형</strong>이면 <code>덧셈</code>을 수행</p></blockquote><h2 id="논리연산자"><a href="#논리연산자" class="headerlink" title="논리연산자"></a>논리연산자</h2><p>불리언 값만 다룰 수 있다. - true, false<br>참 같은 값과 거짓 같은 값 - truthy, falsy</p><blockquote><ul><li>자바스크립트의 거짓 같은 값<br>undefined<br>null<br>false<br>0NAN<br>‘’(빈문자열)</li></ul></blockquote><p>위의 6가지 외에는 모두 참 같은 값이다. </p><blockquote><ul><li>참 같은 값 몇 가지 예시<br>모든 객체, valueOf() 메서드를 호출했을때 false를 반환하는 객체<br>배열,빈 배열 - 공백만 있는 문자열<br>문자열 “false”</li></ul></blockquote><h2 id="AND-OR-NOT"><a href="#AND-OR-NOT" class="headerlink" title="AND, OR, NOT"></a>AND, OR, NOT</h2><p><strong>AND(&amp;&amp;) 연산의 진위표</strong></p><table><thead><tr><th>x</th><th>y</th><th>x &amp;&amp; y</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>flase</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table><p>AND 연산은 피연산자가 모두 true일때만 true</p><p><strong>OR(||) 연산의 진위표</strong></p><table><thead><tr><th>x</th><th>y</th><th>x II y</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>true</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table><p>OR 연산은 피연산자가 모두 false일때만 false</p><p><strong>NOT(!) 연산의 진위표</strong></p><table><thead><tr><th>x</th><th>!x</th></tr></thead><tbody><tr><td>false</td><td>true</td></tr><tr><td>true</td><td>false</td></tr></tbody></table><p>NOT연산은 피연산자를 반대로 바꿈</p><h2 id="단축평가"><a href="#단축평가" class="headerlink" title="단축평가"></a>단축평가</h2><p>x &amp;&amp; y 에서 x가 거짓 같은 값이면 y의 값을 평가할 필요없이 false이다.<br>x || y 에서 x가 참 같은 갑이면 y를 평가할 필요없이 true이다.<br>이러한 방식으로 동작하며 이를 <code>단축평가</code> 라고 한다.</p><blockquote><p>단축평가가 중요한 이유는 두번째 피연산자에 부수효과가 있다 하더라고<br>단축평가를 거치면 그 효과는 일어나지 않기 때문이다.</p></blockquote><h3 id="피연산자가-불리언이-아닐때-논리-연산자가-동작하는-방법"><a href="#피연산자가-불리언이-아닐때-논리-연산자가-동작하는-방법" class="headerlink" title="피연산자가 불리언이 아닐때 논리 연산자가 동작하는 방법"></a>피연산자가 불리언이 아닐때 논리 연산자가 동작하는 방법</h3><p>불리언 피연산자를 사용하면 논리 연산자는 항상 불리언을 반환한다.<br>피연산자가 불리언이 아니라면 결과를 결정한 값이 반환된다.</p><p><strong>불리언이 아닌 피연산자에 대한 AND(&amp;&amp;)의 진위표</strong></p><table><thead><tr><th>x</th><th>y</th><th>x &amp;&amp; y</th></tr></thead><tbody><tr><td>거짓 같은 값</td><td>거짓 같은 값</td><td>x (거짓 같은 값)</td></tr><tr><td>거짓 같은 값</td><td>참 같은 값</td><td>x (거짓 같은 값)</td></tr><tr><td>참 같은 값</td><td>거짓 같은 값</td><td>y (거짓 같은 값)</td></tr><tr><td>참 같은 값</td><td>참 같은 값</td><td>y (참 같은 값)</td></tr></tbody></table><p><strong>불리언이 아닌 피연산자에 대한 AND(&amp;&amp;)의 진위표</strong></p><table><thead><tr><th>x</th><th>y</th><th>x II y</th></tr></thead><tbody><tr><td>거짓 같은 값</td><td>거짓 같은 값</td><td>y (거짓 같은 값)</td></tr><tr><td>거짓 같은 값</td><td>참 같은 값</td><td>y (참 같은 값)</td></tr><tr><td>참 같은 값</td><td>거짓 같은 값</td><td>x (참 같은 값)</td></tr><tr><td>참 같은 값</td><td>참 같은 값</td><td>x (참 같은 값)</td></tr></tbody></table><p>결과를 불리언으로 변환하면 불리언 값을 제공했을 때의 진위표와 같은 결과가 된다.</p><h2 id="조건연산자"><a href="#조건연산자" class="headerlink" title="조건연산자"></a>조건연산자</h2><p>자바스크립트의 유일한 3항 연산자<br>피연산자 세개를 받습니다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">조건식 ? 조건식이 ture일때 반환할 값 : 조건식이 false일때 반환할 값</span><br></pre></td></tr></table></figure><h2 id="쉼표연산자"><a href="#쉼표연산자" class="headerlink" title="쉼표연산자"></a>쉼표연산자</h2><p>쉼표연산자는 표현식을 결합하여 두 표현식을 평가하 후, 두 번째 표현식의 결과를 반환한다.<br>표현식을 하나 이상 실행해야 하지만 값으로 필요 것은 마지막 표현식의 결과 뿐일 때 쉼표 연산자를 유용하게 쓸 수 있다.</p><h2 id="그룹연산자"><a href="#그룹연산자" class="headerlink" title="그룹연산자"></a>그룹연산자</h2><p>그룹연산자<code>()</code>에는 아무 효과도 없지만 연산자 우선 순위를 높이거나 명확히 표현하는데 쓸 수 있다.<br>연산 순서만 바꿀 뿐 다른 부작용은 없다.</p><h2 id="비트연산자"><a href="#비트연산자" class="headerlink" title="비트연산자"></a>비트연산자</h2><h2 id="typeof연산자"><a href="#typeof연산자" class="headerlink" title="typeof연산자"></a>typeof연산자</h2><p>typeof연산자는 피연산자의 타입을 나타내는 문자열을 반환한다.<br>자바스크립트의 일곱가지 데이터 타입을 정확히 나타내지 못한다. (null을 “object”로 판단)</p><h2 id="void연산자"><a href="#void연산자" class="headerlink" title="void연산자"></a>void연산자</h2><p>피연산자를 평가한 후 undefined를 반환한다.</p><h2 id="할당연산자"><a href="#할당연산자" class="headerlink" title="할당연산자"></a>할당연산자</h2><p>변수에 값을 할당한다.<br>등호에 왼쪽에 잇는 것은 반드시 변수나 프로퍼티, 배열 요소 중 하나여야 한다.(상수에 값을 할당 하는 것은 엄밀히 말하면 선언이다.)<br>즉 표현식의 왼쪽에 있는 것은 반드시 값을 저장 할 수 있는 것이어야 한다.</p><h3 id="간편할당연산자"><a href="#간편할당연산자" class="headerlink" title="간편할당연산자"></a>간편할당연산자</h3><p>연산과 할당을 한꺼번에 수행한다.</p><table><thead><tr><th>연산자</th><th>동등한 표현</th></tr></thead><tbody><tr><td>x += y</td><td>x = x + y</td></tr><tr><td>x -= y</td><td>x = x - y</td></tr><tr><td>x *= y</td><td>x = x * y</td></tr><tr><td>x /= y</td><td>x = x / y</td></tr><tr><td>x %= y</td><td>x = x % y</td></tr><tr><td>x &lt;&lt;= y</td><td>x = x &lt;&lt; y</td></tr><tr><td>x &gt;&gt;= y</td><td>x = x &gt;&gt; y</td></tr><tr><td>x &gt;&gt;&gt;= y</td><td>x = x &gt;&gt;&gt; y</td></tr><tr><td>x &amp;= y</td><td>x = x &amp; y</td></tr><tr><td>x I= y</td><td>x = x I y</td></tr><tr><td>x ^= y</td><td>x = x ^ y</td></tr></tbody></table><h2 id="해체할당"><a href="#해체할당" class="headerlink" title="해체할당"></a>해체할당</h2><p>ES6에 새로 도입<br>객체나 배열을 변수로 해체 할 수 있다.</p><figure class="highlight bash hljs"><figcaption><span>해체할당</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//객체선언</span><br><span class="line">cosnt obj = &#123; b:2, c:3, d:4 &#125;</span><br><span class="line"></span><br><span class="line">//해체할당</span><br><span class="line">const &#123;a,b,c&#125; = obj;</span><br><span class="line">a;      //undefined : obj에는 <span class="hljs-string">"a"</span> 프로퍼티가 없습니다.</span><br><span class="line">b;      // 2</span><br><span class="line">c;      // 3</span><br><span class="line">d;      // ReferenceError: <span class="hljs-string">"d"</span>는 정의되지 않았습니다.</span><br></pre></td></tr></table></figure><blockquote><ul><li>객체를 해체할 때는 반드시 변수 이름과 객체의 프로퍼티 이름이 일치해야 한다. 프로퍼티 이름이 유효한 식별자인 프로퍼티만 해체 후 할당 된다.</li><li>객체 해체는 할당만으로 이뤄질 수도 있지만 그렇게 하려면 반드시 괄호를 써야한다.</li><li>배열을 해체할 때는 배열 요소에 대응할 변수 이름을 마음대로 쓸 수 있으며 이들은 배열 순서대로 대응한다.</li><li>확산 연산자를 사용하면 남은 요소를 새 배열에 할당 할 수 있다. - 배열 해체는 꼭 배열에만 사용 할수 있는 것은 아니다, 이터러블 객체에는 모두 사용 할 수있다.</li></ul></blockquote>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/07/05/Learning-JavaScript-chapter5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Disqus를 사용하여 댓글 기능 세팅하기</title>
      <link>http://mishka86.github.io/2019/07/02/hexo-comment-disqus/</link>
      <guid>http://mishka86.github.io/2019/07/02/hexo-comment-disqus/</guid>
      <pubDate>Tue, 02 Jul 2019 05:56:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;오늘은 블로그의 세팅중 한가지인 댓글 기능을 세팅하는 방법에 대해 포스팅해보겠습니다. 사실 hexo 테마들의 대부분은 여러 댓글 시스템들을 간편하게 세팅 할 수 있도록 되어있습니다.&lt;br&gt;그 중에 &lt;code&gt;디스커스(Disqus)&lt;/code&gt;를 사용하여 댓글 기능을 세팅해보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;디스커스-Disqus-란&quot;&gt;&lt;a href=&quot;#디스커스-Disqus-란&quot; class=&quot;headerlink&quot; title=&quot;디스커스(Disqus)란?&quot;&gt;&lt;/a&gt;디스커스(Disqus)란?&lt;/h2&gt;&lt;p&gt;디스커스는 &lt;code&gt;소셜 댓글 서비스&lt;/code&gt;의 하나입니다. 소셜 댓글 서비스란 소셜미디어(SNS)를 활용한 댓글 시스템으로 페이스북,트위터 와 같은 SNS와 연동해서 댓글을 달 수 있게 만들어 주는 서비스입니다. 소셜 댓글 서비스를 활용하여 댓글을 달면 동시에 해당 댓글이 자신이 연동한 SNS에도 발행이 됩니다.&lt;br&gt;별도의 댓글시스템을 구현할 필요없이 디스커스에서 제공하는 위젯을 설치함으로 사용 할 수 있는 것이 장점입니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>오늘은 블로그의 세팅중 한가지인 댓글 기능을 세팅하는 방법에 대해 포스팅해보겠습니다. 사실 hexo 테마들의 대부분은 여러 댓글 시스템들을 간편하게 세팅 할 수 있도록 되어있습니다.<br>그 중에 <code>디스커스(Disqus)</code>를 사용하여 댓글 기능을 세팅해보겠습니다.</p><h2 id="디스커스-Disqus-란"><a href="#디스커스-Disqus-란" class="headerlink" title="디스커스(Disqus)란?"></a>디스커스(Disqus)란?</h2><p>디스커스는 <code>소셜 댓글 서비스</code>의 하나입니다. 소셜 댓글 서비스란 소셜미디어(SNS)를 활용한 댓글 시스템으로 페이스북,트위터 와 같은 SNS와 연동해서 댓글을 달 수 있게 만들어 주는 서비스입니다. 소셜 댓글 서비스를 활용하여 댓글을 달면 동시에 해당 댓글이 자신이 연동한 SNS에도 발행이 됩니다.<br>별도의 댓글시스템을 구현할 필요없이 디스커스에서 제공하는 위젯을 설치함으로 사용 할 수 있는 것이 장점입니다.</p><a id="more"></a><h2 id="설치순서"><a href="#설치순서" class="headerlink" title="설치순서"></a>설치순서</h2><blockquote><ol><li>Disqus <strong>회원가입</strong></li><li>Settings &gt; <strong>profile, Account</strong> 수정</li><li>Add Disqus To Site &gt; <strong>I Want to comment on site</strong> 사이트 추가</li><li>Account &gt; <strong>Username</strong> 확인 (shortname)</li><li><strong>_config.yml</strong> 설정 변경 </li></ol></blockquote><h2 id="회원가입"><a href="#회원가입" class="headerlink" title="회원가입"></a>회원가입</h2><p>Disqus 회원이 아니라면 회원가입이 필요합니다.<br><a href="https://disqus.com" rel="external nofollow noopener noreferrer" target="_blank">Disqus 사이트</a>에서 회원가입을 진행합니다.</p><p><img src="/img/disqus_main.jpg" alt></p><h2 id="정보-수정"><a href="#정보-수정" class="headerlink" title="정보 수정"></a>정보 수정</h2><p>Settings 에 <code>profile</code> 과 <code>Account</code>에서 필요한 정보들을 수정해 줍니다.</p><p><img src="/img/disqus_settings.jpg" alt></p><h2 id="사이트-추가"><a href="#사이트-추가" class="headerlink" title="사이트 추가"></a>사이트 추가</h2><p>우측 상단의 <code>Add Disqus To Site</code> 에 들어가서 <code>I Want to comment on site</code> 를 클릭 </p><p>혹은 메인에서 <code>GET STARTED</code> 에 들어가서 <code>I Want to comment on site</code> 를 클릭 </p><p>해당 정보들을 입력 후 <code>Select a plan</code> 에서 <code>Basic</code> 을 선택</p><p><img src="/img/disqus_select_plan.jpg" alt></p><p><code>Select Platform</code> 단계에서는 맨 아래의 <code>universal Code</code>를 선택해 줍니다.<br><img src="/img/disqus_universal_code.jpg" alt></p><p>여기는 테마마다 조금 다릅니다. 디스커스를 지원하는 테마라면 <code>configure</code> 누르고 사이트 세팅을 마친다음<br>_config.yml 의 설정만 변경 해주면 되고 안되어 있다면 소스를 추가해 주어야 한다. 그 때 이 코드를 사용하여 주면 됩니다.<br><a href="https://disqus.com/admin/install/platforms/universalcode/" rel="external nofollow noopener noreferrer" target="_blank">Installation instructions</a><br><img src="/img/disqus_code.jpg" alt> </p><h2 id="계정정보-확인"><a href="#계정정보-확인" class="headerlink" title="계정정보 확인"></a>계정정보 확인</h2><p>Account 에서 <code>Username(shortname)</code>을 확인하여 줍니다.</p><h2 id="config-yml-설정"><a href="#config-yml-설정" class="headerlink" title="_config.yml 설정"></a>_config.yml 설정</h2><figure class="highlight bash hljs"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comment:</span><br><span class="line">    <span class="hljs-built_in">type</span>: disqus</span><br><span class="line">    shortname: disqus 계정이름</span><br></pre></td></tr></table></figure><p>이 부분은 현재 제가 사용하는 <code>icarus</code> 테마의 _config.yml의 양식이고 테마마다 조금씩 다를수 있습니다. </p><h2 id="배포"><a href="#배포" class="headerlink" title="배포"></a>배포</h2><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>배포를 시켜주고 아래와 같이 나온다면 성공입니다.<br><img src="/img/disqus_comment.jpg" alt="Disqus 세팅완료"></p><h2 id="오류체크"><a href="#오류체크" class="headerlink" title="오류체크"></a>오류체크</h2><p><code>icarus</code>테마는 기본적으로 disqus 댓글 시스템을 지원하고 있어서 위와같이 세팅하면 정상적으로 댓글기능이 작동해야 하지만<br>무엇이 문제였는지 시스템 자체는 연결되었는데 댓글을 작성하는 위젯이 제대로 작동하지 않았다 ㅠㅜ<br><img src="/img/disqus_error.jpg" alt></p><p><code>icarus</code>테마에서 제공하는 포스팅에서도 comment Plugin 의 설정만을 변경해 주면된다고 나오는데 말이다.<br><a href="https://blog.zhangruipeng.me/hexo-theme-icarus/Plugins/Comment/disqus-comment-plugin/" rel="external nofollow noopener noreferrer" target="_blank">Disqus Comment Plugin</a></p><p>여러가지를 시도해 보다 결국 소스코드 자체를 변경하는 것으로 해결하였다.<br>icarus 테마의 경우 <code>disqus.ejs</code> 파일의 내용을 <code>universal Code</code>에서 제공하는 코드로 변경하니 정상적으로 작동되었다.<br>테마마다 약간의 설정이 다를수 있으니 참고정도만 하시면 되겠습니다.</p><h2 id="언어선택-문제"><a href="#언어선택-문제" class="headerlink" title="언어선택 문제"></a>언어선택 문제</h2><p>현재 disqus에서는 한글을 지원하지 않는 것으로 변경되었다고 한다.<br>그래서 편법으로 설정하는 방법이 있는데 편법이라 방법이 나와있는 포스팅을 공유하는 것으로 대체한다.<br><a href="https://jungjoongi.com/2018/10/30/disqus-korean-setting/" rel="external nofollow noopener noreferrer" target="_blank">디스커스 한글 세팅을 해보자</a></p>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/07/02/hexo-comment-disqus/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 4. 제어문</title>
      <link>http://mishka86.github.io/2019/06/27/Learning-JavaScript-chapter4/</link>
      <guid>http://mishka86.github.io/2019/06/27/Learning-JavaScript-chapter4/</guid>
      <pubDate>Thu, 27 Jun 2019 04:48:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번챕터에서는 제어문에 대해서 나와 있었다. 제어문은 크게 조건문과 반복문으로 나눌 수 있다.&lt;br&gt;대표적으로 조건문에는 if…else 문,switch 문이 있고 반복문에는 for 문, while 문 등이 있다.&lt;br&gt;제어문을 시각적으로 나타내는 방법에는 순서도가 있다.&lt;/p&gt;
&lt;h2 id=&quot;순서도&quot;&gt;&lt;a href=&quot;#순서도&quot; class=&quot;headerlink&quot; title=&quot;순서도&quot;&gt;&lt;/a&gt;순서도&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;순서도에서 마름모 모양은 예/아니오 인 결정이며 사각형은 행동입니다.&lt;/li&gt;
&lt;li&gt;시작과 끝은 원으로 나타냅니다.&lt;/li&gt;
&lt;li&gt;순서도를 프로그램으로 바꿀 때 중요한 것은 컴퓨터가 이해 할수 있는 말로 변환하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번챕터에서는 제어문에 대해서 나와 있었다. 제어문은 크게 조건문과 반복문으로 나눌 수 있다.<br>대표적으로 조건문에는 if…else 문,switch 문이 있고 반복문에는 for 문, while 문 등이 있다.<br>제어문을 시각적으로 나타내는 방법에는 순서도가 있다.</p><h2 id="순서도"><a href="#순서도" class="headerlink" title="순서도"></a>순서도</h2><blockquote><ul><li>순서도에서 마름모 모양은 예/아니오 인 결정이며 사각형은 행동입니다.</li><li>시작과 끝은 원으로 나타냅니다.</li><li>순서도를 프로그램으로 바꿀 때 중요한 것은 컴퓨터가 이해 할수 있는 말로 변환하는 것이다.</li></ul></blockquote><a id="more"></a><p><img src="/img/flowchart.jpg" alt="순서도 예시"></p><h2 id="블록문"><a href="#블록문" class="headerlink" title="블록문"></a>블록문</h2><blockquote><ul><li>제어문과 함께 쓰인다. </li><li>복합문(Compound Statement) 이라고도 함</li><li>문 여러개를 중괄호로 묶은것을 말한다.</li><li>한 줄 일때에는 블록문과 같이 사용하지 않아도 된다.</li></ul></blockquote><h2 id="공백"><a href="#공백" class="headerlink" title="공백"></a>공백</h2><blockquote><ul><li>자바스크립트는 줄바꿈 문자를 포함해, 추가 공백을 신경쓰지 않는다.</li><li>들여쓰기는 항상 의미가 명확히 드러나도록 써야 한다. </li></ul></blockquote><h2 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h2><h3 id="if…else-문"><a href="#if…else-문" class="headerlink" title="if…else 문"></a>if…else 문</h3><p>if…else 문은 주어진 조건식의 평가 결과, 즉 논리적 참,거짓에 따라 실행할 코드 블록을 결정하여 if 문 혹은 else 문을 실행합니다.<br>만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 <code>강제변환</code> 되어서 논리적 참,거짓을 구별합니다.</p><figure class="highlight javascript hljs"><figcaption><span>if...else 문의 문법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(조건식)&#123;</span><br><span class="line">    <span class="hljs-comment">// 조건식이 참이면 이 코드 블록을 실행합니다.</span></span><br><span class="line">&#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 조건식이 거짓이면 이 코드 블록을 실행합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>조건식을 추가 하고 싶으면 else if 문을 사용한다.<br>else if문과 else문은 옵션으로 사용 할 수도 있고 사용하지 않을 수도 있다.<br>if 문과 else문은 1번씩만 사용이 가능하고 else if문은 여러 번 사용이 가능하다. </p><h3 id="switch-문"><a href="#switch-문" class="headerlink" title="switch 문"></a>switch 문</h3><p>if 문은 두 가지 중 하나를 선택하지만 switch 문은 조건 하나로 여러가지 중 하나를 선택 할 수 있다.<br>다양하게 나뉘는 조건을 표현 할때 사용</p><figure class="highlight javascript hljs"><figcaption><span>switch 문의 문법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">switch</span>(표현식)&#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> value1:</span><br><span class="line">        <span class="hljs-comment">// 표현식을 평가한 결과가 value1 일때 실행</span></span><br><span class="line">        [<span class="hljs-keyword">break</span>;]</span><br><span class="line">    <span class="hljs-keyword">case</span> value2:</span><br><span class="line">        <span class="hljs-comment">// 표현식을 평가한 결과가 value2 일때 실행</span></span><br><span class="line">        [<span class="hljs-keyword">break</span>;]    </span><br><span class="line">    <span class="hljs-keyword">case</span> valueN:</span><br><span class="line">        <span class="hljs-comment">// 표현식을 평가한 결과가 valueN 일때 실행</span></span><br><span class="line">        [<span class="hljs-keyword">break</span>;]</span><br><span class="line">    <span class="hljs-keyword">default</span>:</span><br><span class="line">        <span class="hljs-comment">// 표현식을 평가한 결과가 없을때 실행</span></span><br><span class="line">        [<span class="hljs-keyword">break</span>;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>default 절은 일치하는 case 절이 없을 때 실행</li><li>필수는 아니지만, 보통 맨 마지막에 사용</li><li>break문이 없어도 되지만 사용하는 습관이 중요한다.</li><li>switch 문을 함수 안에서 사용 할때는 <code>return 문</code>을 <code>break 문</code> 대신해서 사용 할 수 있다.</li></ul></blockquote><h2 id="제어문의-예외"><a href="#제어문의-예외" class="headerlink" title="제어문의 예외"></a>제어문의 예외</h2><blockquote><ul><li>break - 루프 중간에 빠져 나갑니다.</li><li>continue - 루프에서 다음 단계로 바로 건너뜁니다.</li><li>return - 제어문을 무시 하고 현재 함수를 즉시 빠져나갑니다.</li><li>throw - 예외 핸들러에서 반드시 처리해야 할 예외를 일으킵니다. 예외 핸들러는 현재 제어문 바깥에 있어도 상관없습니다.</li></ul></blockquote><h2 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h2><h3 id="while-문"><a href="#while-문" class="headerlink" title="while 문"></a>while 문</h3><p>조건을 만족하는 동안 코드를 계속 반복한다.</p><figure class="highlight javascript hljs"><figcaption><span>while 문의 문법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span>(조건식)&#123;</span><br><span class="line">  <span class="hljs-comment">//조건식이 참이면 실행</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do…while문"><a href="#do…while문" class="headerlink" title="do…while문"></a>do…while문</h3><p>최소 한번은 실행 하려 할 때 사용합니다.</p><figure class="highlight javascript hljs"><figcaption><span>do...while 문의 문법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">do</span>&#123;</span><br><span class="line">  <span class="hljs-comment">//실행문</span></span><br><span class="line">&#125;<span class="hljs-keyword">while</span>(조건문)</span><br></pre></td></tr></table></figure><h3 id="for-문"><a href="#for-문" class="headerlink" title="for 문"></a>for 문</h3><p><code>while문</code>,<code>do...while문</code>은 모두 <code>for 문</code>으로 고쳐 쓸 수 있습니다. 어떤일을 정해진 숫자만큼 반복할거나 특히 그 일을 지금 몇번째 하는지 알아야 할때 사용합니다.</p><figure class="highlight javascript hljs"><figcaption><span>for 문의 문법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>( 초기화식; 조건식; 증감식)&#123;</span><br><span class="line">  <span class="hljs-comment">//조건식이 참인경우 실행문이 반복된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>for 문의 다른 패턴</li></ul><ol><li>쉼표 연산자를 쓰면 초기화와 마지막 표현식에 여러가지 문을 결합 할 수 있다,</li><li>보통 정수 인덱스를 늘이거나 줄이면서 반복하지만 꼭 그래야 하는 건 아니다.</li><li>어떤 표현식이든 쓸수 있다.(문자열, 정수가 아닌 수, 객체 프로퍼티)</li></ol><ul><li>장점 </li></ul><ol><li>제어부가 첫번째 행에 모여 있어서 일목요연하게 파악 할 수 있다.</li><li>초기화한 변수가 for문 안에서만 유효하다.(호이스팅)</li></ol></blockquote><h3 id="for-in-문"><a href="#for-in-문" class="headerlink" title="for..in 문"></a>for..in 문</h3><p>for…in 문은 객체의 프로퍼티에 루프를 실행 하도록 설계된 반복문이다.</p><figure class="highlight javascript hljs"><figcaption><span>for...in 문의 문법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(variable <span class="hljs-keyword">in</span> object)&#123;</span><br><span class="line">  <span class="hljs-comment">//실행문 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>for…in 문 주의사항<br>객체 리터럴에 쓴 순서대로 열거되지 않는다.(순서가 보장되지 않는다.)<br>열거 할 수 없는 프로퍼티가 존재한다.(객체의 모든 내장 메서드를 비롯해 각종 내장 프로퍼티 같은 비열거형 속성은 반복되지 않는다. 예:length)<br>프로토타입에서 상속한 프로터티도 나열한다.<br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" rel="external nofollow noopener noreferrer" target="_blank">hasOwnProperty 관련 참고링크</a></li></ul></blockquote><h3 id="for…of-문"><a href="#for…of-문" class="headerlink" title="for…of 문"></a>for…of 문</h3><p>ES6에서 새로 생긴 반복문, 컬렉션의 요소에 루프를 실행하는 다른 방법</p><figure class="highlight javascript hljs"><figcaption><span>for...of 문의 문법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(variable <span class="hljs-keyword">of</span> object)&#123;</span><br><span class="line">  <span class="hljs-comment">//실행문 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>배열은 물론 이터러블 객체(member를 하나씩 차례로 반환 가능한 object)에 모두 사용 할 수 있는 범용적인 루프<br>루프를 실행해야 하지만 각 요소의 인데스를 알 필요는 없을 때<br><a href="https://mollangk.tistory.com/28" rel="external nofollow noopener noreferrer" target="_blank">이터러블 관련 참고링크</a></p><h2 id="메타문법"><a href="#메타문법" class="headerlink" title="메타문법"></a>메타문법</h2><blockquote><p>다른 문법을 설명하는 문법</p></blockquote>]]></content:encoded>
      
      <comments>http://mishka86.github.io/2019/06/27/Learning-JavaScript-chapter4/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
