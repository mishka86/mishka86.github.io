<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mishka&#39;s Blog</title>
    <link>https://mishka.kr/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>미슈카의 개발 블로그 입니다.</description>
    <pubDate>Wed, 17 Jun 2020 10:26:14 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>타입스크립트 - 비동기 처리</title>
      <link>https://mishka.kr/2020/06/17/TypeScript-async/</link>
      <guid>https://mishka.kr/2020/06/17/TypeScript-async/</guid>
      <pubDate>Wed, 17 Jun 2020 09:10:11 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;HTTP 요청은 비동기이므로 콜백 헬과 같은 중첩 스코프를 만들어 냅니다. 타입스크립트는 ES6에서 제안된 프로미스를 이용해 콜백 헬이 되지 않도록&lt;br&gt;제어 흐름을 개선할 수 있습니다.&lt;br&gt;자바스크립트는 비동기 요청 후 응답 결과를 콜백 함수로 처리합니다. 이렇게 콜백 함수로 처리하는 상황은 대체로 응답 시점을 예측할 수 없을 때입니다.&lt;br&gt;이와 같은 상황의 예로 HTTP 요청에 대한 응답 처리나 파일 I/O 작업 등이 있습니다. 비동기 요청 후 응답 결과는 콜백 함수의 매개변수를 통해 전달됩니다.&lt;/p&gt;
&lt;p&gt;스코프가 깊어지게 되면 콜백 함수와 제어문 사용으로 스코프가 중첩돼 가독성이 안좋습니다. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>HTTP 요청은 비동기이므로 콜백 헬과 같은 중첩 스코프를 만들어 냅니다. 타입스크립트는 ES6에서 제안된 프로미스를 이용해 콜백 헬이 되지 않도록<br>제어 흐름을 개선할 수 있습니다.<br>자바스크립트는 비동기 요청 후 응답 결과를 콜백 함수로 처리합니다. 이렇게 콜백 함수로 처리하는 상황은 대체로 응답 시점을 예측할 수 없을 때입니다.<br>이와 같은 상황의 예로 HTTP 요청에 대한 응답 처리나 파일 I/O 작업 등이 있습니다. 비동기 요청 후 응답 결과는 콜백 함수의 매개변수를 통해 전달됩니다.</p><p>스코프가 깊어지게 되면 콜백 함수와 제어문 사용으로 스코프가 중첩돼 가독성이 안좋습니다. </p><a id="more"></a><h2 id="프로미스-소개와-동작-과정"><a href="#프로미스-소개와-동작-과정" class="headerlink" title="프로미스 소개와 동작 과정"></a>프로미스 소개와 동작 과정</h2><p>프로미스(promise)는 중첩 스코프 문제를 해결하기 위해 ES6에서 제한된 객체입니다. 프로미스는 스코프가 깊어지지 않도록 나열식 패턴 방식으로 입력 데이터를 처리할 수 있게 합니다.</p><p>프로미스는 다음과 같은 세가지 상태가 존재합니다.</p><blockquote><ul><li>대기 상태 (pending)</li><li>충족 상태 (fulfilled)</li><li>거부 상태 (rejected)</li></ul></blockquote><p>대기 상태는 프로미스가 실행되고 값이 결정되지 않은 상태를 말합니다. 충족 상태는 대기 상태가 끝난 뒤 값이 결정된 상태이며 resolve 함수를 통해 값을 전달합니다.<br>거부 상태는 프로미스가 제대로 처리되지 않고 거부된 상태로 catch 메서드를 통해 예외 처리해 주어야 합니다.</p><p>프로미스는 최초 실행 함수(executor)를 통해 실행됩니다. 실행 함수가 시작되고 마치기전까지 대기 상태를 유지합니다.<br>프로미스는 익명 함수 형태로 작성 할수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejects</span>) =></span> {</span><br><span class="line">  <span class="hljs-comment">// 처리할 프로미스 작업 로직</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>프로미스가 정상으로 수행됐다면 충족 상태가 되어 resolve 함수를 호출, 반대로 실패했다면 거부 상태가 되어 reject 함수를 호출해 예외 처리를 진행 합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejects</span>) =></span> {</span><br><span class="line">  <span class="hljs-keyword">if</span>(충족 상태){</span><br><span class="line">   resolve(result); </span><br><span class="line">  } <span class="hljs-keyword">else</span> {</span><br><span class="line">    rejects(<span class="hljs-string">'거절사유'</span>);</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>첫번째 매개변수로 전달된 resolve 함수를 호출하면 then 메서드가 호출됩니다. then 메서드는 결정된 값에 대해 후속 처리를 담당합니다.<br>reject 함수에 거절된 사유를 전달하며 catch 메서드는 전달된 이유를 표시해주고 예외 처리를 진행합니다.</p><h2 id="프로미스를-사용한-중첩-스코프-개선"><a href="#프로미스를-사용한-중첩-스코프-개선" class="headerlink" title="프로미스를 사용한 중첩 스코프 개선"></a>프로미스를 사용한 중첩 스코프 개선</h2><h3 id="then-메서드를-이용해-중첩-코드-개선"><a href="#then-메서드를-이용해-중첩-코드-개선" class="headerlink" title="then 메서드를 이용해 중첩 코드 개선"></a>then 메서드를 이용해 중첩 코드 개선</h3><p>then 메서드는 하나의 처리 작업에 해당하며 작업 개수에 따라 체이닝 형태로 여러 개를 동시에 선언할 수 있습니다.<br>오류가 있다면 reject 를 호출 할 때 거부 이유를 함께 전달함으로써 catch 메서드를 통해 예외 상황을 처리할 수 있도록 합니다.<br>then 메서드를 체이닝 형태로 선언하고 then 메서드에서 발생한 예외 상황을 처리하려면 catch 메서드를 마지막에 선언해야 합니다.</p><p>임의 시간만큼의 지연이 있는 비동기 함수 여러 개를 동시에 호출하면 호출 순서와 응답 결과의 순서가 일치되지 않는 문제가 있습니다.<br>Promise.all() 메서드는 비동기 응답을 호출 순서에 따라 처리할 수 있는 인터페이스를 제공합니다.<br>이 때 Promise.all()는 작업 완료 시점이 일정치 않아 뒤바뀐 결정 갑의 순서를 호출 순서에 따라 출력해주는 역할을 합니다.</p><h2 id="반응형-프로그래밍"><a href="#반응형-프로그래밍" class="headerlink" title="반응형 프로그래밍"></a>반응형 프로그래밍</h2><p>반응형 프로그래밍 모델은 웹 페이지에 들어오는 스트림 형태의 입력 이벤트를 감지해 반응을 처리할 수 있는 모델입니다.<br>이와 관련한 예로 입력에 반응하는 검색어 제안 기능이 있습니다. 검색어 제안 기능은 사용자가 어떠한 단어를 입력하면 단어에 연관된 키워드를 보이는 기능입니다.</p><h2 id="발행-구독-패턴"><a href="#발행-구독-패턴" class="headerlink" title="발행 구독 패턴"></a>발행 구독 패턴</h2><p>시스템은 기본적으로 사용자의 입력에 대해 반응하고 적절한 처리를 해 줄 수 있어야 합니다. 이벤트는 특정 시간에 발생하지 않고 사용자가 의도한 시점에 발생합니다.<br>반응형 프로그래밍은 입력 이벤트를 감지하고 처리하는 데 발행 구독 패턴을 이용합니다.<br>발행 구독 패턴에서 옵저버는 옵저버블을 관찰하고, 옵저버블은 상태가 변경됐을 때 옵저버에게 상태가 변경됐음을 통지해 줍니다.<br>여기서 관측 대상인 옵저버블은 사용자가 입력한 데이터 스트림입니다. 사용자 입력 이벤트는 옵저버가 감시하고 처리해야 할 대상입니다.<br>옵저버는 옵저버블을 구독하고 있다가 옵저버블의 상태가 변경되면 옵저버블로부터 상태가 변경됐음을 통지받습니다.</p><h2 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h2><p>RxJS는 데이터 스트림에 대한 연산을 연산자 메서드를 이용해 연쇄적으로 처리할 수 있게 관련 인터페이스를 제공합니다.<br>RxJS에서는 사용자가 키를 입력할 대마다 데이터가 생성되고 생성된 데이터는 연산자에 의해 데이터가 처리되고 나서 구독될지 말지를 결정합니다.<br>RxJS에서 스트림 데이터를 처리하기 위해 세 단계를 거칩니다.<br>데이터 생성단계에서는 데이터 생성자가 스트림 데이터를 생성합니다. 데이터 처리 단계에서는 스트림 데이터가 파이프 형태로 연결된 연산자를 통과하면서 차례대로 처리됩니다.<br>데이터 소비 단계에서는 구독자가 데이터 스트림을 받아 최종적인 처리를 수행함으로써 데이터를 소비합니다.</p><h2 id="동시성-concurrency-과-동기화-synchronous-작업"><a href="#동시성-concurrency-과-동기화-synchronous-작업" class="headerlink" title="동시성(concurrency)과 동기화(synchronous) 작업"></a>동시성(concurrency)과 동기화(synchronous) 작업</h2><p>동시성란 멀티 스레드와 같이 여러 개의 단위 작업이 동시에 실행되는 성질을 말합니다. 자바스크립트에서 동시성은 작업을 동시에 처리하는 것을 의미합니다.</p><blockquote><ul><li>비동기 프로그래밍 모델</li><li>멀티 스레드 프로그래밍</li></ul></blockquote><p>비동기 프로그래밍 모델은 HTTP 요청과 같은 비동기 요청상황에 해당하는 모델입니다. 비동기 프로그래밍 모델은 동기 프로그래밍 모델과 달리,<br>단위 작업을 하나의 스레드내에서 번갈아 가며 실행합니다. 여기서 스레드는 프로세스보다 작은 단위로 프로세스 내에 존재하는 작은 작업 단위를 의미합니다.</p><p>멀티 스레드 프로그래밍은 멀티 코어 기기상에서 여러 스레드에서 작업을 동시에 실행하는 방식입니다. 여러 작업을 동시에 실행하기 때문에 병렬성의 특정이 있습니다.<br>멑티 스레드는 자바스크립트에서 지원하지 않습니다. 지원하지 않는 이류는 싱글 스레드만으로 실행 해야 페이지를 로딩할 때 보다 더 빠른 속도로 실행할 수 있게 때문입니다.</p><p>더 근본적인 이유로는 브라우저의 인터프리터가 단일 스레드여서 멀티 스레드를 지원하지 않기 때문, 때론 setTimeout 함수를 통한 타이머 호출은 마치 멀티 스레드 처럼<br>동작하는 것처럼 보이지만 실은 멀티 스레드가 아닌 싱글 스레드에서 실행됩니다.<br>비동기 프로그래밍은 작업을 수차적으로 실행 하지 않고 응답 시간을 고려해 실행 순서가 결정됩니다. 동기화 실행이 되면 중간에 비동기 작업이 있더라고 호출순서에 따라 작업이 실행 됩니다.</p><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><p>Async/Await 는 ES2015애 제안됐고 타입스크립트에서는 1.7에서 추가됐습니다.<br>Async/Await 를 이용하며 비동기 함수를 동기화 할 수 있습니다.</p><h3 id="비동기-호출-코드"><a href="#비동기-호출-코드" class="headerlink" title="비동기 호출 코드"></a>비동기 호출 코드</h3><p>비동기 호출은 응답 시간이 저마다 다를 수 있으므로 차례대로 실행되지 않고 호출 시간과 응답 시간을 고려해 동작을 수행합니다.<br>반대로 동기화 코드는 순서가 보장되며 순서대로 실행됩니다. 비동키 코드를 동기화한다면 비동기 코드를 여럿 사용하는 경우 코드 제어가 간소화 됩니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">await</span> run(); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>호출 하는 함수는 프로미스 구문을 포함해 비동기 처리를 수행해야 합니다 .</p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/06/17/TypeScript-async/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 제네릭</title>
      <link>https://mishka.kr/2020/06/03/TypeScript-generic/</link>
      <guid>https://mishka.kr/2020/06/03/TypeScript-generic/</guid>
      <pubDate>Wed, 03 Jun 2020 10:34:40 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;제네릭(generics)은 클래스와 함수에 타입이 고정되는 것을 방지하고 재사용할 수 있는 요소를 선언할 수 있게 합니다. 제네릭은 C#이나 자바와 같은 언어에서 제공됐던 기능으로 타입스크립트 0.9 부터 지원됐습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;제네릭의 타입 검사를 컴파일 시간에 진행해 타입 안정성을 보장한다. &lt;/li&gt;
&lt;li&gt;캐스팅과 관련한 코드를 제거할 수 있다.&lt;/li&gt;
&lt;li&gt;제네릭을 이용하면 제네릭 로직을 이용해 재사용이 가능한 코드를 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>제네릭(generics)은 클래스와 함수에 타입이 고정되는 것을 방지하고 재사용할 수 있는 요소를 선언할 수 있게 합니다. 제네릭은 C#이나 자바와 같은 언어에서 제공됐던 기능으로 타입스크립트 0.9 부터 지원됐습니다.</p><blockquote><ul><li>제네릭의 타입 검사를 컴파일 시간에 진행해 타입 안정성을 보장한다. </li><li>캐스팅과 관련한 코드를 제거할 수 있다.</li><li>제네릭을 이용하면 제네릭 로직을 이용해 재사용이 가능한 코드를 만들 수 있다.</li></ul></blockquote><a id="more"></a><p>타입 매개 변수를 통해 타입 안정성을 보장할 수 있다. 타입 안정성은 제네릭 함수명 끝에 선언된 T에 의해 결정됩니다.<br>T는 타입의 약자로 ‘타입 매개변수’ 또는 ‘제네릭 타입 변수’라 합니다. 타입 매개변수 T 는 타입이 정해져 있지 않은 가상의 타입으로 임의 알파벳이나 단어로 선언해도 좋습니다.</p><p>타입 매개 변수 T는 제네릭 함수를 호출 할 때 타입 인수로 타입을 결정합니다. 제네릭 함수의 타입이 결정되는 과정을 ‘타입 바인딩’이라 합니다. 타입 바인딩이 이뤄 지면 타입 안정성이 생깁니다.</p><p>캐스팅과 관련한 코드를 제거할 수 있다. 만약 타입 매개변수로 반환 타입의 지정돼 있다면 더는 함수의 반환값에 대해 캐스팅하지 않아도 됩니다.</p><p>제네릭 로직을 이용해 재사용할 수 있는 코드를 만들 수 있습니다. 제네릭 로직을 이용하면 타입은 다르지만 같은 로직을 수행하는 재사용성이 좋은 코드를 만들 수 있습니다.</p><h2 id="제네릭-함수"><a href="#제네릭-함수" class="headerlink" title="제네릭 함수"></a>제네릭 함수</h2><p>타임 매개 변수는 제네릭에서 가장 중요한 요소입니다. 타입 매개변수는 함수 선언에 함수를 제네릭 함수로 변경 할 수 있게 합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concat</span><<span class="hljs-title">T</span>>(<span class="hljs-params">strs: T, strs: T</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> strs + strs2;</span><br><span class="line">}</span><br><span class="line">concat<<span class="hljs-built_in">string</span>>(<span class="hljs-string">'abc'</span>,<span class="hljs-string">'123'</span>);</span><br></pre></td></tr></tbody></table></figure><p>제네릭 함수의 매개변수 strs가 타입이 결정됐을 때 타입 매개변수와 다른 타입의 인수가 전달되면 타입 오류가 발생합니다.<br>타입 인수를 전달하면 함수가 불필요한 추론을 하지 않아도 됩니다.</p><h3 id="바운드-타입-매개변수를-이용한-T-T-연산시도"><a href="#바운드-타입-매개변수를-이용한-T-T-연산시도" class="headerlink" title="바운드 타입 매개변수를 이용한 T+T 연산시도"></a>바운드 타입 매개변수를 이용한 T+T 연산시도</h3><p>타입을 제약 하려면 타입 매개변수는 특정 타입을 상속해야 합니다.<br>타입 매개변수가 특정 타입으로 묶였다면 해당 타입 매개변수는 T를 바운드 타입 매개변수라고 부릅니다.(유니언 타입을 상속해 선언 할 수도 있습니다.)</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>></span><br><span class="line"><T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>></span><br></pre></td></tr></tbody></table></figure><h3 id="오버로드-함수를-이용한-타입-매개변수-간의-연산"><a href="#오버로드-함수를-이용한-타입-매개변수-간의-연산" class="headerlink" title="오버로드 함수를 이용한 타입 매개변수 간의 연산"></a>오버로드 함수를 이용한 타입 매개변수 간의 연산</h3><p>오버로드 함수를 이용하면 T+T 와 같은 타임 매개변수 간에 연산이 가능합니다, 오버로드 함수는 이름만 같고 매개변수의 타입이나 개수가 다르게 선언된 함수를 의미합니다.</p><h2 id="제네릭-클래스와-인터페이스"><a href="#제네릭-클래스와-인터페이스" class="headerlink" title="제네릭 클래스와 인터페이스"></a>제네릭 클래스와 인터페이스</h2><p>자료구조나 알고리즘은 타입에 의존적이면 범용으로 사용할 수 없습니다. 범용으로 사용할 목적의 자료구조나 알고리즘이 있다면 다양한 타입에 대응하도록 제네릭을 적용해야합니다.<br>제네릭은 함수처럼 작은 단위뿐아니라, 클래스처럼 큰 단위에서도 적용할 수 있습니다.</p><h3 id="제네릭-클래스-선언"><a href="#제네릭-클래스-선언" class="headerlink" title="제네릭 클래스 선언"></a>제네릭 클래스 선언</h3><p>제네릭 클래스는 외부로부터 타입을 받아들여 클래스 내부에 입력된 타입을 적용할 수 있는 클래스입니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line"><span class="hljs-keyword">class</span>  클래스명<T> {</span><br><span class="line">  getValue(elms: <span class="hljs-built_in">Array</span><T>, index: <span class="hljs-built_in">number</span>): T {</span><br><span class="line">    <span class="hljs-keyword">return</span> elms[index];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>클래스 명 뒤에 타입 매개변수인 <t>를 선언해 줍니다. <t>는 타입 매개변수이며 매개변수나 반환 타입으로 사용될 수 있습니다.</t></t></p><h2 id="타입-매개변수에-인터페이스-상속"><a href="#타입-매개변수에-인터페이스-상속" class="headerlink" title="타입 매개변수에 인터페이스 상속"></a>타입 매개변수에 인터페이스 상속</h2><p>제네릭 클래스에 전달된 매개변수가 클래스이고 타입 매개변수일때 코드 어시스트를 받지 못할 때가 있다. 이유는 타입 매개변수<t>에 타입이 없기 때문<br>명시적으로 타입을 선언하려면 <T extends 인터페이스>처럼 클래스에 대한 인터페이스를 상속해주면 됩니다. </t></p><p>제네릭 클래스를 사용하면 클래스 전역에 걸쳐 타입 매개변수가 적용됩니다. 만약 특정 메서드만을 대상으로 제네릭을 적용하려면 해당 메서드를 제네릭 메서드로 선언하면 됩니다.<br>메서드 단위로 제네릭을 적용하는 것은 특정 메서드에만 타입 인수를 전달할 수 있으므로 타입의 재활용성이 다소 떨어집니다.<br>그런데 클래스 단위로 제네릭을 적용하며 클래스 내에 존재하는 불특정 메서드에 대해 일괄적으로 제네릭 메서드로 선언할 수 있어서 더 편리합니다.</p><h2 id="제네릭의-여러-활용방법"><a href="#제네릭의-여러-활용방법" class="headerlink" title="제네릭의 여러 활용방법"></a>제네릭의 여러 활용방법</h2><h3 id="룩업-타입을-제네릭-클래스에-적용"><a href="#룩업-타입을-제네릭-클래스에-적용" class="headerlink" title="룩업 타입을 제네릭 클래스에 적용"></a>룩업 타입을 제네릭 클래스에 적용</h3><p>룩업 타입은 keyof로 속성을 포함하는 대상을 탐색해 유니언 타입처럼 동작합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">getValue</span><<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>>(<span class="hljs-params">obj: T, key: K</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> obj[key];</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">let</span> numberKeys = { one:<span class="hljs-number">1</span>, two:<span class="hljs-number">2</span>, three:<span class="hljs-number">3</span> };</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getValue(numberKeys, <span class="hljs-string">'one'</span>));</span><br><span class="line"><span class="hljs-comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>타입 매개 변수K는 타입 매개변수 T에 의해 정해지는 룩업 타입이 됩니다. 따라서 타입 매개변수 K는 keyof를 이용해 타입 매개변수 T의 속성을 탐색해 하나의 속성만 허용하도록 제약합니다.</p><h2 id="인터페이스를-상속해-제네릭-확장하기"><a href="#인터페이스를-상속해-제네릭-확장하기" class="headerlink" title="인터페이스를 상속해 제네릭 확장하기"></a>인터페이스를 상속해 제네릭 확장하기</h2><p>인터페이스는 클래스가 구현해야 할 메서드나 프로퍼티를 선언할 수 있습니다. 만약에 구현해야 할 클래스가 제네릭 클래스라면 인터페이스는 제네릭 인터페이스로 선언해야 합니다.<br>제네릭 인터페이스는 타입 매개변수가 선언된 형태로 선언합니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> IFilter<T> {</span><br><span class="line">  unique(array: <span class="hljs-built_in">Array</span><T>): <span class="hljs-built_in">Array</span><T>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> Filter<T> <span class="hljs-keyword">implements</span> IFilter<T> {</span><br><span class="line">  unique(array:<span class="hljs-built_in">Array</span><T>):<span class="hljs-built_in">Array</span><T> {</span><br><span class="line">    <span class="hljs-keyword">return</span> array.filter(<span class="hljs-function">(<span class="hljs-params">v, i, array</span>) =></span> array.indexOf(v) === i);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> myFilter = <span class="hljs-keyword">new</span> Filter<<span class="hljs-built_in">string</span>>();</span><br><span class="line"><span class="hljs-keyword">let</span> resultFilter = myFilter.unique([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(resultFilter);</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/06/03/TypeScript-generic/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 타입 선언과 변경, 타입호환</title>
      <link>https://mishka.kr/2020/06/03/TypeScript-typeChange/</link>
      <guid>https://mishka.kr/2020/06/03/TypeScript-typeChange/</guid>
      <pubDate>Wed, 03 Jun 2020 09:09:00 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;타입-에일리어스-type-alias&quot;&gt;&lt;a href=&quot;#타입-에일리어스-type-alias&quot; class=&quot;headerlink&quot; title=&quot;타입 에일리어스(type alias)&quot;&gt;&lt;/a&gt;타입 에일리어스(type alias)&lt;/h2&gt;&lt;p&gt;타입 에일이어스는 타입스크립트 1.4 버전부터 지원된 특징입니다. 타입 에일리어스를 이용하면 기존 타입에 새로운 이름을 지을 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[형식]&lt;br&gt;type&lt;바인딩 식별자&gt; = 타입;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;바인딩 식별자(binding identifier)는 타입의 별칭에 해당하는 타입 에일라어스입니다.&lt;br&gt;타입에 새로운 별칭을 만드는 과정을 줄여서 에일리어싱(aliasing)이라고 합니다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h2 id="타입-에일리어스-type-alias"><a href="#타입-에일리어스-type-alias" class="headerlink" title="타입 에일리어스(type alias)"></a>타입 에일리어스(type alias)</h2><p>타입 에일이어스는 타입스크립트 1.4 버전부터 지원된 특징입니다. 타입 에일리어스를 이용하면 기존 타입에 새로운 이름을 지을 수 있습니다.</p><blockquote><p>[형식]<br>type<바인딩 식별자> = 타입;</p></blockquote><p>바인딩 식별자(binding identifier)는 타입의 별칭에 해당하는 타입 에일라어스입니다.<br>타입에 새로운 별칭을 만드는 과정을 줄여서 에일리어싱(aliasing)이라고 합니다.</p><a id="more"></a><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> myId = <span class="hljs-built_in">string</span>;</span><br></pre></td></tr></tbody></table></figure><p>타입 에일리어스는 단일 타입보다는 유니언 타입이나 리터럴 타입과 같은 다소 복작한 형태의 타입에 적용하면 좋습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> myAlias = <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="타입-추론"><a href="#타입-추론" class="headerlink" title="타입 추론"></a>타입 추론</h2><p>타입스크립트에서는 값을 할당할 때 타입을 명시하지 않으면 타입 추론(type inference)을 통해 타입이 결정됩니다.<br>values는 Object 타입이며, 내부 요소는 타입이 다르더라고 서로간에 할당할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values[<span class="hljs-number">0</span>] = values[<span class="hljs-number">1</span>]</span><br></pre></td></tr></tbody></table></figure><p>그런데 변수의 경우 각 변수에 처음 갑싱 할당되는 시점에 타입이 정해지므로 초기화가 이뤄진 다음에는 다른 타입의 값을 할당할 수 없습니다.</p><h2 id="타입-캐스팅과-변환"><a href="#타입-캐스팅과-변환" class="headerlink" title="타입 캐스팅과 변환"></a>타입 캐스팅과 변환</h2><p>타입 캐스팅(type casting)은 명시적으로 선언한 캐스팅 코드에 의한 타입 변경을 의미하며, JS 인터프리터에 의해 타입이 바뀌는 타입 변환(type conversion)과 구분됩니다.<br>타입 캐스팅의 예로, null 이나 undefined를 제외한 인수 값은 기본 래퍼 객체을 이용해 캐스팅 할 수 있습니다.</p><figure class="highlight typescript hljs"><figcaption><span>기본 래퍼 객체</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">string</span></span><br><span class="line"><span class="hljs-built_in">Number</span></span><br><span class="line"><span class="hljs-built_in">Boolean</span></span><br><span class="line">Symbol</span><br></pre></td></tr></tbody></table></figure><p>타입을 변경할 때 기본 래퍼 객체 외에도 +연산자를 이용할 수 있습니다.</p><p>parseInt 함수가 Number 함수와 다른 점이 있다면 parseInt는 함수 이름 처럼 파싱 기능이 있어 숫자 외에 여러 문자가 섞여 있을 때 숫자만을 골라서 숫자 타입으로 변경할 수 있다는 점입니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'50px'</span>); <span class="hljs-comment">// 50</span></span><br><span class="line"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'1010'</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 2진수를 인식해 10진수로 바꿔 10</span></span><br><span class="line"><span class="hljs-built_in">Number</span>(<span class="hljs-string">'50px'</span>);  <span class="hljs-comment">// NaN을 반환</span></span><br></pre></td></tr></tbody></table></figure><h2 id="타입-어설션"><a href="#타입-어설션" class="headerlink" title="타입 어설션"></a>타입 어설션</h2><p>타입 어설션(type assertion)을 이용하면 타입스크립트 컴파일러가 타입 어설션 정보를 이용해 컴파일을 수행합니다. 따라서 타입 어설션은 컴파일 과정까지만 유효하고 컴파일 후에는 사라집니다.<br>타입 어셜션의 선언 방식은 크게 꺽쇠 괄호 방식과 as 문법이 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num1: <span class="hljs-built_in">number</span> = <<span class="hljs-built_in">number</span>>myNum;</span><br><span class="line"><span class="hljs-keyword">let</span> num2: <span class="hljs-built_in">number</span> = myNum <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>;</span><br></pre></td></tr></tbody></table></figure><p>타입 어설션에 사용되는 꺽쇠 기호가 포함된 <number>의 선언형태는 자바스크립트 라이브러리중 하나인 리액트에서 사용하는 JSX 문법과 유사해 충돌을 일으킵니다.<br>이러한 단점을 보완하기 위해 as 문법사용을 권장합니다.</number></p><p>타입 어설션은 컴파일러에게 전달되는 타입 정보이므로 컴파일러는 타입 어셜션을 보고 유효성을 검증합니다. 예를 들어 타입이 지정된 변수와 타입 어설션이 선언된 변수 간에 유효성에 문제가 없으면 두 변수 간에 타입 호환이 이뤄집니다.</p><h2 id="타입-호환"><a href="#타입-호환" class="headerlink" title="타입 호환"></a>타입 호환</h2><p>프로그래밍 언어마다 타입 검사 시점이 다른데 타입 검사는 크게 다음과 같은 두가지 방식이 있습니다.</p><blockquote><ul><li>동적 타입 검사(dynamic type checking)</li><li>정적 타입 검사(static type checking)</li></ul></blockquote><p>자바스크립트 같은 동적 프로그래밍 언어는 런타임 시점에 동적 타입 검사를 수행하고, 타입스크립트 같은 정적 언어는 컴파일 시점에 정적 타입 검사를 수행합니다.</p><p>타입스크립트는 두 부류의 타입 시스템을 지원합니다.</p><blockquote><ul><li>구조 타입 시스템(structural type system)</li><li>명목 타입 시스템(nominal type system)</li></ul></blockquote><p>구조 타입 시스템은 타입의 구조와 정의만 같다면 타입 호환이 가능합니다. 이와 달리 명목 타입 시스템은 타입 호환이 되려면 명시적으로 같은 타입이어야 합니다.</p><p>타입 스크립트는 크게 네 부류의 타이핑 방식을 지원합니다.</p><blockquote><ul><li>덕 타이핑(duck typing) - 런타임시 동적으로 타입의 구조가 정해지는 타입 지정 방식</li><li>구조 타이핑(structural typing) - 타이브이 구조만 같으면 서로 호환 가능한 타입 지정 방식</li><li>구조 서브타이핑(structural subtyping) - 구조가 부분적으로 같더라도 타입 호환을 지원합니다.</li><li>명목 타이핑(nominal typing) - 타입 구조뿐 아니라 타입까지 같아야 호환 가능한 타입 지정 방식</li></ul></blockquote><h3 id="덕-타이핑"><a href="#덕-타이핑" class="headerlink" title="덕 타이핑"></a>덕 타이핑</h3><p>덕 타이핑은 동적으로 타입이 결정되므로 유연하지만 타입 안정성은 떨어집니다. 만약 덕 타이핑을 할 때 타입 안정성을 강화하려면 인터페이스를 도입하면 됩니다.<br>덕 타이핑을 수행할 때 매개변수에 지정할 타입으로 사용하기 위한 인터페이스 타입을 선언하고 함수의 매개변수에 인터페이스 타입을 선언하면 덕 타이핑에도 타입 안정성이 생깁니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span>  DuckGoose {</span><br><span class="line">  speak();</span><br><span class="line">  swim();</span><br><span class="line">}</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swim</span>(<span class="hljs-params">obj: DuckGoose</span>) </span>{</span><br><span class="line">  obj.speak();</span><br><span class="line">  obj.swim();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="구조-타이핑"><a href="#구조-타이핑" class="headerlink" title="구조 타이핑"></a>구조 타이핑</h3><p>타입 호환이 가능하며 컴파일을 통과시키고 타입 호환이 불가능 하면 컴파일 오휴를 출력합니다.<br>구조가 같은 클래스 간에는 서로 타입 호환이 가능해서 서로의 타입으로 구조 타이핑이 가능합니다.<br>생성자의 매개변수가 달라로 타입 호환이 되는 데는 문제가 없습니다. 생성자 매개변수는 접근 제한자가 설정되지 않아 생성자 내부에서만 사용할 수 있으므로 클래스 구조에 영향을 미치지 않기 때문입니다.</p><h3 id="구조-서브-타이핑"><a href="#구조-서브-타이핑" class="headerlink" title="구조 서브 타이핑"></a>구조 서브 타이핑</h3><p>구조 타이핑은 타입 구조가 같아야지만 타입 호환이 이뤄지지만, 구조 서브 타이핑은 구조가 부분적으로 같더라도 타입 호환을 지원합니다.</p><h4 id="구조-서브-타이핑의-조건"><a href="#구조-서브-타이핑의-조건" class="headerlink" title="구조 서브 타이핑의 조건"></a>구조 서브 타이핑의 조건</h4><p>구조 서브 타이핑은 하위 타입이 상위 타입으로만 호환되는 조건이 있습니다. 상위 타입은 타이핑 관점에서 공통되는 구조(변수 메서드 등)가 들어있는 기본 형태이고, 하위 타입은 상위 타입을 포함하면서 구조가 보태어진 특정한 형태를 의미 합니다.</p><p>하위 타입은 상위 타입의 속성을 포함합니다. 이때 “상위 타입 = 하위 타입”처럼 하위 타입을 상위 타입에 대입하는 것으로 구조 서브타이핑이 가능합니다. 이때 하위 타입은 상위 타입으로 타입 호환이 가능합니다.</p><p>구조가 일부 같으면 타입이 ㅇ벗더라고 변수 간의 구조 서브 타이핑이 가능합니다.</p><p>매개변수 개수와 호출시 전달하는 인수의 개수가 다르면 오류가 발생합니다. 함수의 매개변수가 다른 경우 매개변수가 적은 사위 함수 타입이 매개변수가 많은 하위 함수 타입으로 타입 호환이 가능합니다.</p><p>객테 리터럴이 할당된 변수에 인터페이스 타입을 지정하면 해당 변수는 구조 서브 타이핑이 적용됩니다. </p><h3 id="명목-타이핑"><a href="#명목-타이핑" class="headerlink" title="명목 타이핑"></a>명목 타이핑</h3><p>명목 타이핑은 자바나 C++, C#과 같은 언어에서 사용하는 타이핑방식으로 명시적으로 지정된 타입 간에만 타입이 호환됩니다.</p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/06/03/TypeScript-typeChange/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 고급타입</title>
      <link>https://mishka.kr/2020/05/20/TypeScript-Advancedtype/</link>
      <guid>https://mishka.kr/2020/05/20/TypeScript-Advancedtype/</guid>
      <pubDate>Wed, 20 May 2020 10:19:45 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;유니언-타입&quot;&gt;&lt;a href=&quot;#유니언-타입&quot; class=&quot;headerlink&quot; title=&quot;유니언 타입&quot;&gt;&lt;/a&gt;유니언 타입&lt;/h2&gt;&lt;p&gt;유니언 타입은 타입스크립트 1.4에 추가된 특징입니다. 유니언타입은 2개 이상의 타입을 하나의 타입으로 정의한 타입입니다.&lt;br&gt;유니언 타입을 선언 할 때는 파이프(|)를 타입명 사이에 넣습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;타입A | 타입B | 타입C …&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;유니언 타입으로 선언된 변수는 나열된 타입 중 하나의 타입에 속한 값만 할당 받습니다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h2 id="유니언-타입"><a href="#유니언-타입" class="headerlink" title="유니언 타입"></a>유니언 타입</h2><p>유니언 타입은 타입스크립트 1.4에 추가된 특징입니다. 유니언타입은 2개 이상의 타입을 하나의 타입으로 정의한 타입입니다.<br>유니언 타입을 선언 할 때는 파이프(|)를 타입명 사이에 넣습니다.</p><blockquote><p>타입A | 타입B | 타입C …</p></blockquote><p>유니언 타입으로 선언된 변수는 나열된 타입 중 하나의 타입에 속한 값만 할당 받습니다.</p><a id="more"></a><h2 id="타입-가드"><a href="#타입-가드" class="headerlink" title="타입 가드"></a>타입 가드</h2><p>유니언 타입은 여러 타입을 받을 수 있다는 장점이 있습니다. 그런데 유니언 타입은 여러 타입을 받음으로써 타입을 활신할 수 없다는 문제가 있다.<br>매개변수가 유니언 타입일 때 안전한 값을 할당하려면 타입 검사를 거쳐 매개변수 값을 답아야 한다.<br>유니언 타입에 대한 타입 검사를 통해 타입 안전성을 주는 방법을 ‘타입가드(type guards)’라고 합니다. </p><p>타입 가드는 유니언 타입으로 지정된 변수에 대해 typeof나 insranceof 연산자를 활용해 타입 질의를 한 후 명시된 타입과 일치하는지 검사 합니다.</p><figure class="highlight typescript hljs"><figcaption><span>typeof를 이용한 타입 검사</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'string'</span>) {</span><br><span class="line">  <span class="hljs-keyword">return</span> x.indexOf(y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>클래스도 유니언 타입 형태로 지정할 수 있습니다. 클래스에 대한 타입을 확신할 수 있으려면 instanceof 연산자를 통해 같은 클래스인지 확인 해야합니다.</p><figure class="highlight typescript hljs"><figcaption><span>instanceof를 이용한 타입 검사</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Dog) {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x.name);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x.leg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>조건 검사가 이뤄지지 않은 영역에서는 오류가 발생합니다.</p><h2 id="문자열-리터럴-타입"><a href="#문자열-리터럴-타입" class="headerlink" title="문자열 리터럴 타입"></a>문자열 리터럴 타입</h2><p>문자열 리터럴 타입은 타입에 정의한 문자열만 할당받을 수 있게 하는 타입입니다. 사용자 정의 타입이므로 사용자가 정의해 사용합니다.<br>타입 에일리어스를 이용하면 좀 더 일관성 있게 타입을 관리 할 수 있습니다. type 키워드를 이용해 ‘keyup’만 할당받을 수 있는 문자열 리터럴 타입인 EventType은 다음과 같은 형태로 선언합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 문자열 리터럴 타입</span></span><br><span class="line"><span class="hljs-keyword">let</span> event: <span class="hljs-string">'keyup'</span> = <span class="hljs-string">'keyup'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 타입 에일리어스</span></span><br><span class="line"><span class="hljs-keyword">type</span> EventType = <span class="hljs-string">'keyup'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 유니언 타입과 결합</span></span><br><span class="line"><span class="hljs-keyword">type</span> EventType = <span class="hljs-string">'keyup'</span> | <span class="hljs-string">'mouseover'</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li>유니언 타입과 결합해 사용하면 허용할 문자열을 여러 개 지정할 수 있습니다.</li></ul></blockquote><h2 id="룩업-타입"><a href="#룩업-타입" class="headerlink" title="룩업 타입"></a>룩업 타입</h2><p>룩업(lookup)타입은 타입스크립트 2.1에 추가된 타입입니다. 룩업 타입은 인덱스 접근타입으로 불리는데, keyof를 통해 타입T의 하위 타입을 생성해 내기 때문입니다.<br>여기서 타입T는 여러 타입으로 이뤄진 유니언이나 인터페이스 타입을 가리킵니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> testUnion: <span class="hljs-string">'name'</span> | <span class="hljs-string">'gennder'</span> | <span class="hljs-string">'age'</span> = <span class="hljs-string">'name'</span>;</span><br></pre></td></tr></tbody></table></figure><p>유니언 타입을 다음과 같이 인터페이스 구조로 바꿀 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Profile {</span><br><span class="line">  name: <span class="hljs-built_in">String</span>;</span><br><span class="line">  gender: <span class="hljs-built_in">String</span>;</span><br><span class="line">  age: <span class="hljs-built_in">number</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이 인터페이스를 keyof를 이용해 룩업 타입으로 선언하면 다음과 같습니다.</p><figure class="highlight typescript hljs"><figcaption><span>룩업타입</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> Profile1 = keyof Profile;</span><br></pre></td></tr></tbody></table></figure><h2 id="non-nullable-타입"><a href="#non-nullable-타입" class="headerlink" title="non-nullable 타입"></a>non-nullable 타입</h2><p>타입스크립트 2.0에 추가된 특징으로 non-nullable 타입은 컴파일러가 null이나 undefined를 엄격하게 제한합니다.</p><p>타입스크립트 2.0 전에는 null이나 undefined를 모든 타입의 변수에 할당할 수 있었으나 null이나 undefined를 할당하면 타입이 명확하지 않아서<br>타입스크립트 2.0에서 strictNullChecks 라는 옵션이 추가되었습니다.</p><p>strictNullChecks 옵션을 true 로 설정하면 특정 타입으로 선언된 변수에 null과 undefined 가 할당되지 않아 타입 사용이 명확해집니다.</p><p>strictNullChecks 가 true일 때 null이나 undefined를 할당하려면 유니언타입으로 만들면 됩니다.</p><h2 id="네버타입"><a href="#네버타입" class="headerlink" title="네버타입"></a>네버타입</h2><p>타입스크립트 2.0에 내장 타입으로 네버(naver)이 추가 됐습니다. 네버는 모든 타입의 하위 타입으로 사용할 수 있지만, any 타입을 never 타입에 할당 할 수는 없습니다.</p><blockquote><ol><li>함수에 닿을 수 없는 코드 영역이 있어 반환값이 존재하지 않을 때</li><li>함수에 Throw 객체가 반환돼 오류가 발생할 때</li></ol></blockquote><h3 id="닿을-수-없는-코드"><a href="#닿을-수-없는-코드" class="headerlink" title="닿을 수 없는 코드"></a>닿을 수 없는 코드</h3><p>함수를 실행하다 보면 ‘닿을 수 없는 코드(unreachable code)’가 발생할 때가 있습니다. 한 예로는 무한루프가 있습니다.<br>닿을 수 없는 코드가 포함된 함수를 변수에 할당하려면 할당 받을 변수도 never 타입이 돼야 합니다.<br>닿을 수 없는 코드를 없애려면 조건 검사에서 예외 상황이 없게끔 수정하면 됩니다.</p><h3 id="예외-객체가-반활될-때"><a href="#예외-객체가-반활될-때" class="headerlink" title="예외 객체가 반활될 때"></a>예외 객체가 반활될 때</h3><p>오류를 발생시키려면 throw new Error(…)구문을 사용합니다. 오류 객체를 생성하고 던지면 함수가 반환값을 줄 수 없으므로 네버 타입이 됩니다.</p><h2 id="this-타입"><a href="#this-타입" class="headerlink" title="this 타입"></a>this 타입</h2><p>this 타입은 인터페이스와 클래스의 하위 타입이면서 이들을 참조할 수도 있는 타입입니다. this 타입은 this 키워드를 이용해 선언합니다.<br>this 타입은 다형적 this 타입(polymorphic this type)이라고도 하는데, 선언 위치에 따라 참조하는 대상이 달라지기 때문입니다.<br>클래스 멤버 변수나 생성자에서 this 타입을 사용하면 가장 가까운 클래스의 인스턴스를 참조합니다. 인터페이스 멤버에 this 타입을 사용하면 this 타입은 인터페이스를 참조합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> ListItem {</span><br><span class="line">  getHead(): <span class="hljs-keyword">this</span>;</span><br><span class="line">  getTail(): <span class="hljs-keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>각 인터페이스의 멤버는 인터페이스 자신을 참조합니다. 인터페이스는 구현 클래스의 객체를 통해 getHead() 라고 호출하면 자신을 호출하므로 재귀 타입이 됩니다.</p><p>이처럼 자기 자신을 반환하는 인스턴스 메서드를 활용해 체이닝 형태로 사용하면 마치 데이터가 흐르는 듯이 표현할 수 있는데 이러한 패턴을 프루언트 인터페이스패턴이라 하고 줄여서 플루언트 패턴이라고 합니다.<br>플루언트 패턴을 구현할 때는 매세드가 인스터스 자신을 가리키는 this 타입을 반환하게 합니다.</p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/05/20/TypeScript-Advancedtype/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 모듈</title>
      <link>https://mishka.kr/2020/05/14/Typescript-Module/</link>
      <guid>https://mishka.kr/2020/05/14/Typescript-Module/</guid>
      <pubDate>Thu, 14 May 2020 07:50:03 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;모듈(modules)은 독립 가능한 기능의 단위 입니다. 프로그램은 여러 모듈로 구성돼 있고 모듈을 결합해 하나의 프로그램을 만듭니다.&lt;br&gt;모듈을 사용하면 다음과 같은 장점이 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;유지보수의 용이성&lt;/li&gt;
&lt;li&gt;전역 스코프 오염을 방지 &lt;/li&gt;
&lt;li&gt;재사용성 향상 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;첫 번째 장점은 모듈을 사용하면 유지보수가 쉬워집니다. 공통기능을 모듈로 정의해 사용하면 애플리케이션의 전체적인 수정 없 모듈의 수정이나&lt;br&gt;교체만으로도 코드를 효과적으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;두 번째 장점은 모듈은 전역 스코프 오염(global scope pollution)을 방지합니다. 전역 스코프틑 전역 이름 공간을 가지므로 변수의 이름이나&lt;br&gt;함수 이름을 중복해 선언 할 수 없습니다. 그런데 변수나 함수등을 파일 내부에 한정해 모듈로 선언하면 이름 공간이 파일 단위로 제한되며 전역 이름 공간을 침범하지 않습니다.&lt;/p&gt;
&lt;p&gt;세 번째 장점은 모듈을 사용하면 재사용성이 향상 됩니다. 모듈화를 잘 해두면 현재의 프로젝트뿐 아니라 다른 프로젝트에도 공유해 재사용할 수 있습니다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>모듈(modules)은 독립 가능한 기능의 단위 입니다. 프로그램은 여러 모듈로 구성돼 있고 모듈을 결합해 하나의 프로그램을 만듭니다.<br>모듈을 사용하면 다음과 같은 장점이 있습니다.</p><blockquote><ul><li>유지보수의 용이성</li><li>전역 스코프 오염을 방지 </li><li>재사용성 향상 </li></ul></blockquote><p>첫 번째 장점은 모듈을 사용하면 유지보수가 쉬워집니다. 공통기능을 모듈로 정의해 사용하면 애플리케이션의 전체적인 수정 없 모듈의 수정이나<br>교체만으로도 코드를 효과적으로 수정할 수 있습니다.</p><p>두 번째 장점은 모듈은 전역 스코프 오염(global scope pollution)을 방지합니다. 전역 스코프틑 전역 이름 공간을 가지므로 변수의 이름이나<br>함수 이름을 중복해 선언 할 수 없습니다. 그런데 변수나 함수등을 파일 내부에 한정해 모듈로 선언하면 이름 공간이 파일 단위로 제한되며 전역 이름 공간을 침범하지 않습니다.</p><p>세 번째 장점은 모듈을 사용하면 재사용성이 향상 됩니다. 모듈화를 잘 해두면 현재의 프로젝트뿐 아니라 다른 프로젝트에도 공유해 재사용할 수 있습니다.</p><a id="more"></a><h2 id="모듈러-프로그래밍을-위한-접근"><a href="#모듈러-프로그래밍을-위한-접근" class="headerlink" title="모듈러 프로그래밍을 위한 접근"></a>모듈러 프로그래밍을 위한 접근</h2><p>모듈러 프로그래밍은 프로그램의 설계 기술로 모듈의 분리와 모듈의 손쉬운 교체에 관심이 있습니다. 상호 교환 가능한 모듈을 정의할 수 있어야 합니다.<br>모듈러 프로그래밍의 첫 번째 과정은 모듈을 식별, 두번째는 모듈을 분리, 세번째 과정을 모듈을 공개 하는 것입니다.<br>모듈을 외부로 공개함으로써 프로젝트 내에 존재하는 특정 파일에서 호출해 사용할 수 있게 됩니다.</p><h2 id="내부-모듈과-외부-모듈"><a href="#내부-모듈과-외부-모듈" class="headerlink" title="내부 모듈과 외부 모듈"></a>내부 모듈과 외부 모듈</h2><p>내부 모듈의 네임스페이스는 여러 파일에 걸쳐 하나의 이름 공간을 공유하지만, 외부 모듈은 파일 모듈 파일마다 이름 공간이 정해집니다.</p><h3 id="내부-모듈"><a href="#내부-모듈" class="headerlink" title="내부 모듈"></a>내부 모듈</h3><p>내부 모듈인 네임스페이스는 전역 이름 공간과 분리된 네임스페이스 단위의 이름 공간입니다. 참조할 때는 별도의 참조문을 선언하지 않아도 됩니다.<br>네임스페이스는 전역 스코프에 속하지만 전역 스코프와 독립된 이름공간이라는 점.</p><h3 id="외부-모듈"><a href="#외부-모듈" class="headerlink" title="외부 모듈"></a>외부 모듈</h3><p>export로 선언한 모듈을 외부 모듈이라 합니다. 흔희 말하는 모듈은 외부 모듈을 가리킵니다.<br>외부 모듈의 이름 공간은 파일 내로 제한되므로 파일이 다르다면 외부 모듈의 이름이 같아도 괜찮지만 export를 생략해 외부 모듈로 선언하지<br>않으면 전역 스코프의 이름 공간을 공유해 이름 충돌이 발생합니다.</p><h2 id="네임스페이스"><a href="#네임스페이스" class="headerlink" title="네임스페이스"></a>네임스페이스</h2><p>네임스페이스는 하나의 독립된 이름 공간을 만들고 여러 파일에 걸쳐 하나의 이름 공간을 공유 할 수 있습니다.<br>namespace와 module은 키워드는 다르지만, 역할과 기능상 차이가 없습니다.</p><ul><li>타입스크립트 1.5 버전 이후에 내부 모듈을 선언 할 때는 module 대신에 namespace로 선언해야 합니다.</li></ul><p>내부 모듈은 자바스크립트로 컴파일 될때 즉시 실행 함수로 변환됩니다. </p><figure class="highlight javascript hljs"><figcaption><span>.js</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hello</span>) </span>{</span><br><span class="line">  <span class="hljs-comment">/* 내부 모듈의 이름 공간 */</span></span><br><span class="line">})(Hello || (Hello = {}));</span><br></pre></td></tr></tbody></table></figure><p>즉시 실행 함수에서 hello 매개변수는 함수 외부에서 함수 내부의 이름 공간에 접근 할수 있게 하는 역할을 합니다.</p><p>프로젝트 단위 컴파일을 수행하지 않고 특정 파일만을 컴파일할 때는 같은 네임스페이스라도 외부에 선언된 네임스페이스를 인식할 수 없습니다.<br>그럴땐 명시적으로 참조 경로를 선언해 줘야 합니다.</p><h3 id="네임스페이스-모듈"><a href="#네임스페이스-모듈" class="headerlink" title="네임스페이스 모듈"></a>네임스페이스 모듈</h3><p>네임스페이스는 export를 이용해 모듈로 선언할 수 있습니다. 모듈로 선언되 네임스페이스는 import 문을 이용해 JS로 컴파일된 뒤에도 명시적으로<br>모듈 호출(import문, require 함수 등)을 할 수 있습니다. </p><h3 id="네임스페이스의-이름-확장"><a href="#네임스페이스의-이름-확장" class="headerlink" title="네임스페이스의 이름 확장"></a>네임스페이스의 이름 확장</h3><p>네임스페이스 이름은 알파벳의 소문자와 대문자를 사용해 다음처럼 선언합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">namespace</span> Animal{...}</span><br></pre></td></tr></tbody></table></figure><p>네임스페이스 이름은 예외로 점(.)을 허용합니다. 점을 이용하면 네임스페이스 간의 이름 계층을 만드는 효과가 있습니다.<br>논리적인 이름 순서상 상위 이름은 앞에 선언돼야 하고 하위 이름은 상대적으로 뒤에 선언돼야 합니다. </p><h3 id="브라우저에서-네임스페이스의-모듈-호출"><a href="#브라우저에서-네임스페이스의-모듈-호출" class="headerlink" title="브라우저에서 네임스페이스의 모듈 호출"></a>브라우저에서 네임스페이스의 모듈 호출</h3><p>여러 타입스크립트 파일을 컴파일할 때 런타임시에 타입스크립트 파일을 인식하려면 가장 단순한 방법으로 out옵션으로 타입스크립트 파일을 컴파일하며 됩니다.<br>그런데 브라우저 상황은 다소 다릅니다. 파일을 하나로 합치지 않고 타입스크립트 파일을 개별적으로 컴파일하고 import문을 사용하지 않더라고 브라우저가<br>호출된 것처럼 인식합니다.</p><h2 id="모듈-선언과-모듈-임포트"><a href="#모듈-선언과-모듈-임포트" class="headerlink" title="모듈 선언과 모듈 임포트"></a>모듈 선언과 모듈 임포트</h2><p>타입스크립트 1.5부터는 ES2015 모듈 시스템을 지원합니다.<br>ES2015 모듈 시스템은 export나 import 제한자를 통해 모듈을 선언하고 호출 할 수 있습니다. 모듈은 export로 선언해야 외부로 노출됩니다.<br>export 키워드와 모듈 이름을 함께 선언해 모듈을 노출하는 방식을 명명된 내보내기(named exports)라고 합니다. 외부로 노출된 모듈은 import 키워드를 이용해 가져올 수 있습니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Information {...}</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) </span>{...}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> { add, sub } <span class="hljs-keyword">from</span> <span class="hljs-string">'./calc'</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="여러-모듈을-함께-export하기"><a href="#여러-모듈을-함께-export하기" class="headerlink" title="여러 모듈을 함께 export하기"></a>여러 모듈을 함께 export하기</h3><p>변수나 배열 등도 모듈로 선언할 수 있습니다. 모듈을 개벌적으로 선언해도 되지만 모듈을 선언할 때마다 export 키워드를 붙이는건 불편합니다.<br>이러한 점을 개선하기 위해 여러 모듈을 함께 export 해주면 편리합니다.<br>만약 모듈로 선언할 대상이 인터페이스를 사용하는 함수일 때는 함수가 인터페이스와 의존관계가 있으므로 함수와 인터페이스를 함께 export해야 합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> ver = <span class="hljs-string">'1.0'</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> author: <span class="hljs-built_in">string</span> = <span class="hljs-string">'happy'</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> extension = [<span class="hljs-string">'jpg'</span>, <span class="hljs-string">'bmp'</span>, <span class="hljs-string">'png'</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> display = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-string">'hello world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> { ver, author, extension, display };</span><br></pre></td></tr></tbody></table></figure><h3 id="가져온-모든-모듈을-재노출"><a href="#가져온-모든-모듈을-재노출" class="headerlink" title="가져온 모든 모듈을 재노출"></a>가져온 모든 모듈을 재노출</h3><p>재노출할 모듈이 많아 구체적인 이름을 열거하기가 불편할 때는 “export * from …”문법을 이용합니다. *은 모든 모듈을 의미합니다.<br>모듈 파일을 재노출할 때 모든 외부 모듈을 의미하는 *에 대한 별칭이 없으므로 임포트 할 때는 as 키워드를 이용해 별칭을 추가해야 합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span>  <span class="hljs-string">'./module1'</span>;</span><br><span class="line"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span>  <span class="hljs-string">'./module2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;</span><br></pre></td></tr></tbody></table></figure><p>모듈 파일에서 재노출한 전체 모듈을 참조할 수 있도록 m이라는 별칭을 추가 별칭 m은 재노출된 모듈에 접근할 수 있는 식별자로 이용됩니다.</p><h3 id="네임스페이스로-감싸서-재노출"><a href="#네임스페이스로-감싸서-재노출" class="headerlink" title="네임스페이스로 감싸서 재노출"></a>네임스페이스로 감싸서 재노출</h3><p>네임스페이스는 독립된 이름 공간이며 export를 이용해 모듈로 선언할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">namespace</span> CarInfo{...}</span><br></pre></td></tr></tbody></table></figure><p>export로 선언하며 다른 파일에서 임포트할 수 있는 모듈이 됩니다. 네임스페이스는 이름공간을 정의해 하위에 여러 모듈을 포함할 수 있는 특성이 있습니다.<br>이 때문에 네임스페이스를 기존에 흩어졌던 모듈을 다시 용도에 맞게 감싸서 재노출할 용도로 사용할 수 있습니다.</p><h3 id="디폴트-모듈"><a href="#디폴트-모듈" class="headerlink" title="디폴트 모듈"></a>디폴트 모듈</h3><p>타입스크립트 1.5가 발표되기 전에는 모듈을 선언할 때 export-equals 문으로 할당 했고, 모듈을 호출 할 때는 import-equals 문으로 임포트했습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> = validator</span><br><span class="line"><span class="hljs-keyword">import</span> Validator = <span class="hljs-built_in">require</span>(<span class="hljs-string">"validator"</span>);</span><br></pre></td></tr></tbody></table></figure><p>타입스크립트1.5에서는 import-equals 문과 export-equals 문 대신 다른 형태의 키워드를 이용합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {...}</span><br><span class="line"><span class="hljs-keyword">import</span> Validator <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;</span><br></pre></td></tr></tbody></table></figure><p>이외에도 모듈을 선언하는 방법은 여럿 있습니다. 익명 함수의 디폴트 모듈선언, 기명함수의 디폴트 함수선언, 클래스 선언</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>{...}</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>{...}</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> Hello {...}</span><br></pre></td></tr></tbody></table></figure><p>디폴트 모듈은 default 키워드를 사용해서 선언합니다. 디폴트 모듈의 특성은 모듈파일에 <strong>최대 1개</strong> 까지만 선언할 수 있습니다.<br>default 키워드를 두 번 사용하면 컴파일 에러가 발생합니다.<br>임포트할 디폴트 모듈은 {}에 선언하면 안 되고 {}가 없이 선언해야 합니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> p, {hello} <span class="hljs-keyword">from</span> <span class="hljs-string">'./defaul'</span>;</span><br></pre></td></tr></tbody></table></figure><p>이처럼 디폴트 모듈과 일반 모듈을 함께 임포트할 때는 디폴트 모듈은 이름만 선언하고 일반 모듈은 {} 내부에 모듈 이름을 선언해야 합니다.</p><h3 id="모듈-시스템"><a href="#모듈-시스템" class="headerlink" title="모듈 시스템"></a>모듈 시스템</h3><p>모듈 로더는 모듈 파일에 선언된 모듈을 실행할수 있습니다. 브라우저에서 동작하는 모듈로더는 느린로딩의 방식으로 모듈 파일을 가져와 모듈을 실행합니다.<br>타입스크립트에서는 모듈을 정의하거나 호출할 때 ES2015 모듈을 이용합니다. 타입스크립트는 자바스트립트로 컴파일돼 실행 합니다.<br>이때 ES2015 모듈이 표준이지만 더 많은 브라우저에서 지원하게 하고자 ES5 표준으로 컴파일 하되 ES2015 모듈은 모듈 로더를 통해 호출 할 수 있습니다.</p><p>모듈 로더마다 지원하는 명세가 다소 다릅니다. 최근 나오는 모듈 로더는 대체로 CommonJS 와 AMD 모듈 형식을 기본으로 지원합니다.</p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/05/14/Typescript-Module/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 클래스와 인터페이스</title>
      <link>https://mishka.kr/2020/04/29/TypeScript-class-Interface/</link>
      <guid>https://mishka.kr/2020/04/29/TypeScript-class-Interface/</guid>
      <pubDate>Wed, 29 Apr 2020 10:35:41 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;객체지향-프로그래밍과-클래스-기초&quot;&gt;&lt;a href=&quot;#객체지향-프로그래밍과-클래스-기초&quot; class=&quot;headerlink&quot; title=&quot;객체지향 프로그래밍과 클래스 기초&quot;&gt;&lt;/a&gt;객체지향 프로그래밍과 클래스 기초&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;객체지향 프로그래밍(Object Oriented Programming, OOP)은 커다란 문제를 클래스 단위로 나누고 클래스 간의 관계를 추가하면서 코드 중복을&lt;br&gt;최소화 하는 개발방식&lt;/strong&gt;이다. 클래스 간의 관계를 추가할 때는 상속이나 포함 관계를 고려하여 추가한다. OOP를 통해 어플리케이션을 개발하면 코드 중복을&lt;br&gt;상당히 줄일 수 있다. 타입스크립트는 자바스크립트(ES6)에 비해서 OOP를 지원하는 부분이 훨씬 더 많다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h2 id="객체지향-프로그래밍과-클래스-기초"><a href="#객체지향-프로그래밍과-클래스-기초" class="headerlink" title="객체지향 프로그래밍과 클래스 기초"></a>객체지향 프로그래밍과 클래스 기초</h2><p><strong>객체지향 프로그래밍(Object Oriented Programming, OOP)은 커다란 문제를 클래스 단위로 나누고 클래스 간의 관계를 추가하면서 코드 중복을<br>최소화 하는 개발방식</strong>이다. 클래스 간의 관계를 추가할 때는 상속이나 포함 관계를 고려하여 추가한다. OOP를 통해 어플리케이션을 개발하면 코드 중복을<br>상당히 줄일 수 있다. 타입스크립트는 자바스크립트(ES6)에 비해서 OOP를 지원하는 부분이 훨씬 더 많다.</p><a id="more"></a><p>클래스는 멤버 변수와 멤버 메서드 등으로 구성된 ‘틀’이며 클래스를 실제로 사용하려면 객체로 생성해야 한다.<br><strong>생성된 객체는 실제 메모리에 위치하고 객체의 참조가 객체 참조변수에 할당되는 과정을 인스턴스화(instantiate)</strong>라고 한다.</p><p>OOP에서 클래스 간의 관계는 크게 두 가지로 나누어 볼 수 있다. 하나는 상속 관계(IS-A)이며, 다른 하나는 포함 관계(HAS-A)이다.</p><blockquote><ul><li>상속 관계 : 상속은 클래스 계층을 만들어 코드 중복을 줄이는 객체지향 프로그래밍 방법이다.<br>타입스크립트는 클래스에 대해 단일 상속만 지원하므로 자식 클래스는 하나의 부모 클래스만 상속받을 수 있다.<br>자식 클래스가 부모 클래스를 상속받을 때는 자식 클래스의 생성자에서 super() 메서드를 호출해 부모 클래스의 생성자를 호출해 주어야 한다.</li><li>포함 관계 : 포함 관계는 클래스가 다른 클래스를 포함하는 HAS-A 관계이다. 클래스 내부에 다른 클래스를 포함하는 관계는<br>합성(composition) 관계와 집합(aggregation) 관계로 나뉜다. 합성 관계는 강한 관계인 반면, 집합 관계는 약한 관계이다.</li></ul></blockquote><p>추상 클래스(abstract class)는 구현 메서드와 추상 메서드(abstract method)가 동시에 존재할 수 있다. 여기에서 구현 메서드는 실제 구현 내용을 포함<br>한 메서드이고, 추상 메서드는 선언만 된 메서드이다. 이와 같이 추상 클래스는 구현 내용이 없는 추상 메서드를 포함하기 때문에 불완전한 클래스이다.<br>따라서 <strong>추상 클래스는 단독으로 객체를 생성할 수 없고 추상 클래스를 상속하고 구현 내용을 추가하는 자식 클래스를 통해 객체를 생성</strong>해야 한다. </p><p>구현하지 않은 추상 메서드가 선언되었으므로 자식 클래스에서는 추상 메서드를 오버라이딩(overriding)하여 반드시 구현해 주어야 한다.<br>또한 추상 클래스에 추상 멤버 변수가 선언되어 있으면 자식 클래스에서도 선언해야 한다. 추상 클래스를 작성할 때 abstract 키워드는<br>static 이나 private(public, protected는 가능)과 함께 선언할 수 없음에 주의해야 한다. </p><h2 id="인터페이스에-대한-이해"><a href="#인터페이스에-대한-이해" class="headerlink" title="인터페이스에 대한 이해"></a>인터페이스에 대한 이해</h2><p><strong>인터페이스(interface)는 클래스에서 구현 부분이 빠진 타입으로 이해하면 된다. 인터페이스는 컴파일 후에 사라지게 된다.</strong><br>인터페이스는 선언만 존재하며, 멤버 변수와 멤버 메서드를 선언할 수 있지만 접근 제한자는 설정할 수 없다.</p><p>자식 인터페이스의 경우 부모 인터페이스를 상속해서 확장할 수 있는데, 타입스크립트는 다중 상속이 가능하다. 만약 다중 상속을 받을 때<br>같은 이름의 메서드를 상속받으면, 상속받는 인터페이스에서 같은 이름의 메서드를 모두 재정의 해야 한다.</p><p><strong>인터페이스는 타입 선언이 많아도 컴파일(ES6) 후에는 모두 사라지므로 런타임 성능에 영향을 끼치지 않는다.</strong></p><h2 id="오버라이딩-Overriding"><a href="#오버라이딩-Overriding" class="headerlink" title="오버라이딩(Overriding)"></a>오버라이딩(Overriding)</h2><p><strong>오버라이딩은 부모 클래스에 정의된 메서드를 자식 클래스에서 새로 구현하는 것을 일컫는 개념이다.</strong><br>부모 클래스에서 오버라이딩을 당하는(?) 메서드를 오버라이든 메서드 라고 하고, 자식 클래스에서 오버라이딩된 메서드를 오버라이딩 메서드라고 했을 때,<br>오버라이딩이 이루어지기 위해서는 다음 두 가지의 조건을 만족해야 한다. </p><blockquote><ul><li>조건 1. 오버라이든 메서드의 매개변수 타입은 오버라이딩 메서드의 매개변수 타입과 같거나 상위 타입이어야 한다.<br>(단, 오버라이딩 메서드의 매개변수 타입이 Any 이면 예외)</li><li>조건2. 오버라이든 메서드의 매개변수 갯수가 오버라이딩 메서드의 매개변수 갯수와 같거나 많아야 한다.<br>(단, 조건 1이 성립하는 전제가 있어야 함)</li></ul></blockquote><h2 id="오버로딩-Overloading"><a href="#오버로딩-Overloading" class="headerlink" title="오버로딩(Overloading)"></a>오버로딩(Overloading)</h2><p><strong>메서드 오버로딩은 메서드의 이름이 같지만 매개변수의 타입과 개수를 다르게 정의하는 방법이다.</strong><br>클래스의 상속을 고려해 오버로딩을 구현하려면 부모 클래스에 상위 타입을 가지는 오버라이든 메서드를 선언해 두고 파생 클래스에서 오버라이딩 메서드를<br>선언해 구현할 수 있다. 이 때 오버라이딩 메서드가 오버로딩을 수행하려면 오버라이딩 메서드 위에 오버로드를 추가하면 된다.<br>인터페이스를 이용해서 오버로딩을 구현할 수도 있다. 인터페이스를 이용해 오버로딩을 하려면 인터페이스에 오버로딩할 기본 메서드를 선언해 준다.<br>그리고 인터페이스를 구현할 클래스에서 기본 메서드를 구현해 준다.</p><p><strong>인터페이스를 사용하면 선언과 구현을 분리할 수 있고 구현부의 구조를 강제할 수 있다.<br>이 점에서 로직과 구조가 섞여 있는 클래스를 상속해 오버로딩하는 것 보다 구조만을 포함하고 있는 인터페이스를 이용하는 것이 복잡도가 낮다.</strong></p><h2 id="다형성-polymorphism"><a href="#다형성-polymorphism" class="headerlink" title="다형성(polymorphism)"></a>다형성(polymorphism)</h2><p>다형성은 ‘여러 모양’을 의미하는 그리스 단어이고, 다형성에서 형은 타입을 의미한다. 프로그래밍 언어에서 다형성이란,<br>여러 타입을 받아들임으로써 여러 형태를 가지는 것을 의미한다. 타입스크립트에서 살펴볼 수 있는 다형성의 예로는 다음 세 가지가 있다.</p><blockquote><ul><li>클레스의 다형성</li><li>인터페이스의 다형성</li><li>매개변수의 다형성</li></ul></blockquote><h3 id="클래스의-다형성"><a href="#클래스의-다형성" class="headerlink" title="클래스의 다형성"></a>클래스의 다형성</h3><p>부모 클래스 A를 자식 클래스 B가 상속할 때 부모 클래스 A가 변수의 타입으로 지정되면 자식 클래스의 객체에 할당될 수 있다.<br>이 때 부모 클래스 A는 부모 클래스 A를 상속하는 어떤 자식 클래스의 타입이라도 받아들일 수 있는 다형 타입이 되고, 다형성을 띠게 한다.<br>런타임 시에 호출될 메서드가 결정되는 특성을 런타임 다형성이라고 한다. 런타임 다형성의 대표적인 예로 덕 타이핑(duck typing)이 있다.</p><h3 id="인터페이스의-다형성"><a href="#인터페이스의-다형성" class="headerlink" title="인터페이스의 다형성"></a>인터페이스의 다형성</h3><p>인터페이스 A가 있고 인터페이스 A를 구현한 클래스 B가 있을 때 클래스 B가 인터페이스 A 타입으로 지정된 변수에 할당될 때 생기는 다형성을 의미한다.<br>인터페이스를 구현한 클래스를 가지고 객체를 생성하면, 해당 객체 참조변수는 인터페이스에 정의된 멤버 변수, 메서드 등에 접근할 수는 있지만, 구현 클래스에 추가된 멤버 변수나 클래스에는 접근할 수가 없다.</p><h3 id="매개변수의-다형성"><a href="#매개변수의-다형성" class="headerlink" title="매개변수의 다형성"></a>매개변수의 다형성</h3><p>메서드의 매개변수가 여러 타입을 받아들이면서(유니언 타입, 인터페이스 타입 등) 생기는 다형성을 말한다.<br>매개변수의 타입이 여러 서브 타입을 받아들아면 해당 매개변수의 타입이 서브 타입 다형성이 된다. 반대로 자바스크립트의 매개변수처럼 타입을 지정하지 않고 여러 타입을 받아들이면 매개변수 다형성이 된다.</p><h2 id="Getter와-Setter"><a href="#Getter와-Setter" class="headerlink" title="Getter와 Setter"></a>Getter와 Setter</h2><p>자바스크립트에서는 객체의 멤버에 접근할 수 있는 방법으로 ES6의 getter와 setter를 지원한다. <strong>getter는 일반적으로 접근자(accessor)라 하고,<br>setter는 설정자(mutation)라 한다.</strong> 타입스크립트에서는 클래스 내에 get과 set 키워드를 통해 getter와 setter를 선언할 수 있다.<br>값을 설정하거나 읽을 때 로직을 추가하고 싶다면 get/set 키워드로 접근자와 설정자를 추가해 줄 수 있다. </p><h2 id="정적-변수와-정적-메서드"><a href="#정적-변수와-정적-메서드" class="headerlink" title="정적 변수와 정적 메서드"></a>정적 변수와 정적 메서드</h2><p>타입스크립트에서는 static 키워드를 지원한다. <strong>static 키워드는 클래스에 정적 멤버 변수나 정적 메서드 등을 선언할 때 사용할 수 있는데<br>객체 생성 없이 바로 접근이 가능하므로 메모리 절약 효과가 있다.</strong></p><p>static 키워드는 클래스에 선언된 멤버 변수를 객체 생성 없이 접근할 수 있게 해주는 장점이 있다.<br>이 경우 단일 상태를 관리하지만 외부에 변수를 둘 수 없는 문제점이 있다. 반드시 클래스를 통해 정적 멤버에 접근해야 하기 때문이다.<br>외부에 변수를 두면서 프로그램 단위에서 유일한 객체를 유지할 수 있게 하려면 싱글턴 패턴(Singleton Pattern)을 도입해야 한다.<br>싱글턴 패턴은 유일한 객체를 생성해 공유해서 사용하는 방식이다. 싱글턴 패턴에는 크게 두 가지가 있다. </p><blockquote><ul><li>부지런한 초기화(eager initialization)</li><li>게으른 초기화(lazy initialization).</li></ul></blockquote><h3 id="부지런한-초기화"><a href="#부지런한-초기화" class="headerlink" title="부지런한 초기화"></a>부지런한 초기화</h3><p>부지런한 초기화는 프로그램이 구동될 때 초기화가 일어나고 공개된 정적 메서드를 통해 생성된 객체를 얻는다.<br>싱글턴 객체는 사용자가 정의한 임의의 변수에 할당돼 접근할 수 있다.</p><h3 id="게으른-초기화"><a href="#게으른-초기화" class="headerlink" title="게으른 초기화"></a>게으른 초기화</h3><p>게으른 초기화는 프로그램이 구동될 때 초기화되지 않지만 공개된 정적 메서드를 호출하는 시점에 객체를 생성한다. 싱글턴 객체는 변수에 할당될 수 있다.</p><h2 id="readonly-제한자"><a href="#readonly-제한자" class="headerlink" title="readonly 제한자"></a>readonly 제한자</h2><p>readonly는 타입스크립트 2.0부터 지원하는 제한자이다. readonly가 선언된 변수는 초기화되면 재할당이 불가능하다.<br>const와 readonly의 공통점은 상수 선언이 가능하다는 점이다. 차이점은 다음과 같다.</p><blockquote><ol><li>const는 초기화가 필수이지만, readonly는 초기화가 선택이다.</li><li>const는 값 재할당이 불가능하지만, readonly는 가능하다.</li><li>const는 선언 가능한 대상이 전역 변수, 클래스 메서드의 변수, 함수의 변수 등이 있고 readonly는 선언 가능한 대상이 인터페이스의 멤버 변수,<br>클래스의 멤버 변수, 객체 리터럴의 속성, 새롭게 정의하는 타입 등이 있다.</li><li>const는 상수로 사용하고, readonly는 읽기 전용 속성을 가지고 있다.</li><li>const는 ES6인 경우 컴파일 후 선언이 유지되고, readonly는 컴파일 후 사라진다.</li></ol></blockquote></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/04/29/TypeScript-class-Interface/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 함수</title>
      <link>https://mishka.kr/2020/04/01/TypeScript-function/</link>
      <guid>https://mishka.kr/2020/04/01/TypeScript-function/</guid>
      <pubDate>Wed, 01 Apr 2020 09:30:43 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;함수는 애플리케이션의 코드를 구성하는 기본 요소입니다. 타입스크립트에서 함수는 클래스나 네이스페이스 내에 선언할 수 있고 때론 모듈로서 사용됩니&lt;br&gt;다. 자바스크립트에서 함수를 선언했던 것과 동일한 방식으로 선언해 사용자가 원하는 단위 기능을 수행 할 수 있습니다. &lt;code&gt;다른 점이 있다면 함수의 
매개변수나 반환값에 타입을 지정해 타입 안전성을 강화&lt;/code&gt;할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;자바스크립트-함수&quot;&gt;&lt;a href=&quot;#자바스크립트-함수&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트 함수&quot;&gt;&lt;/a&gt;자바스크립트 함수&lt;/h2&gt;&lt;h3 id=&quot;기명-함수와-익명-함수의-선언&quot;&gt;&lt;a href=&quot;#기명-함수와-익명-함수의-선언&quot; class=&quot;headerlink&quot; title=&quot;기명 함수와 익명 함수의 선언&quot;&gt;&lt;/a&gt;기명 함수와 익명 함수의 선언&lt;/h3&gt;&lt;p&gt;함수의 이름을 명시해 선언하는 &lt;code&gt;기명 함수(named function)&lt;/code&gt;와 함수의 이름을 명시하지 않고 사용하는 &lt;code&gt;익명 함수(anonymous function)&lt;/code&gt;로 나뉩니다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>함수는 애플리케이션의 코드를 구성하는 기본 요소입니다. 타입스크립트에서 함수는 클래스나 네이스페이스 내에 선언할 수 있고 때론 모듈로서 사용됩니<br>다. 자바스크립트에서 함수를 선언했던 것과 동일한 방식으로 선언해 사용자가 원하는 단위 기능을 수행 할 수 있습니다. <code>다른 점이 있다면 함수의 매개변수나 반환값에 타입을 지정해 타입 안전성을 강화</code>할 수 있습니다.</p><h2 id="자바스크립트-함수"><a href="#자바스크립트-함수" class="headerlink" title="자바스크립트 함수"></a>자바스크립트 함수</h2><h3 id="기명-함수와-익명-함수의-선언"><a href="#기명-함수와-익명-함수의-선언" class="headerlink" title="기명 함수와 익명 함수의 선언"></a>기명 함수와 익명 함수의 선언</h3><p>함수의 이름을 명시해 선언하는 <code>기명 함수(named function)</code>와 함수의 이름을 명시하지 않고 사용하는 <code>익명 함수(anonymous function)</code>로 나뉩니다.</p><a id="more"></a><p>기명 함수는 호출될 때 호이스팅이 발생합니다. 따라서 함수를 선언하기 전에도, 함수를 선언한 후에도 호출 할 수 있습니다. 반면 익명 함수는 함수를 할당한<br>뒤에만 호출 할 수 있도록 제한 할 수 있습니다.</p><h3 id="자바스크립트-함수의-불안전성"><a href="#자바스크립트-함수의-불안전성" class="headerlink" title="자바스크립트 함수의 불안전성"></a>자바스크립트 함수의 불안전성</h3><p>자바스크립트는 느슨한 타입언어 입니다. 매개변수의 타입이나 반환 타입은 없지만, 프로그램이 실행될 때 동적으로 타입을 할당해 추론된 타입이 지정됩니<br>다. 타입이 없기 때문에 런타임 때 의도하지 않은 타입 변환이 일어날수 있다는 문제가 있습니다. 타입을 고정할 수 없어 때로는 타입 안정성을 갖추기 위해<br>타입 검사와 타입 캐스팅과 같은 불필요한 코드를 추가할 수밖에 없습니다.</p><h2 id="타입스크립트-함수"><a href="#타입스크립트-함수" class="headerlink" title="타입스크립트 함수"></a>타입스크립트 함수</h2><p>타입스크립트는 함수의 매개변수나 반환 타입을 추가해 타입 안전성을 강화합니다. 매개변수에 타입을 지정해 숫자 값만 받을 수 있도록 타입을 제한할 수<br>있고, 함수의 반환 타입을 지정해 잘못된 타입의 값이 반환되지 않도록 합니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ex</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{ ... }</span><br></pre></td></tr></tbody></table></figure><p>위와 같이 함수에 매개변수 타입이나 반환 타입을 추가하는 과정을 함수에 대한 타입지정(typing)이라 합니다.</p><h2 id="매개변수의-활용"><a href="#매개변수의-활용" class="headerlink" title="매개변수의 활용"></a>매개변수의 활용</h2><h3 id="기본-초기와-매개변수"><a href="#기본-초기와-매개변수" class="headerlink" title="기본 초기와 매개변수"></a>기본 초기와 매개변수</h3><p>기본 초기화 매개변수는 함수의 특정 매개변수에 인수가 전달되지 않으면 매개변수에 설정된 초깃값으로 값을 초기화하는 기능입니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x: <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span></span><br></pre></td></tr></tbody></table></figure><p>매개변수 목록에는 일반 매개변수와 기본 초기화 매개변수를 함께 선언할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ex2</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span> = 2</span>): <span class="hljs-title">number</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="나머지-매개변수"><a href="#나머지-매개변수" class="headerlink" title="나머지 매개변수"></a>나머지 매개변수</h3><p>나머지 매개변수는 ES6에서 제안된 특징으로 개수가 정해지지 않은 인수를 배열로 받을 수 있는 기능입니다. 개수가 정해지지 않은 만큼 순서가 크게<br>중요하지 않은 여러 요소를 전달하는 데 유용합니다. 나머지 매개변수는 “…”형태로 선언합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rest</span>(<span class="hljs-params">...restParams</span>) </span>{...}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 나머지 매개변수에 타입 지정</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rest</span>(<span class="hljs-params">...restParams: <span class="hljs-built_in">string</span>[]</span>) </span>{...}</span><br></pre></td></tr></tbody></table></figure><p>나머지 매개변수는 0개 이상의 요소를 받을 수 있습니다. 나머지 매개변수에 타입을 추가하면 지정한 타입의 인수만 받을 수 있습니다.</p><h3 id="선택-매개변수"><a href="#선택-매개변수" class="headerlink" title="선택 매개변수"></a>선택 매개변수</h3><p>함수 호출 시 매개변수를 선언한 만큼 인수를 전달해야 합니다. 나머지 매개변수는 0개 이상의 인수를 받으므로 매개변수에 나머지 매개변수만 선언돼 있다<br>면 인수 전달을 생략해도 됩니다. 선택 매개변수는 변수명 뒤에 물음표를 붙이는 식으로 선언합니다. 선택 매개변수를 이용하면 선택 매개변수로 지정한 매개<br>변수는 생략이 가능합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">select</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{...}</span><br></pre></td></tr></tbody></table></figure><p>함수 호출 시 함수에 선언된 매개변수는 2개지만, 두 번째 매개변수는 선택 매개변수를 사용함으로써 인수 하나를 생략해 호출하더라고 에러가 발생하지<br>않습니다. 앞에서 사용한 매개변수 초깃값을 설정하는 방법은 선택 매개변수와 결합해서 사용할 수 없습니다.</p><h3 id="함수-오버로드"><a href="#함수-오버로드" class="headerlink" title="함수 오버로드"></a>함수 오버로드</h3><p>함수 오버로드는 함수명은 같지만, 매개변수와 반환 타입이 다른 함수를 여러 개 선언할 수 잇는 특징을 말합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b:<span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b:<span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">any</span>, b:<span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>가장 일반적인 함수의 시그니처를 가장 아래에 선언하고 그 위로 구체적인 타입을 명시한 함수의 시그니처를 쌓는 방식으로 선언해야 합니다.<br>이때 매개변수의 개수가 다른 오버로드를 지정할 때는 선택 매개변수를 둬 매개변수 개수에 변화를 줄 수 있도록 허용할 수 있습니다.</p><h2 id="익명-함수"><a href="#익명-함수" class="headerlink" title="익명 함수"></a>익명 함수</h2><h3 id="익명-함수와-화살표-함수"><a href="#익명-함수와-화살표-함수" class="headerlink" title="익명 함수와 화살표 함수"></a>익명 함수와 화살표 함수</h3><p>화살표 함수(arrow function)는 ES6 표준에 포함된 익명 함수를 좀 더 간략하게 표현 할 수 있는 방법입니다. 파이선, C++, 자바 8에서는<br>화살표 함수를 ‘람다 함수(lambda function)’ 라고도 부릅니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">() => {};</span><br><span class="line"><span class="hljs-keyword">let</span> x = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {};</span><br><span class="line"><span class="hljs-keyword">let</span> y =  <span class="hljs-function"><span class="hljs-params">x</span> =></span> { <span class="hljs-keyword">return</span> x; };</span><br></pre></td></tr></tbody></table></figure><p>매개변수가 1개일 때는 화살표 함수의 매개변수 목록에 있는 소괄호를 생략할 수 있습니다. 변수에 할당하지 않고 화살표 함수를 사용하려면 즉시 호출 함수를 이용해야 합니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-params">x</span> =></span> { x; })(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">let</span> iif = (<span class="hljs-function"><span class="hljs-params">x</span> =></span> { <span class="hljs-keyword">return</span>  x; })(<span class="hljs-number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>즉시 호출 함수가 반환값을 가져 변수에 할당해야 한다면 중괄호 내부에서 return 키워드를 사용, 실행하면 변수 iif에 즉시 호출 함수가 반환한<br>값이 할당 됩니다.</p><h3 id="필터-메서드"><a href="#필터-메서드" class="headerlink" title="필터 메서드"></a>필터 메서드</h3><p>필터 메서드는 배열에서 조건에 맞는 요소를 추출 하는데 사용합니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];</span><br><span class="line">numbers = numbers.filter(<span class="hljs-function"><span class="hljs-params">n</span> =></span> {</span><br><span class="line">  <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;</span><br><span class="line">})</span><br><span class="line"><span class="hljs-built_in">console</span>.log(numbers);</span><br><span class="line"><span class="hljs-comment">// 결과 [ 2, 4 ]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="리듀스-메서드"><a href="#리듀스-메서드" class="headerlink" title="리듀스 메서드"></a>리듀스 메서드</h3><p>배열 값의 합을 손쉽게 구할 때는 리듀스 메서드를 이용할 수 있습니다. 리듀스 메서드는 누산기의 원리처럼 배열의 요소를 왼쪽에서 오른쪽으로 더해나가<br>면서 누산된 값을 처리 할 수 있는 함수입니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].reduce(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =></span> { <span class="hljs-keyword">return</span> a + b; })</span><br></pre></td></tr></tbody></table></figure><p>리듀스 메서드의 첫 번째 매개변수는 누적된 값이고 두 번째 매개변수는 현재 카운터의 값입니다.</p><h3 id="객체-리터러릥-선언과-객체-리터럴-타입의-선언"><a href="#객체-리터러릥-선언과-객체-리터럴-타입의-선언" class="headerlink" title="객체 리터러릥 선언과 객체 리터럴 타입의 선언"></a>객체 리터러릥 선언과 객체 리터럴 타입의 선언</h3><p>객테 리터럴은 여러 속성과 값을 한 단위로 묶어서 표현할 수 있는 객체입니다. 속성은 키(key)가 되고 값(value)은 숫자나 문자열뿐만 아니라<br>사용자가 정의한 객체도 할당 할 수 있습니다. 정의한 객체 리터럴 내부에서 다른 프로퍼티를 참조할 일이 많다면 객체 리터럴의 타입을 선언해 내부<br>참조를 함으로써 코드 어시스트가 동작하게 할 수 있습니다.</p><figure class="highlight typescript hljs"><figcaption><span>인터페이스를 이용해 객체 리터럴 타입을 선언</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> PersonType {</span><br><span class="line">  name: <span class="hljs-built_in">string</span>;</span><br><span class="line">  hello(<span class="hljs-keyword">this</span>: PersonType, name2: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>유의할 점은 this 는 반드시 첫 번째 매개변수로 선언해야 합니다. </p><h2 id="익명-함수의-함수-타입"><a href="#익명-함수의-함수-타입" class="headerlink" title="익명 함수의 함수 타입"></a>익명 함수의 함수 타입</h2><h3 id="익명-함수의-타입-선언"><a href="#익명-함수의-타입-선언" class="headerlink" title="익명 함수의 타입 선언"></a>익명 함수의 타입 선언</h3><p>익명 함수는 변수에 할당할 수 있습니다. 함수 자체에 대한 타입을 함수 타입(function type)이라고 합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> exFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str1: <span class="hljs-built_in">string</span>, str2: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>{ <span class="hljs-keyword">return</span> str1 + str2};</span><br></pre></td></tr></tbody></table></figure><p>익명 함수의 매개변수나 반환값에 타입을 지정할 수 있지만 익명 함수가 구현체이므로 타입을 선언하면 형태가 복잡해집니다. 이러한 점을 개선하기 위해<br>익명함수에 선언된 타입을 별도로 분리해 함수 타입으로 선언하면, 쉽게 파악할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> exFunc: <span class="hljs-function">(<span class="hljs-params">str1: <span class="hljs-built_in">string</span>, str2: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">string</span> = <span class="hljs-function">(<span class="hljs-params">str1, str2</span>) =></span> { <span class="hljs-keyword">return</span> str1 + str2; };</span><br></pre></td></tr></tbody></table></figure><p>함수 타입을 type 앨리어스 를 이용해 별도로 분리하면 반복적으로 사용할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> exType = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =></span> <span class="hljs-built_in">number</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> addValue: exType = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> a + b;</span><br><span class="line"><span class="hljs-keyword">let</span> minusValue: exType = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> a - b;</span><br></pre></td></tr></tbody></table></figure><p>각 변수에 함수 타입을 선언 했으므로 익명 함수의 매개변수 타입이나 반환 타입을 선언하지 않더라도 타입 안정성을 확보할 수 있습니다.</p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/04/01/TypeScript-function/#disqus_thread</comments>
    </item>
    
    <item>
      <title>webstorm 과 jira 연동해서 사용하기</title>
      <link>https://mishka.kr/2020/03/30/webstorm-jira/</link>
      <guid>https://mishka.kr/2020/03/30/webstorm-jira/</guid>
      <pubDate>Mon, 30 Mar 2020 10:00:25 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;webstorm을 사용하고 업무를 진행할 때 &lt;code&gt;jira&lt;/code&gt;를 사용하다보니 jira를 별도의 창으로 띄워놓고 이슈를 생성하고, webstorm에서 작업하다가 커밋하면서&lt;br&gt;jira 티켓번호 생성하고 푸시한 다음에 티켓을 이동시켜주고 하는 반복작업이 많아졌습니다. 어떻게 보면 별거아닌 작업일 수 있지만 까먹게 되는 일이&lt;br&gt;많고 바쁠때는 모아서 하기도 하다보니 이슈 트레킹 하는데 문제가 있어보여 찾아보다가 연동하는 방법을 찾아 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;단축키는 &lt;code&gt;Mac OS&lt;/code&gt;를 기준으로 정리하였습니다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>webstorm을 사용하고 업무를 진행할 때 <code>jira</code>를 사용하다보니 jira를 별도의 창으로 띄워놓고 이슈를 생성하고, webstorm에서 작업하다가 커밋하면서<br>jira 티켓번호 생성하고 푸시한 다음에 티켓을 이동시켜주고 하는 반복작업이 많아졌습니다. 어떻게 보면 별거아닌 작업일 수 있지만 까먹게 되는 일이<br>많고 바쁠때는 모아서 하기도 하다보니 이슈 트레킹 하는데 문제가 있어보여 찾아보다가 연동하는 방법을 찾아 정리해 보았습니다.</p><p>단축키는 <code>Mac OS</code>를 기준으로 정리하였습니다.</p><a id="more"></a><h2 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h2><p>webstorm에서 <code>preferences > Tasks > Servers</code> 로 이동합니다. 화면에서 <strong>+</strong> 버튼을 클릭해서 <strong>JIRA</strong>를 선택합니다.</p><p><img src="/img/webstorm/jira-select.png" alt><br>JIRA 외에 다른 이슈 트레커들도 연동해서 사용할 수 있습니다.</p><p>JIRA 버튼을 누르면 설정창이 뜨는데 설정창에서 Server URL 에는 JIRA 주소를 입력합니다. 그리고 계정/비밀번호를 입력해 줍니다.<br>저는 회사계정으로 입력했더니 비밀번호 입력하는 칸이 <code>API Token</code> 을 입력하는 칸으로 변경되더라구요. </p><p><img src="/img/webstorm/jira-apitoken.png" alt></p><blockquote><p>API 토큰 생성 방법은 atlassian 사이트를 참고 하셔서 발급 받으시면됩니다. -<a href="https://confluence.atlassian.com/cloud/api-tokens-938839638.html" rel="external nofollow noopener noreferrer" target="_blank">사이트 링크</a><br>API token은 한번 발급 받으면 다시 볼수 없으니 계속해서 사용하고 싶으시면 개인저장소에 저장해놓거나 잃어버리면 새로 발급 받아야합니다.</p></blockquote><p>Search 입력란은 Task 목록을 방식을 설정하는 방식을 이야기하는데 기본값으로 최신정렬순으로 되어있으니 필요하신분만 수정하시면 됩니다.</p><p><img src="/img/webstorm/jira-setting.png" alt><br>설정이 끝나면 우측 하단에 있는 <code>Test</code> 버튼을 클릭하여 테스트를 해볼수 있습니다. <strong>Connection is successful</strong> 이라는 메세지가 나오면 됩니다.<br>그리고 나서 Apply > OK 눌러주시면 설정은 끝났습니다.</p><h2 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h2><p>사용해본 결과 현재(2020.03.30일 기준 2019.3 버전) webstorm에서는 JIRA 티켓 생성은 지원하고 있지 않았습니다.<br>기존에 되어있는 티켓을 Task 가져오는게 아니라면 티켓 생성은 JIRA 사이트에서 해주어야 합니다. </p><p><code>Tools > Tasks & contexts > Open Task</code> 로 <strong>본인에게 할당된 티켓 목록</strong>을 볼 수 있습니다. 단축키는 <code>option+shift+n</code> 입니다.</p><p><img src="/img/webstorm/jira-ticket.png" alt></p><p>테스트를 위해 티켓을 별도로 하나 생성했습니다. FE-66 티켓을 선택해 주면 아래와 같은 창이 열립니다.<br>update issue state는 티켓의 state를 원하는 상태로 변경할 수 있습니다. clear current context는 현재 편집기에 열려있는 모든 탭을 닫습니다.<br>create branch 를 하면 원하는 브런치를 생성 할수도 있고, gitflow 메뉴를 이용하면 gitflow 정책대로 브런치를 생성 할 수도 있습니다.gitflow 정책에 대해서는 지난 블로그 내용을 참고 바랍니다. <a href="/2020/03/30/webstorm-gitflow/">webstorm에서 gitflow 사용하기</a><br><img src="/img/webstorm/jira-task.png" alt></p><p>개발이 완료되면 커밋을 해줍니다. 단축키는 <code>command+k</code> 입니다.</p><p><img src="/img/webstorm/jira-commit.png" alt><br>커밋 메세지는 자동생성되는데 기본 옵션으로 <code>티켓ID + 제목</code> 으로 되어있고 설정을 변경할 수 있습니다.<br><code>Preferences > Tasks > Servers</code> <strong>Commit Message 탭</strong>을 클릭해서 원하는 규칙으로 수정 할 수 있습니다.</p><p><img src="/img/webstorm/jira-commit-message.png" alt></p><p>티켓 상태도 상황에 맞게 변경 할 수 있습니다. 단축키는 <code>option+shift+w</code> 입니다.</p><p><img src="/img/webstorm/jira-state.png" alt></p><h2 id="추가-설정"><a href="#추가-설정" class="headerlink" title="추가 설정"></a>추가 설정</h2><p>기본적으로 Task에서 생성해주는 브랜치 명은 티켓ID 로 자동할당됩니다. 생성 템플릿을 변경하려면<br><code>Preferences > Tasks</code>에서 <strong>Feature branch name format</strong>을 원하는 규칙으로 수정하면됩니다.</p><p><img src="/img/webstorm/jira-format.png" alt></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://jojoldu.tistory.com/260" rel="external nofollow noopener noreferrer" target="_blank">IntelliJ를 JIRA와 연동해서 사용하기</a><br><a href="https://www.jetbrains.com/help/idea/managing-tasks-and-context.html#" rel="external nofollow noopener noreferrer" target="_blank">IntelliJ IDEA</a><br><a href="https://confluence.atlassian.com/cloud/api-tokens-938839638.html" rel="external nofollow noopener noreferrer" target="_blank">API tokens</a></p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/30/webstorm-jira/#disqus_thread</comments>
    </item>
    
    <item>
      <title>webstorm에서 gitflow 사용하기</title>
      <link>https://mishka.kr/2020/03/30/webstorm-gitflow/</link>
      <guid>https://mishka.kr/2020/03/30/webstorm-gitflow/</guid>
      <pubDate>Mon, 30 Mar 2020 09:30:17 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;vscode 에서 webstorm으로 갈아타면서 플러그인으로 사용하던 몇가지 기능들을 webstorm 에서도 사용해 보고 싶었습니다.&lt;br&gt;그 중에 git 을 사용하다 보면 대부분의 경우 &lt;strong&gt;&lt;a href=&quot;/2020/03/30/gitflow&quot;&gt;git-flow&lt;/a&gt;&lt;/strong&gt; 를 따라서 작업을 진행하게 됩니다. 물론 cli 를 이용해서&lt;br&gt;정책만을 따라 가며 작업할 수 있지만 번거로운 작업들도 있고 급할때는 까먹기도 하기 때문에 편하게 사용하는 방법을 찾아보았습니다.&lt;br&gt;&lt;strong&gt;&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7315-git-flow-integration&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;IntelliJ Git Flow Integration&lt;/a&gt;&lt;/strong&gt;를 이용한 방법입니다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>vscode 에서 webstorm으로 갈아타면서 플러그인으로 사용하던 몇가지 기능들을 webstorm 에서도 사용해 보고 싶었습니다.<br>그 중에 git 을 사용하다 보면 대부분의 경우 <strong><a href="/2020/03/30/gitflow">git-flow</a></strong> 를 따라서 작업을 진행하게 됩니다. 물론 cli 를 이용해서<br>정책만을 따라 가며 작업할 수 있지만 번거로운 작업들도 있고 급할때는 까먹기도 하기 때문에 편하게 사용하는 방법을 찾아보았습니다.<br><strong><a href="https://plugins.jetbrains.com/plugin/7315-git-flow-integration" rel="external nofollow noopener noreferrer" target="_blank">IntelliJ Git Flow Integration</a></strong>를 이용한 방법입니다.</p><a id="more"></a><h2 id="gitflow-설치"><a href="#gitflow-설치" class="headerlink" title="gitflow 설치"></a>gitflow 설치</h2><p>그 전에 gitflow 를 사용할때는 별도로 gitflow 를 설치하지 않았었는데 webstorm에서 gitflow 를 사용하려면 <code>avh</code> 버전으로 설치가 필요하다.<br>mac OS의 경우 <strong><a href="/2019/09/27/zsh-setting">homebrew</a></strong> 를 통해 gitflow 를 설치해줍니다. </p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git-flow-avh</span><br></pre></td></tr></tbody></table></figure><blockquote><p>다른 OS 환경에서의 설치 방법은 <a href="https://github.com/petervanderdoes/gitflow-avh/wiki/Installation" rel="external nofollow noopener noreferrer" target="_blank">링크</a>를 참고하세요</p></blockquote><p>gitflow 를 설치하고 나면 preferences > plugins > marketplace 에서 <code>Git Flow Integration</code> 를 검색하여 설치해 줍니다.</p><p><img src="/img/webstorm/gitflow-integration.png" alt="Git Flow Integration"></p><p>Webstorm을 재시작하면 설치가 완료됩니다.</p><h2 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h2><p>플러그인 설치 후 Webstorm 우측 하단을 보시면 아래그림과 같이 No Gitflow 를 보이시면 정상적으로 설치가 완료된것입니다.</p><p><img src="/img/webstorm/gitflow-nogitflow.png" alt></p><p>No Gitflow 를 클릭하셔셔 init Repo 를 선택하면 아래와 같은 설정화면이 나옵니다.</p><center><img src="/img/webstorm/gitflow-setting.png" alt="Option for gitflow init"></center><p>기본 옵션이 git-flow 규칙을 따라 설정되어있어서 똑같은 규칙으로 사용하시다면 별도의 수정없이 OK 눌러 주시면됩니다.</p><p>기본 옵션을 설정하고 나면 No gitflow 에서 gitflow 로 변경되고 gitflow 를 클릭하면 원하시는 동작을 할 수 있습니다.</p><p><img src="/img/webstorm/gitflow-start.png" alt></p><p>Start Feature를 눌러 feature 브런치를 생성하고 finish feature를 하면 자동으로 develop 브런치에 merge 가 이루어집니다.<br>Git flow 전략에 따라 버튼만 선택해주면 모든 이벤트가 자동으로 진행됩니다. 별도로 브랜치를 체크아웃하면서 merge, remove, tag 등을 할 필요가 없어서 반복작업의 시간을 줄일 수 있습니다.</p><p>merge의 기본옵션은 fast-forward 입니다. 이를 변경하여 merge도 하나의 커밋으로 취급하고 싶으신 분들은 prefereces > Other Settings ><br>gitflow 에서 Do not fast-forward when merging, always create commit(–no-ff) 옵션에 체크 하시면됩니다.</p><p><img src="/img/webstorm/gitflow-fast-forward.png" alt></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://jojoldu.tistory.com/268" rel="external nofollow noopener noreferrer" target="_blank">Git Flow Integration으로 Git Flow 심플하게 운영하기</a><br><a href="https://plugins.jetbrains.com/plugin/7315-git-flow-integration" rel="external nofollow noopener noreferrer" target="_blank">Git Flow Integration</a><br><a href="https://k39335.tistory.com/82" rel="external nofollow noopener noreferrer" target="_blank">Gitflow로 branch를 관리하자!!</a></p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/30/webstorm-gitflow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>gitflow 란? git-flow 를 사용한 브랜치 전략</title>
      <link>https://mishka.kr/2020/03/30/gitflow/</link>
      <guid>https://mishka.kr/2020/03/30/gitflow/</guid>
      <pubDate>Mon, 30 Mar 2020 09:05:57 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;GitFlow&quot;&gt;&lt;a href=&quot;#GitFlow&quot; class=&quot;headerlink&quot; title=&quot;GitFlow?&quot;&gt;&lt;/a&gt;GitFlow?&lt;/h2&gt;&lt;p&gt;깃플로우(git-flow) 전략은 소프트웨어의 소스코드를 관리하고 출시하기 위한 &lt;strong&gt;‘브랜치 관리 전략(branch management strategy)’&lt;/strong&gt;중 하나이다.&lt;br&gt;git-flow 전략외에도 &lt;a href=&quot;https://guides.github.com/introduction/flow/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;github flow&lt;/a&gt; 와 &lt;a href=&quot;https://about.gitlab.com/blog/2014/09/29/gitlab-flow/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;gitlab flow&lt;/a&gt; 전략등도 있다. 각자에게 맞는 전략을 선택해서 사용하는게 가장 중요하다.&lt;br&gt;git-flow 는 Vicent Driessen 이 제안한 git 의 workflow 디자인에 기반한 브랜칭 모델이다. git-flow 에서 사용하는 브랜치의 종류는 5가지이며,&lt;br&gt;크게 항상 유지되는 메인브렌치(master, develop)와 일정 기간 유지되는 보조 브랜치(feature, realease, hotfix)로 나뉜다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow?"></a>GitFlow?</h2><p>깃플로우(git-flow) 전략은 소프트웨어의 소스코드를 관리하고 출시하기 위한 <strong>‘브랜치 관리 전략(branch management strategy)’</strong>중 하나이다.<br>git-flow 전략외에도 <a href="https://guides.github.com/introduction/flow/" rel="external nofollow noopener noreferrer" target="_blank">github flow</a> 와 <a href="https://about.gitlab.com/blog/2014/09/29/gitlab-flow/" rel="external nofollow noopener noreferrer" target="_blank">gitlab flow</a> 전략등도 있다. 각자에게 맞는 전략을 선택해서 사용하는게 가장 중요하다.<br>git-flow 는 Vicent Driessen 이 제안한 git 의 workflow 디자인에 기반한 브랜칭 모델이다. git-flow 에서 사용하는 브랜치의 종류는 5가지이며,<br>크게 항상 유지되는 메인브렌치(master, develop)와 일정 기간 유지되는 보조 브랜치(feature, realease, hotfix)로 나뉜다.</p><a id="more"></a><blockquote><ul><li>Master - 제품으로 출시 되는 브랜치</li><li>Develop - 다음 출시 버전을 개발하는 브랜치</li><li>Feature - 기능을 개발하는 브랜치</li><li>Realease - 이번 출시 버전을 준비하는 브랜치</li><li>Hotfix - 출시 버전에서 발생한 버그를 수정하는 브랜치</li></ul></blockquote><p>많은 그림들 중에 역시 아래의 그림이 git-flow를 한눈에 이해하기에는 가장 좋은 것 같아서 가져왔다.<br><img src="/img/git-flow-model.png" alt="git-flow-model"></p><h2 id="개발-흐름"><a href="#개발-흐름" class="headerlink" title="개발 흐름"></a>개발 흐름</h2><p>위의 그림을 토대로 개발 흐름을 보자면 처음에 <code>Master</code> 와 <code>Develop</code> 브랜치를 만드는데,<br>Develop는 Master에서 부터 시작되는 브랜치입니다. 위 두 브랜치는 항상 존재하는 브랜치 입니다.<br>새로운 추가 작업이 있는 경우 <strong>Develop</strong> 에서 <code>Feature</code> 브랜치를 생성한다.<br>Feature는 언제나 Develop에서 시작해야 합니다. 기능추가 작업이 완료되면 Feature는 Develop로 <strong>Merge</strong>한다.<br>QA를 위해 <strong>Develop</strong>에서 <code>Release</code> 브랜치를 생성한다. QA를 진행 하면서 발생한 버그들은 Release에 수정된다.<br>QA가 끝나면 Release 브랜치를 <strong>Develop</strong> 와 <strong>Master</strong> 브랜치로 각각 <strong>Merge</strong> 한다.<br><code>Hotfix</code> 브랜치는 언제나 Master에서 시작해야 합니다. 작업이 완료되면 Hotfix는 <strong>Master</strong> 와 <strong>Develop</strong> 브랜치로 각각 <strong>Merge</strong> 한다.</p><p>더욱 자세한 내용은 <a href="https://nvie.com/posts/a-successful-git-branching-model/" rel="external nofollow noopener noreferrer" target="_blank">A successful Git branching model</a>를 참고하세요.</p><p>git 을 여러사람이 함께 사용하다보면 필연적으로 브랜치 전략을 세워서 git을 관리해야됩니다. 어떤 브랜치 전략을 사용하는지는 해당 팀의 성격에 맞게 선택하고 함께 공유하는게 중요하다고 생각합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" rel="external nofollow noopener noreferrer" target="_blank">A successful Git branching model</a><br><a href="https://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html" rel="external nofollow noopener noreferrer" target="_blank">우린 Git-flow를 사용하고 있어요 - 우아한형제들 기술 블로그</a></p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/30/gitflow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 제어문 과 연산자</title>
      <link>https://mishka.kr/2020/03/25/TypeScript-4/</link>
      <guid>https://mishka.kr/2020/03/25/TypeScript-4/</guid>
      <pubDate>Wed, 25 Mar 2020 09:30:24 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;조건문&quot;&gt;&lt;a href=&quot;#조건문&quot; class=&quot;headerlink&quot; title=&quot;조건문&quot;&gt;&lt;/a&gt;조건문&lt;/h2&gt;&lt;p&gt;타입스크립트는 자바스크립트에서 사용했던 조건문을 사용할 수 있습니다. 대표적으로 &lt;code&gt;if 문과 switch&lt;/code&gt; 문이 있습니다.&lt;br&gt;if 문은 조건의 참과 거짓에 따라 분기를 수행하는 조건문, switch 문은 입력값에 따라 분기를 결정하는 조건문입니다.&lt;/p&gt;
&lt;h3 id=&quot;if-문&quot;&gt;&lt;a href=&quot;#if-문&quot; class=&quot;headerlink&quot; title=&quot;if 문&quot;&gt;&lt;/a&gt;if 문&lt;/h3&gt;&lt;p&gt;if 문은 조건이 참인지 거짓인지 판단하고 분기를 수행합니다.&lt;/p&gt;
&lt;figure class=&quot;highlight typescript hljs&quot;&gt;&lt;figcaption&gt;&lt;span&gt;if 문 형식&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (조건) {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  명령문;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;이때 if 문에 지정하는 조건은 참과 거짓을 판단할 수 있는 &lt;strong&gt;불리언(boolean) 타입&lt;/strong&gt;이어야 합니다. 이때 if 문에 사용할 변수도 다음과 같이 명시적으로 불리언 타입으로 선언해야 합니다.&lt;/p&gt;
&lt;figure class=&quot;highlight typescript hljs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; idEnable: &lt;span class=&quot;hljs-built_in&quot;&gt;boolean&lt;/span&gt; = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h2 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h2><p>타입스크립트는 자바스크립트에서 사용했던 조건문을 사용할 수 있습니다. 대표적으로 <code>if 문과 switch</code> 문이 있습니다.<br>if 문은 조건의 참과 거짓에 따라 분기를 수행하는 조건문, switch 문은 입력값에 따라 분기를 결정하는 조건문입니다.</p><h3 id="if-문"><a href="#if-문" class="headerlink" title="if 문"></a>if 문</h3><p>if 문은 조건이 참인지 거짓인지 판단하고 분기를 수행합니다.</p><figure class="highlight typescript hljs"><figcaption><span>if 문 형식</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (조건) {</span><br><span class="line">  명령문;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이때 if 문에 지정하는 조건은 참과 거짓을 판단할 수 있는 <strong>불리언(boolean) 타입</strong>이어야 합니다. 이때 if 문에 사용할 변수도 다음과 같이 명시적으로 불리언 타입으로 선언해야 합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> idEnable: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><p>if 문의 조건이 만족하면 if 블록을 실행합니다. if문 뒤에 바로 if 문이 오는 경우 <strong>중첩이 가능하고 괄호를 생략</strong>할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-number">10</span>><span class="hljs-number">1</span>)</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span><<span class="hljs-number">1</span>) {</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>이어서 if 문의 조건이 false 일때 예외 사항을 처리하기 위해 else 문을 추가할 수 있습니다.</p><p>숫자열 타입에서 숫자가 0이면 false 이고, 0 이 아닌 나머지 값은 true 입니다.<br>문자열 타입은 빈 값일 때는 false 이고, 값이 있을 때는 true 입니다. </p><h3 id="switch-문"><a href="#switch-문" class="headerlink" title="switch 문"></a>switch 문</h3><p>switch 문은 비교할 대상이 많을 때 단순한 형태로 비교를 수행하기 위해 사용합니다. 타입스크립트의 switch 문은 자바스크립트의 switch 문과 형식이 같습니다.</p><figure class="highlight typescript hljs"><figcaption><span>switch 문 형식 </span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">switch</span> (표현식) {</span><br><span class="line">  <span class="hljs-keyword">case</span> 값<span class="hljs-number">1</span>:</span><br><span class="line">    명령문;</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">  <span class="hljs-keyword">case</span> 값<span class="hljs-number">2</span>:</span><br><span class="line">    명령문;</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">  <span class="hljs-keyword">default</span>:</span><br><span class="line">    명령문;</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>switch/case 절에서는 <code>break</code> 문을 통해 switch 문을 벗어날 수 있어야 하고, case 절에 부합하지 않는 예외 조건을 처리하기 위해 때로는 <code>default</code> 절을<br>추가할 필요가 있습니다. switch 문의 표현식에는 변수가 올 수 있고 표현식의 값과 일치하는 case 절이 실행됩니다. 이때 case 절에 선언한 값에 표현식 값<br>과 다른 타입이 오는 것을 방지하기 위해 표현식에 사용할 변수에 타입을 지정할 수 있습니다. 이렇게 하면 switch 문에 있는 표현식 값과 case 절에 오는 값의 타입이 일치하게 됩니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> command: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">switch</span> (command) {</span><br><span class="line">  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:</span><br><span class="line">    <span class="hljs-comment">// 명령문</span></span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:</span><br><span class="line">    <span class="hljs-comment">// 명령문</span></span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>switch 문의 조건은 number 타입이므로 case 절의 값은 모두 number 타입이어야 합니다.<br>switch 문을 사용할 때 case 절에 사용할 타입이 고정적이라면 반드시 입력 변수에 타입을 선언해야 하고, 그렇지 않다면 any 타입을 지정해야 합니다.</p><h4 id="폴스루"><a href="#폴스루" class="headerlink" title="폴스루"></a>폴스루</h4><p>case 절에서는 break 문을 사용해 switch 문을 벗어납니다. 그런데 때에 따라 break 문을 생략할 수 있습니다. 만약 break 문을 생략하면 다음 case 절이<br>실행됩니다. 이러한 상태를 <strong>폴스루(fall-through)</strong>라고 합니다.<br>noFallthroughCaseInSwitch 옵션의 기본값은 false 이므로 폴스루를 허용할 것 이라면 false 로 지정하거나 위 옵션을 추가하지 않고 생략하면 됩니다.</p><figure class="highlight bash hljs"><figcaption><span>tsconfig.json</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="hljs-string">"compilerOptions"</span>: {</span><br><span class="line">    <span class="hljs-string">"noFallthroughCaseInSwitch"</span>: <span class="hljs-literal">true</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>파일 단위로 컴파일할 때 폴스루를 방지하려면 tsc 명령어 뒤에 –noFallthroughCaseInSwitch 옵션을 추가합니다.</p><p>예외적으로 noFallthroughCaseInSwitch 옵션을 true 로 설정하더라고 폴스루를 허용하는 방법은 case 절에 <code>아무런 명령문도 넣지 않는 것</code>입니다.</p><h2 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h2><p>타입스크립트는 ECMA 스크립트를 따르므로 자바스크립트의 반복문을 지원합니다.</p><h3 id="for-문"><a href="#for-문" class="headerlink" title="for 문"></a>for 문</h3><figure class="highlight typescript hljs"><figcaption><span>for 문 형식</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (변수 초기화; 조건식; 증감식) {</span><br><span class="line">  명령문;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>for 문에서 사용할 변수에 ES6에서 지원되는 let 키워드와 타입을 지정할 수 있습니다.</p><h3 id="for-in-문"><a href="#for-in-문" class="headerlink" title="for in 문"></a>for in 문</h3><p>for in 문은 ES5의 자바스크립트에서 배열이나 객체를 순화할 때 사용, for in 문에 선언된 index 변수는 인덱스를 나타냅니다. 이때 배열의 요소를 가져오려면 인덱스를 통해 값에 접근 할 수 있습니다.<br>만약 인덱스가 숫자가 아닌 키라고 한다면 객체 리터럴을 이용하면 됩니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> island = [<span class="hljs-string">"jejudo"</span>, <span class="hljs-string">"Jindo"</span>, <span class="hljs-string">"Geojedo"</span>];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> island) {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(index, island[index]);</span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// for in 문을 이용해 객체 리터럴을 순회</span></span><br><span class="line"><span class="hljs-keyword">let</span> fruits = { <span class="hljs-string">"a"</span> : <span class="hljs-string">"apple"</span>, <span class="hljs-string">"b"</span>: <span class="hljs-string">"banana"</span> };</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> property <span class="hljs-keyword">in</span> fruits) {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(property, fruits[property]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="for-of-문"><a href="#for-of-문" class="headerlink" title="for of 문"></a>for of 문</h3><p>for of 문은 ES6 표준에 추가된 특징으로 타입스크립트 1.5부터 지원, for in 문과 달리 for of 문은 <code>곧바로 값을 가져올 수 있습니다.</code></p><figure class="highlight typescript hljs"><figcaption><span>for of 문 형식</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (변수 <span class="hljs-keyword">if</span> 이터러블) {</span><br><span class="line">  명령문; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>이터러블(iterable)</code>은 반복 가능한 객체인 배열, 문자열, DOM 콜렉션, 맵과 셋 등을 말합니다.</p><p>일반 for 문에서는 let 선언자가 아닌 const 를 사용할 수 없습니다. 만약 일반 for문에서 let 대신 const 응 사용하면 상수가 되어 증가 값이 바꾸지 않기 때문에 <code>무한 루프</code>가 됩니다.<br>그런데 for of 문은 <code>Symbol.iterator</code> 의 구현을 통해 각 이터레이션 값의 요소를 가져오기 때문에 const를 사용할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value of [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]){</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="맵과-셋"><a href="#맵과-셋" class="headerlink" title="맵과 셋"></a>맵과 셋</h3><p>ES6에 추가된 이터러블 객체로 맵과 셋이 있습니다. 맵과 셋은 tsconfig.json 파일의 <code>target 속성이 ES5</code>이면 컴파일되지 않습니다.<br>이는 ES5에 <code>맵과 셋에 대응할 만한 문법이 존재하지 않기 때문</code>입니다. 맵과 셋을 이용하는 for of 문을 정상적으로 실행하려면 tsconfig.json 파일의 target을 es2015 로 수정해야 합니다.</p><p>셋 객체는 어떤 타입의 값이든 유일한 값을 저장할 수 있습니다. 셋 객체는 맵처럼 타입스크립트 컴파일러 target 속성값이 es2015일 때 컴파일됩니다.</p><p>Set 객체가 제공하는 메서드는 값을 추가하거나(add), 값을 비우거나(clear), 값을 삭제하는 것(delete)과 같이 키가 아닌 값을 메서드를 제공합니다.<br>Set 객체는 ES5에 존재하지 않으므로 ES5로 컴파일하면 for 문으로 변환됩니다. </p><h3 id="Symbol-iterator-메서드"><a href="#Symbol-iterator-메서드" class="headerlink" title="[Symbol.iterator]() 메서드"></a>[Symbol.iterator]() 메서드</h3><p>[Symbol.iterator]() 메서드는 ES6에 추가된 특징으로 배열, 맵, 셋 과 같은 이터러블 객체를 순회하는데 사용합니다.<br>사용자가 새로운 이터러블 객체를 만들어 for of, for in 문에 적용하려면 [Symbol.iterator]() 메서드를 이용해 이터러블 객체로 구현해야 합니다.</p><h3 id="while-문"><a href="#while-문" class="headerlink" title="while 문"></a>while 문</h3><p>타입스크립트의 while 문은 자바스크립트 ES5와 동일한 문법을 사용합니다. while 문은 <code>조건이 참이면 명령문을 실행하며 조건이 거짓이면 명령문의 실행을 끝내는 반복문</code>입니다.</p><figure class="highlight typescript hljs"><figcaption><span>while 문 형식</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> (참/거짓을 판별할 수 있는 조건문) {</span><br><span class="line">  명령문</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>while 문은 for 문과 달리 while 문에서 변수를 초기화할 수 없지만, 루프를 반복할지 여부를 루프 내부에서 결정할 수 있다는 장점이 있습니다.</p><h3 id="do-while-문"><a href="#do-while-문" class="headerlink" title="do-while 문"></a>do-while 문</h3><p>타입스크립트의 do-while 문은 자바스크립트 ES5와 동일합니다. do-while 문은 명령문을 실행하고 나서 조건이 참이면 명령문을 실행하고 거짓이면 명령문을 실행을 끝내는 반복문입니다.</p><figure class="highlight typescript hljs"><figcaption><span>do-while 문 형식</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> cnt: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">do</span> {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(cnt);</span><br><span class="line">  cnt++;</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">while</span> (cnt !=<span class="hljs-number">4</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><h3 id="산술연산자"><a href="#산술연산자" class="headerlink" title="산술연산자"></a>산술연산자</h3><p>타입스크립트는 자바스크립트와 동일한 산술연산자를 지원합니다. 산술연산자로는 더하기, 빼기, 곱하기, 나누기 같은 사칙연산과 나머지 연산을 수행할 수 있는 % 연산자가 있습니다.<br>추가로 ES7의 지수 연산자인 **를 지원하므로 Math.pow 를 대체해 사용할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">10</span> + <span class="hljs-number">2</span>, <span class="hljs-number">10</span> - <span class="hljs-number">2</span>, <span class="hljs-number">10</span> / <span class="hljs-number">2</span>, <span class="hljs-number">10</span> % <span class="hljs-number">2</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">10</span> ** <span class="hljs-number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>+ <span class="hljs-string">"happy"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-string">"happy"</span> );</span><br></pre></td></tr></tbody></table></figure><p>산술연산자가 포함된 코드를 컴파일하면 산술 연산자가 포함된 식은 변하지 않습니다. 다만 지수 연산자가 포함된 10 ** 3 은 ES5나 ES6로 컴파일 하면<br>Math.pow(10,3)로 변환돼 컴파일 됩니다. 문자열간의 더하기 연산은 자바스크립트처럼 문자열 결합으로 인식합니다.</p><p>타입스크립트에서는 숫자 값과 불리언 값은 연산할 수 없으며, 자바스크립트처럼 false 값을 0으로 인식하지 않습니다. 따라서 <code>숫자값과 불리언 값의 덧셈은연산할 수 없으며</code> 불리언 값끼리의 연산식도 타입오류가 발생합니다. 타입스크립트에서는 문자열 타입의 숫자를 연산식에 사용할 수 없습니다.</p><h3 id="비교-논리-조건-연산자"><a href="#비교-논리-조건-연산자" class="headerlink" title="비교, 논리, 조건 연산자"></a>비교, 논리, 조건 연산자</h3><p>타입스크립트에서 조건문에 사용할 수 있는 연산는 크게 세가지로 나눌수 있습니다.</p><blockquote><ul><li>비교 연산자</li><li>논리 연산자</li><li>조건 연산자</li></ul></blockquote><p>비교연산자로는 ==, ===, !=, !==, >, <, >=, <= 가 있습니다. 자바스크립트와 다른점은 1 == true, 1 == “1” 과 같이 <code>피연산자간에 타입이 다르면 연산을 허용하지 않습니다.</code><br>이는 피연산자 간의 비교연산을 할 때 타입 안전성을 고려하기 때문입니다.</p><p>논리 연산자로는 &&, ||, ! 가 있습니다. 비교 연산자와 달리 논리 연산자는 피연산자끼리 타입이 일치하지 않아도 됩니다.<br>&& 은 피연산자가 모두 참일 때 참, ||은 피연산자 가운데 하나 이상이 참일 때 참을 의미합니다.<br>!은 부정 연산자 !true 와 같이 true 를 부정하면 false 이고 !false 와 같이 false 를 부정하면 true 입니다.</p><p>조건 연산자는 피연산자 3개를 사용하는 삼항 연산자 입니다.<br>형식은 <code>판별조건? 표현식1 : 표현식2</code> 이고 판별 조건에 따라 표현식1과 표현식2 가운데 하나를 반환합니다. 이때 판별 조건의 결과는 true/false 여야<br>하며, true 일 때는 표현식1이 실행되고 false 일때는 표현식2가 실행됩니다.</p><blockquote><p>Boolean 메서드를 이용하면 입력값을 고려해 불리언 타입으로 변환할 수 있습니다.</p></blockquote><h2 id="디스트럭처링"><a href="#디스트럭처링" class="headerlink" title="디스트럭처링"></a>디스트럭처링</h2><p>타입스크립트는 ES6의 디스트럭처링(destructuring)을 지원합니다. 디스트럭쳐링이라는 말의 뜻은 <code>객체의 구조를 제거한다는 의미</code>가 있습니다.</p><blockquote><ul><li>객체 디스트럭처링</li><li>배열 디스트럭처링</li></ul></blockquote><h3 id="객체-디스트럭처링"><a href="#객체-디스트럭처링" class="headerlink" title="객체 디스트럭처링"></a>객체 디스트럭처링</h3><p>객체 디스트럭처링은 객체 리터럴에서 변수명에 대응하는 속성값을 추출해 변수로 할당하는데 유용합니다.<br>이렇게 객체의 속성값을 변수에 할당하는 것을 <code>디스트럭처링 할당</code> 이라고 합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> { id, country } = { id: <span class="hljs-string">"happy"</span>, country: <span class="hljs-number">88</span> };</span><br></pre></td></tr></tbody></table></figure><p>디스트럭처링 할당 표현식은 { id, country } 와 같습니다. 디스트럭처링 할당 시 표현식 내부의 id와 country 변수는 객체의 속성값과 대응합니다. 따라서 id에는 happy 가 country 에는 88 이 할당됩니다.<br>디스트럭처링 할당 시 할당할 객체의 속성에 새로운 이름을 부여해 할당하려면 속성 재명명을 이용할 수 있습니다.</p><p>type 키워드를 이용해 매개변수의 타입을 선언함으로써 객체 디스트럭처링을 수행할 수 있습니다.</p><h3 id="배열-디스트럭처링"><a href="#배열-디스트럭처링" class="headerlink" title="배열 디스트럭처링"></a>배열 디스트럭처링</h3><p>배열 디스트럭처링은 배열 요소를 간결한 방법으로 변수에 할당하는 방법을 제공합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> numbers = [ <span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span> ];</span><br><span class="line"><span class="hljs-keyword">let</span> [num1, num2] = numbers;</span><br></pre></td></tr></tbody></table></figure><p>만약 numbers 배열의 세 번째, 네 번째 요소를 변수에 할당하려면 앞의 요소는 쉼표로 건너뛰고 원하는 위치에 있는 요소만 변수로 지정합니다.</p><p>배열 디스트럭처링을 이용하면 함수에 배열을 전달할 때 배열 요소를 디스트럭처링 매개변수로 전달할 수 있다는 장점이 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params">[first, second]: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]</span>) </span>{ ... }</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params">[100, "hello"]</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="전개-연산자"><a href="#전개-연산자" class="headerlink" title="전개 연산자"></a>전개 연산자</h2><p>타입스크립트는 ES6의 전개 연산자를 지원합니다. 전개 연산자는 ‘…’ 로 나타내는데 다음 세가지 경우에 사용됩니다.</p><blockquote><ul><li>나머지 매개변수를 선언할 때</li><li>배열 요소를 확장할 때</li><li>객체 요소를 확장할 때</li></ul></blockquote><h3 id="나머지-매개변수"><a href="#나머지-매개변수" class="headerlink" title="나머지 매개변수"></a>나머지 매개변수</h3><p>나머지 매개변수는 여러 인수를 배열로 받는데 “…매개변수” 와 같은 형태로 선언해 받습니다.</p><h3 id="배열-요소-확장"><a href="#배열-요소-확장" class="headerlink" title="배열 요소 확장"></a>배열 요소 확장</h3><p>전개 속성에 전개 연산자를 사용해 배열을 합칠 수 있습니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, ...arr];</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr2);</span><br><span class="line"><span class="hljs-comment">// 출력 [1,2,3,4,5]</span></span><br></pre></td></tr></tbody></table></figure><p>이때 전개 속성은 위치를 조정할 수 있습니다. ([…arr, 1, 2])</p><p>배열 디스트럭처링이 수행되면 배열은 해체해 여러 변수에 할당하는데, 할당받는 변수에 전개 연산자인 “…”을 사용하면 배열의 나머지 요소를 배열로 받을 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> [firstItem, ...rest]: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];</span><br></pre></td></tr></tbody></table></figure><h3 id="객체-요소-확장"><a href="#객체-요소-확장" class="headerlink" title="객체 요소 확장"></a>객체 요소 확장</h3><p>객체 합치기를 수행할 때는 전개 속성에 전개 연산자인 “…”를 사용해 합칠 수 있습니다. </p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> obj = { c:<span class="hljs-number">3</span>, d:<span class="hljs-number">4</span>, e:<span class="hljs-number">5</span> };</span><br><span class="line"><span class="hljs-keyword">let</span> obj2 = { a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, ...obj };</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj2);</span><br><span class="line"><span class="hljs-comment">// 출력 { a:1, b:2, c:3, d:4, e:5 }</span></span><br></pre></td></tr></tbody></table></figure><p>전개 연산자는 얕은 복사(shallow copy)방식으로 obj2 객체로 복사합니다. </p><p>객체 디스트럭처링은 객체를 해체해 속성값을 변수에 할당할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> {n1, ...rest} = { n1:<span class="hljs-number">1</span>, n2:<span class="hljs-number">2</span>, n3:<span class="hljs-number">3</span> };</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/25/TypeScript-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 변수 선언과 기본 타입</title>
      <link>https://mishka.kr/2020/03/18/TypeSctipt-3-var/</link>
      <guid>https://mishka.kr/2020/03/18/TypeSctipt-3-var/</guid>
      <pubDate>Wed, 18 Mar 2020 10:44:32 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;var-의-특징&quot;&gt;&lt;a href=&quot;#var-의-특징&quot; class=&quot;headerlink&quot; title=&quot;var 의 특징&quot;&gt;&lt;/a&gt;var 의 특징&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;호이스팅&lt;/li&gt;
&lt;li&gt;함수 레벨 스코프(블록 레벨 스코프 지원 되지 않음)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;var의 첫 번째 특징은 &lt;strong&gt;호이스팅&lt;/strong&gt; 입니다. 호이스팅은 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상입니다.&lt;br&gt;두 번째 특징은 &lt;strong&gt;함수 레벨 스코프(function level scope)&lt;/strong&gt;를 지원하므로 함수 내에서 선언한 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없다는 것이다. var 는 블록 레벨 스코프(block level scope)를 지원하지 않는다. 블록 레벨 스코프란 블록{} 내에서만 유효하고 블록 외부에서는 참조 할 수 없는 것을 말한다.&lt;/p&gt;
&lt;p&gt;블록 레벨 스코프를 지원하는 하는 대표적인 선언은 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;let, const&lt;/li&gt;
&lt;li&gt;클래스, 인터페이스, 타입 에일리어스(type alias), enum 선언&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h2 id="var-의-특징"><a href="#var-의-특징" class="headerlink" title="var 의 특징"></a>var 의 특징</h2><blockquote><ul><li>호이스팅</li><li>함수 레벨 스코프(블록 레벨 스코프 지원 되지 않음)</li></ul></blockquote><p>var의 첫 번째 특징은 <strong>호이스팅</strong> 입니다. 호이스팅은 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상입니다.<br>두 번째 특징은 <strong>함수 레벨 스코프(function level scope)</strong>를 지원하므로 함수 내에서 선언한 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없다는 것이다. var 는 블록 레벨 스코프(block level scope)를 지원하지 않는다. 블록 레벨 스코프란 블록{} 내에서만 유효하고 블록 외부에서는 참조 할 수 없는 것을 말한다.</p><p>블록 레벨 스코프를 지원하는 하는 대표적인 선언은 다음과 같다.</p><blockquote><ul><li>let, const</li><li>클래스, 인터페이스, 타입 에일리어스(type alias), enum 선언</li></ul></blockquote><a id="more"></a><h2 id="let-의-특징"><a href="#let-의-특징" class="headerlink" title="let 의 특징"></a>let 의 특징</h2><p>호이스팅 방지와 블록 레벨 스코프를 지원할 방법으로 ES6에서 let 선언자가 나왔고, 타입스크립트에서도 let 선언자를 지원합니다. 다음과 같은 특징을 가지고 있습니다.</p><blockquote><ul><li>블록 내에서 변수를 중복 선언 방지</li><li>호이스팅 방지</li><li>선언할 변수에 블록 레벨 스코프 적용</li></ul></blockquote><h2 id="const-의-특징"><a href="#const-의-특징" class="headerlink" title="const 의 특징"></a>const 의 특징</h2><p>const는 ES6의 특징이며 타입스크립트에서도 지원한다. let과 같은 블록 레벨 스코프를 지원하며 호이스팅을 일으키지 않습니다.<br>let과 다른 점은 const는 변수를 상수로 선언할 때 사용한다는 점이다. const를 이용해 변수를 상수로 선언하면 선언할 때 초기화는 가능하지만 재할당되지 않는 읽기전용(read only) 변수가 됩니다.<br>예외적으로 const로 선언한 변수라도 객체 리터럴의 속성으로는 변경할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> profile = {</span><br><span class="line">  name : <span class="hljs-string">"happy"</span>,</span><br><span class="line">  month: <span class="hljs-number">8</span>,</span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// const profile = "unhappy"; 재할당 불가능</span></span><br><span class="line">profile.name = <span class="hljs-string">"happy2"</span>; <span class="hljs-comment">// 속성에 할당 가능</span></span><br></pre></td></tr></tbody></table></figure><p>이는 타입스크립트가 값 자체를 재할당하는 것은 허용하지 않지만, 속성값의 변경을 허용하는 특성이 있기 때문이다.</p><h2 id="타입-검사와-타입선언"><a href="#타입-검사와-타입선언" class="headerlink" title="타입 검사와 타입선언"></a>타입 검사와 타입선언</h2><h3 id="타입-검사의-종류"><a href="#타입-검사의-종류" class="headerlink" title="타입 검사의 종류"></a>타입 검사의 종류</h3><p>언어에 따라 수행하는 타입 검사의 종류는 크게 ‘정적 타입 검사(statically type checking)’와 ‘동적 타입 검사(dynamically type checking)’로 나뉩니다. 정적 타입 검사는 자바, C++ 등의 언어에서 사용하고, 동적 타입 검사는 실행시간에 타입검사를 수행하며 대표적으로는 자바스크립트가 있습니다.</p><p>타입스크립트는 ‘점진적 타입 검사(gradually type checking)’를 수행합니다. 점진적 검사를 하는 대표적인 언어로는 타입스크립트와 파이썬등이 있습니다. 점진적 타입 검사는 컴파일 시간에 타입 검사를 수행하면서 필요에 따라 타입 선언의 생략을 허용합니다. 타입스크립트에서 점진적 타이핑을 성명할 때 적절한 타입으로 <strong>any</strong>가 있습니다.<br>any 타입은 모든 타입의 최상위 타입이며, 동적 타입과 정적 타입의 경계선에 있는 타입으로 타입스크립트에서는 특별히 다뤄집니다.<br>any 타입으로 선언된 변수는 어떤 타입의 변수도 받아들이면서 심지어 타입이 없는 변수도 받아들입니다.</p><h3 id="자바스크립트의-동적-타이핑"><a href="#자바스크립트의-동적-타이핑" class="headerlink" title="자바스크립트의 동적 타이핑"></a>자바스크립트의 동적 타이핑</h3><p>자바스크립트에는 기본타입과 객체타입이 있습니다. 기본 타입은 Number, Boolean, String 과 같은 타입을 말하고, 객체 타입으로는 객체 리터럴, 배열, 내장객체가 있습니다.<br>자바스크립트에는 타입이 있지만 <code>타입을 강제할 수는 없고 값을 할당할 때 타입이 추론됩니다.</code> 값을 변수에 할당 할때 타입이 정해지는 것을 <strong>동적 타이핑(dynamic typing)</strong>이라 합니다. </p><p>타입을 명시하지 않고 값을 할당하면 입력값에 따라 타입이 동적으로 정해지므로 정해진 타입을 예측할 수 없습니다. 따라서 변수의 안전한 사용을 위해서는 타입을 검사하는 코드를 불가피하게 추가 해야 합나다.</p><h2 id="타입-스크립트-계층도"><a href="#타입-스크립트-계층도" class="headerlink" title="타입 스크립트 계층도"></a>타입 스크립트 계층도</h2><center><img src="/img/Typescript_Type.png" alt="타입스크립트 타입계층도"></center><h3 id="기본-타입"><a href="#기본-타입" class="headerlink" title="기본 타입"></a>기본 타입</h3><p>기본 타입은 보편적으로 많이 사용되는 내장 타입으로서 타입 스크립트에서 지원하는 기본 타입의 종류는 다음과 같습니다.</p><blockquote><ul><li>String, number, boolean</li><li>symbol(ECMA 2015에 추가)</li><li>enum</li><li>문자열 리터럴</li></ul></blockquote><p>문자열 값을 표현할 때 역따옴표를 이용할수 있는데 역따옴표를 이용하면 줄 구분 없이 문장을 입력할 수 있습니다. 또한, 역따옴표 내에는 내장 표현식을 이용할 수 있습니다.</p><h3 id="객체-타입"><a href="#객체-타입" class="headerlink" title="객체 타입"></a>객체 타입</h3><p>객체 타입은 속성을 포함하고 있으며, 호출 시그니처, 생성자 시그니처 등으로 구성된 타입입니다. 타입스크립트에서 지원하는 객체 타입의 종류는 다음과 같습니다.</p><blockquote><ul><li>Array</li><li>Tuple</li><li>Function</li><li>Constructor</li><li>Class</li><li>Interface</li></ul></blockquote><p>tuple은 배열 요소가 n개로 정해질 때 각 요소별로 타입을 지정한 타입입니다. 예를 들어 배열 요소가 문자열과 숫자라면 <code>[string, number]</code> 같은 형태로 타입을 정의합니다.</p><h3 id="기타-타입"><a href="#기타-타입" class="headerlink" title="기타 타입"></a>기타 타입</h3><blockquote><ul><li>유니언(Union)</li><li>인터섹션(Intersection)</li><li>특수 타입</li></ul></blockquote><p>유니언 타입은 <code>2개 이상의 타입을 하나의 타입으로 정의한 타입</code>입니다. 특수 타입으로 타입 계층도의 가장 아래쪽에 위치한 void, null, undefined 있습니다. void는 빈 값을 나타내는 타입입니다.<br>함수에 반환값이 없을 때 void 타입을 선언할 수 있는데 undefined 나 null 값을 받을 때 사용합니다.</p><p><code>non-nullable</code>은 null이나 undefined를 허용하지 않는 타입이고, <code>룩업(lookup)</code> 타입은 인터페이스를 이용해 키값을 설정할 수 있는 타입입니다.</p><ul><li>객체 타입의 상위 타입으로 any 추가</li><li>any 타입의 특수 타입으로 유니언 타입과 인터섹션 타입추가</li><li>객체 타임의 하위 타입으로 Array, Interface, Tuple 추가</li><li>Void 타입 추가</li></ul><h3 id="변수에-타입-지정"><a href="#변수에-타입-지정" class="headerlink" title="변수에 타입 지정"></a>변수에 타입 지정</h3><blockquote><p><strong>[형식]</strong><br>var <변수 식별자>:<타입> = <값>;</p></blockquote><p>변수에 타입을 명시적으로 지정할 수 있습니다. 명시적 타입표기를 하면 변수에 어떤 값이 할당될지 직관적으로 알 수 있습니다.</p><h2 id="자바스크립트의-타입"><a href="#자바스크립트의-타입" class="headerlink" title="자바스크립트의 타입"></a>자바스크립트의 타입</h2><p>타입을 지정할 수 있는 타입스크립트와 달리 자바스크립트에서는 별도로 타입을 지정하는 절차가 없고, 런타임 시 변수에 값이 할당되면 동적으로 타입이 결정됩니다.</p><h3 id="symbol-타입"><a href="#symbol-타입" class="headerlink" title="symbol 타입"></a>symbol 타입</h3><p>ES6에서 추가된 특징으로 객체 속성의 <strong>유일하고 불변적인 식별자</strong>로 사용된다. Symbol 타입은 Symbol 함수를 이용해 다음과 같은 형태로 선언한다.</p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> hello = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"hello"</span>);</span><br></pre></td></tr></tbody></table></figure><p>Symbol 함수는 심벌 객체를 반환, 이때 Symbol 함수가 유일한 식별자를 생성하는 팩토리 함수의 역할을 합니다. Symbol 함수를 호출할 때 “hello” 인수는 심벌의 설명을 의미한다.<br>설명은 심벌에 접근할 때 사용할 수 있으며, 생략할 수 있다. </p><h3 id="enum-타입"><a href="#enum-타입" class="headerlink" title="enum 타입"></a>enum 타입</h3><p>enum 타입은 ES6에 제안된 타입으로, 컴파일 시간에 평가된다. 타입 계층도로 보면 number 타입의 하위 타입으로 자바스크립트로 컴파일된 후에는 객체 리터럴이나 배열처럼 객체 타입이 됩니다.<br>typeof를 통해 타입 이름을 표시하면 <code>object</code>로 표시됩니다.</p><p>enum은 명명된 숫자 상수의 집합을 정의할 때 사용합니다. 명명된 숫자 상수는 enum의 속성에 대응하는 값으로서 속성은 열거해 선언할 수 있습니다.</p><blockquote><p>[형식]<br>enum Day { 속성: 값, 속성: 값, 속성: 값, … };</p></blockquote><h2 id="타입스크립트의-내장-타입"><a href="#타입스크립트의-내장-타입" class="headerlink" title="타입스크립트의 내장 타입"></a>타입스크립트의 내장 타입</h2><h3 id="any-타입"><a href="#any-타입" class="headerlink" title="any 타입"></a>any 타입</h3><p>any 타입은 제약이 없는 타입으로 <code>어떤 타입의 값도 받아들일 수 있습니다</code>. 자바스크립트가 최소한의 정적 타입 검사를 수행하는 것처럼 최소한의 타입 검사만 수행 합니다.<br>임의의 값을 받아들일 때 any 타입은 any 키워드로 선언할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> basket: <span class="hljs-built_in">any</span> = <span class="hljs-number">10</span>;</span><br><span class="line">basket = <span class="hljs-literal">true</span>;</span><br><span class="line">basket = <span class="hljs-string">"banana"</span>;</span><br></pre></td></tr></tbody></table></figure><p>any는 확정된 타입은 아니지만 어떤 값이든 할당받을 수 있습니다. 뿐만아니라 배열의 타입으로 사용하면 어떤 타입의 요소도 받아들일 수 있으므로 유연하게 활용할 수 있습니다.</p><p>any 타입은 모든 타입의 <code>가장 최상위 타입</code>입니다. 다시 말해 모든 타입은 any 타입의 하위 타입입니다. 그래서 any 타입은 자바스크립트의 모든 값을 할당 받을 수 있습니다.</p><p><code>object 타입</code>은 any 타입처럼 타입 구분 없이 값을 할당할 수 있는 특성이 있어 any 타입과 비슷하지만 속성 유무를 검사하는 시점이 다릅니다.<br>any 타입으로 선언한 변수는 속성의 유무를 런타임 시에 검사하지만, object 타입으로 선언한 변수는 컴파일 시간에 속성의 유무를 검사합니다.<br>따라서 object 타입의 변수에 숫자를 할당하더라고 컴파일 시에 숫자 메서드를 인식하지 못하므로 컴파일 시간에 에러가 발생합니다.</p><h3 id="noImplicitAny-옵션"><a href="#noImplicitAny-옵션" class="headerlink" title="noImplicitAny 옵션"></a>noImplicitAny 옵션</h3><p>any 타입의 사용을 강제할때 컴파일 옵션 중 noImplicitAny를 true 로 설정합니다.</p><figure class="highlight bash hljs"><figcaption><span>tsconfig.json</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="hljs-string">"compilerOptions"</span>: {</span><br><span class="line">    <span class="hljs-string">"noImplicitAny"</span>: <span class="hljs-literal">true</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>noImplicitAny 옵션은 false 가 기본값이므로 noImplicitAny 옵션을 생략한다면 any 타입을 생략해도 괜찮습니다.</p><h2 id="배열-타입과-제네릭-배열-타입"><a href="#배열-타입과-제네릭-배열-타입" class="headerlink" title="배열 타입과 제네릭 배열 타입"></a>배열 타입과 제네릭 배열 타입</h2><p>배열은 여러 개의 값을 하나의 변수에 담아 관리하는 자료구조이다. 여러 값을 모아 담기 때문에 컬렉션(collections) 이라 불리기도 합니다.<br>타입스크립트에서 배열 타입은 두 가지 형태로 나뉩니다.</p><blockquote><ul><li>배열 타입 (array type)</li><li>제네릭 배열 타입 (generic array type)</li></ul></blockquote><h3 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h3><p>배열 타입은 타입스크립트 0.9 버전 부터 지원 됐으며 다음 같이 선언합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> myVar: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];</span><br></pre></td></tr></tbody></table></figure><p>배열 타입은 요소 타입에 []를 붙여 선언합니다. 요소 타입으로는 string, number, boolean 과 같은 내장 타입뿐 아니라 클래스나 인터페이스도 올 수 있습니다.<br>베열 요소의 타입이 정해져 있지 않다면 any 타입으로 지정할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> myVal: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-string">"hi"</span>, <span class="hljs-literal">true</span>]</span><br></pre></td></tr></tbody></table></figure><p>any 타입으로 지정하면 어떤 요소든 배열의 요소로 추가할 수 있습니다. 타입이 느슨하므로 타입을 제약하려면 유니언 타입을 이용해 선언합니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> myVal: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">"hi"</span>, <span class="hljs-literal">true</span>]</span><br></pre></td></tr></tbody></table></figure><h3 id="제네릭-배열"><a href="#제네릭-배열" class="headerlink" title="제네릭 배열"></a>제네릭 배열</h3><p>제네릭 배열 타입은 타입스크립트 0.9 버전부터 지원됐으며 제네릭 배열 타입은 Array<t>형태로 선언합니다. 이때 T 는 타입을 의미합니다.</t></p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num:<span class="hljs-built_in">Array</span><<span class="hljs-built_in">number</span>> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br></pre></td></tr></tbody></table></figure><p>타입을 숫자나 문자열 타입으로 제약하려면 유니언 타입으로 선언</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num:<span class="hljs-built_in">Array</span><<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>> = [<span class="hljs-number">1</span>, <span class="hljs-string">"hello"</span>];</span><br></pre></td></tr></tbody></table></figure><p>제네릭 타입 인수로 사용된 T는 컴파일 시점에 타입을 검사합니다. 타입스크립트에서 선언한 배열,제네릭 배열타입은 컴파일시 타입 검사를 위해 필요하고, 컴파일 후에는 타입이 제거된 배열만 남습니다.</p><h3 id="튜플-타입"><a href="#튜플-타입" class="headerlink" title="튜플 타입"></a>튜플 타입</h3><p>튜플 타입은 n 개의 요소로 이뤄진 배열에 대응하는 타입을 의미합니다. 튜플은 배열과 비슷한데, 배열은 배열 요소의 개수에 제한이 없고 string[]처럼 특정 타입으로 배열 요소의 타입을 강제할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">string</span>[] = [ <span class="hljs-string">"tuple1"</span>,  <span class="hljs-string">"tuple2"</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> x: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [ <span class="hljs-string">"tuple1"</span>,  <span class="hljs-number">100</span>];</span><br></pre></td></tr></tbody></table></figure><p>타입 스크립트2.7 이전에는 배열의 요소가 튜플타입에 선언된 개수를 초과하면 유니언 타입을 적용받았습니다. 그런데 2.7이 되면서 튜플 타입에 따라 할당 배열의 요소 수도 고정됐습니다.</p><h3 id="void-null-undefined"><a href="#void-null-undefined" class="headerlink" title="void, null, undefined"></a>void, null, undefined</h3><p>void는 함수의 반환값이 없을 때 지정하는 타입입니다. void 타입에는 null이나 undefiend만 할당할 수 있습니다.<br>반환값이 없을 때 이를 명시적으로 나타내기 위해 void를 지정합니다.<br>null 이든 undefined 이든 불필요한 선언이 되거나 초기화하지 않았을 때 불안정한 연산을 초래할 수 있으므로 컴파일러 옵션에서 사용하지 못하게 막을 필요가 있습니다.</p><figure class="highlight bash hljs"><figcaption><span>tsconfig.json</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="hljs-string">"compilerOptions"</span>: {</span><br><span class="line">    <span class="hljs-string">"strincNullChecks"</span>: <span class="hljs-literal">true</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>그럼 기본적으로 변수에 할당되번 null 과 undefined는 더 이상 할당되지 못하고 컴파일 오류를 발생시킵니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>타입스크립트 퀵스타트 - 루비페이퍼</p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/18/TypeSctipt-3-var/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript? 타입스크립트 소개 및 개발환경 구축</title>
      <link>https://mishka.kr/2020/03/11/TypeScript-1/</link>
      <guid>https://mishka.kr/2020/03/11/TypeScript-1/</guid>
      <pubDate>Wed, 11 Mar 2020 08:15:00 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;타입스크립트-TypeScript&quot;&gt;&lt;a href=&quot;#타입스크립트-TypeScript&quot; class=&quot;headerlink&quot; title=&quot;타입스크립트(TypeScript)&quot;&gt;&lt;/a&gt;타입스크립트(TypeScript)&lt;/h2&gt;&lt;p&gt;타입스크립트(TypeScript)는 오픈소스 프로그래밍 언어입니다. &lt;strong&gt;마이크로소프트&lt;/strong&gt;가 개발했고 유지 관리하고 있습니다.&lt;br&gt;독자적인 표준을 가지고 있지 않고 &lt;code&gt;ECMA스크립트 표준&lt;/code&gt;을 따르기 때문에 자바스크립트의 특성을 침범하지 않고 최신 ECMA 표준을 지원합니다.&lt;br&gt;그래서 타입스크립트는 &lt;strong&gt;자바스크립트의 상위 집합(superset)언어&lt;/strong&gt;라고 합니다.&lt;br&gt;타입스크립트가 ECMA 스크립트를 따르므로 자바스크립트 문법을 타입스크립트에서 이용 할수 있으며, 최신 ECMA 표준을 지원함으로써 하위 ECMA 표준에 대한 컴파일도 지원합니다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h2 id="타입스크립트-TypeScript"><a href="#타입스크립트-TypeScript" class="headerlink" title="타입스크립트(TypeScript)"></a>타입스크립트(TypeScript)</h2><p>타입스크립트(TypeScript)는 오픈소스 프로그래밍 언어입니다. <strong>마이크로소프트</strong>가 개발했고 유지 관리하고 있습니다.<br>독자적인 표준을 가지고 있지 않고 <code>ECMA스크립트 표준</code>을 따르기 때문에 자바스크립트의 특성을 침범하지 않고 최신 ECMA 표준을 지원합니다.<br>그래서 타입스크립트는 <strong>자바스크립트의 상위 집합(superset)언어</strong>라고 합니다.<br>타입스크립트가 ECMA 스크립트를 따르므로 자바스크립트 문법을 타입스크립트에서 이용 할수 있으며, 최신 ECMA 표준을 지원함으로써 하위 ECMA 표준에 대한 컴파일도 지원합니다.</p><a id="more"></a><h3 id="ECMA-스크립트의-역사"><a href="#ECMA-스크립트의-역사" class="headerlink" title="ECMA 스크립트의 역사"></a>ECMA 스크립트의 역사</h3><p>ECMA는 유럽 컴퓨터 제조사 연합<code>(European Computer Manufacturers Association)</code>의 약자로 스크립트의 표준을 만들고 관리하는 단체입니다.<br>이 단체는 자바스크립트 뿐아니라 C#, 다트(Dart) 같은 언어의 표준과 JSON, XML과 같은 데이터 교환 형식의 표준도 관리하고 있습니다.<br>간단하게 역사를 살펴보면 </p><blockquote><p>ECMA 스크립트 표준은 1997년에 처음 등장한 스크립트 표준이고, 첫번째 판이라는 의미로 ‘Ed.1’이라는 버전 형식을 추가해<br>‘ECMA-262 Ed.1’ 이라고 명명됐습니다. 이를 줄여서 <strong>ES1</strong> 이라고 부릅니다.<br><strong>ES2</strong> 버전은 1998년도에 나왔습니다. 새로운 특징이 추가된 것은 아니고 국제 표준화 국제 전기 전자 표준 위원회의 표준인 ISO/IEC 16262에 부합하도록 재편집 됐습니다.<br><strong>ES3</strong>부터는 ECMA 스크립트가 본격적으로 브라우저 지원을 위한 표준으로 발돋움 했고, 이때 추가된 특징으로 <strong>try/catch</strong> 예외 처리 구문 등이 있습니다.<br><strong>ES4</strong>는 스크립트 버전 중 예외적으로 불완전한 표준이 되어 표준으로 채택되지 못했습니다.<br><strong>ES5</strong>는 2009에 나왔고 브라우저에서 가장 안정적으로 동작하는 표준입니다. 이때 ES5표준을 기반으로 한 <strong>Node.js</strong> 플랫폼도 등장했습니다.<br>이로써 자바스크립트가 서버프로그래밍이 가능한 언어로서 영역을 확장했습니다.<br><strong>ES6</strong>는 2015년에 확정되었고 <strong>모듈 시스템, 화살표함수, 클래스, 개선된 객체 리터널, 템플릿 문자열, 심볼, 프로미스, 제너레이터, for of, 디스트럭처링, 프락시, let, const</strong> 등 많은 특징이 추가됐습니다.<br><strong>ES7</strong>은 2016년에 확정되었고, 비동기 함수를 동기화 할 수 있는 <strong>Async/Await</strong> 에 대한 특징 등이 추가됐습니다.<br><strong>ES8</strong>은 2017년에 확정되었고, 문자열패딩, Object, values 메서드, Object.entries 메서드 등 많은 특징이 추가됐습니다.<br><strong>ES9</strong>은 2018년에 확정되었고, Rest/Spread Properties, for await of, Promise.prototype.finally 메서드 등이 추가되었습니다.</p></blockquote><h2 id="타입스크립트의-특징"><a href="#타입스크립트의-특징" class="headerlink" title="타입스크립트의 특징"></a>타입스크립트의 특징</h2><p>타입스크립트를 자바스스크립트와 비교할때 가장 두드러진 특징은 <strong>‘타입’</strong>입니다. 타입은 꽤 사소해 보이지만 타입스크립트에서 중요한 특징입니다.<br>타입이 있음으로써 개별 변수나 함수에 타입 안정성을 더할 뿐 아니라, 대규모 프로젝트를 구성할 수 있는 밑바탕이 됩니다.</p><p>타입스크립트의 공식 홈페이지에 나와있는 슬로건은 <code>'JavaScript that scales'</code> 입니다.<br>타입스크립트는 대규모 애플리케이션 개발을 위해 다음과 같은 특징을 지원합니다.</p><blockquote><ul><li>모듈 시스템- ES6 모듈과 네임스페이스 지원</li><li>클래스와 인터페이스 지원</li><li>타입시스템 지원</li></ul></blockquote><p>타입스크립트의 모듈 시스템은 크게 <code>ES6 모듈</code>과 <code>네임스페이스</code>로 나뉩니다.<br><code>ES6 모듈</code>은 기존 ES5에서 어려웠던 모듈 분활과 결합 기능을 향상 <code>네임스페이스</code>는 ES6에 없는 타입스크립트에 추가된 특징으로 분리된 이름 공간을 제공해 복잡도를 낮춥니다. 또한 ES6의 클래스뿐 아니라 인터페이스를 추가로 지원해 객체지향 프로그래밍을 더욱 완전하게 지원하고,<br>타입시스템을 기반으로 대규모 애플리케이션을 개발 할 수 있게 합니다.</p><h3 id="모듈-시스템"><a href="#모듈-시스템" class="headerlink" title="모듈 시스템"></a>모듈 시스템</h3><p>ES6에서 제공하는 <code>모듈 선언</code>과 <code>모듈 호출</code> 방식을 지원합니다. <code>export</code> 키워드로 외부 모듈을 선언하거나 <code>import</code> 키워드를 이용해 외부 모듈을 호출 할수 있습니다. 네임스페이스는 라이브러리 단위의 모듈 구성에 유리하며 규모있는 모듈 구성에 필요한 특징입니다.<br>각 네임스페이스에는 인터페이스를 비롯해 클래스나 함수 등의 모듈을 선언할 수 있습니다.</p><h3 id="클래스와-인터페이스-지원"><a href="#클래스와-인터페이스-지원" class="headerlink" title="클래스와 인터페이스 지원"></a>클래스와 인터페이스 지원</h3><p>ES6와 동일한 키워드를 이용해 클래스를 정의 할수 있고, 특히 인터페이스를 지원함으로써(interface, extends) 객체지향 언어의 특징을 더욱 풍부하게 지원합니다.</p><h3 id="타입-시스템-지원"><a href="#타입-시스템-지원" class="headerlink" title="타입 시스템 지원"></a>타입 시스템 지원</h3><p>타입스크립트에는 강력한 <code>타입 시스템(type system)</code>이 있습니다 타입시스템은 자바스크립트의 타입을 확장하고 타입 어노테이션(type annotation)을 이용해 변수에 타입을 선언할 수 있게 합니다.<br>변수에 타입을 선언하는 것을 타입 지정(typing) 이라고 합니다. 타입 지정이 이뤄지면 변수는 엄격한 타이핑(strong typing)이 적용돼 타입 안전성(type safety)을 확보합니다.<br>예를 들어 변수에 string을 타입 어노테이션으로 선언하면 지정한 string 타입 외에 다른 타입의 값을 할당할 수 없습니다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 타입 어노테이션</span></span><br><span class="line">val myVal:<span class="hljs-built_in">string</span></span><br></pre></td></tr></tbody></table></figure><p>타입스크립트에서 변수는 함수의 매개변수 등에 선언한 타입 어노테이션은 컴파일할 때 타입 검사를 위한 목적으로 사용합니다.<br>타입 검사를 통해 타입 안정성이 확보되면 타입스크립트 컴파일러가 타입 어노테이션을 제거하고 최종적으로 자바스크립트 코드를 생성합니다.</p><h4 id="정적타입"><a href="#정적타입" class="headerlink" title="정적타입"></a>정적타입</h4><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">funxtion sum(a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>){</span><br><span class="line">  <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sum(<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>);</span><br><span class="line"><span class="hljs-comment">// error TS2345: Argument of type '"x"' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></tbody></table></figure><p>TypeScript는 정적 타입을 지원하므로 컴파일 단계에서 오류를 포착 할수 있다는 장점이 있다.<br>명시적인 정적 타입 지적은 개발자의 의도를 명확하게 코드로 기술 할 수 있다. 가독성을 높이고 디버깅을 쉽게 한다.</p><h2 id="타입스크립트의-역사"><a href="#타입스크립트의-역사" class="headerlink" title="타입스크립트의 역사"></a>타입스크립트의 역사</h2><p>타입스크립트는 대규모 애플리케이션을 개발하는 데 있어 자바스크립트는 어렵고 불편하다는 고객사의 불만에 대응하기 위한 목적으로 개발됐습니다.<br>메인 개발자는 앤더스 헤일스버그(Anders Hejlsberg)입니다. C# 언어의 설계를 이끌고 있으며, 델파이의 창시자이기도 합니다.<br>C# 를 설계하고 개발을 주도한 아키텍트가 타입스크립트 개발을 이끌면서 타입스크립트에 많은 영향을 끼쳤습니다.</p><h3 id="버전별-특징"><a href="#버전별-특징" class="headerlink" title="버전별 특징"></a>버전별 특징</h3><p>출시 당시에는 많은 관심을 받지 못함, 여러가지 불편사항들이 있었는데 그 중 IDE 지원이 원할하지 못하다는 것에 대응으로 이후 마이크로소프트는 비주얼 스튜디오를 통해 타입스크립트를 지원하게 됐습니다. 이 후 여러가지 개발도구들에서 타입스크립트를 지원하게 됐습니다.</p><blockquote><ul><li>2012년 10월 1일에 첫번째 버전(0.8)이 출시 됐습니다. 이후에 ECMA 스크립트가 발표될 때마다 곧바로 버전이 업데이트 되었습니다.</li><li>타입스크립트 두 번째 버전(0.9)은 2013년 6월 18일에 발표 됐습니다. 0.9 버전의 가장 큰 특징은 <strong>제네릭(generics)</strong> 지원입니다.</li><li>2014년 4월 2일에 타입스크립트 버전1.0 을 발표 2014년 7월에 타입스크립트만을 위한 <strong>새로운 컴파일러</strong>를 발표</li><li>2016년 8월 26일에 타입스크립트 2.0 이 발표 주요 특징은 <strong>Non-Nullable 타입, .d.ts</strong> 파일을 패키지로 가져올 수 있음</li><li>버전 2.1 에서는 <strong>프로미스에 대한 폴리필이나 Async/Await 의 하위표준(ES3, ES5)으로의 컴파일</strong>을 지원</li><li>2.5 에서는 <strong>함수추출, 메서드 리팩토리, 퀵 픽스</strong> 기능 추가</li><li>2.7 에서는 컴파일러의 타입검사 기능 향상 대표적 특징으로는 <strong>엄격한 클래스 초기화(Strict Class Initialization)와 고정 길이 튜플(Fixed Length Tuples)</strong>이 있습니다.</li></ul></blockquote><h2 id="타입스크립트의-아키텍처"><a href="#타입스크립트의-아키텍처" class="headerlink" title="타입스크립트의 아키텍처"></a>타입스크립트의 아키텍처</h2><blockquote><ul><li>에디터</li><li>독립서버</li><li>언어 서비스 / 독립 TS 컴퍼일러</li><li>코어 타입스크립트 컴파일러</li></ul></blockquote><h3 id="컴파일러"><a href="#컴파일러" class="headerlink" title="컴파일러"></a>컴파일러</h3><p>타입스크립트의 아키텍처는 언어 변환 기능을 수행하는 코어 타입스크립트 컴파일러(core typescript compiler)를 기반으로 합니다.<br>코어 타입스크립트 컴파일러는 파서, 바인더, 타입체커, 에미터, 전처리기로 구성돼 있습니다.</p><blockquote><ul><li>파서(parser) : 읽어 들인 소스코드를 해석해 구문 트리를 만들고, 구문 트리를 다시 해석해 추상 구분 트리(AST: Abstract Syntax Tree)를 생성한다.</li><li>바인더(binder) : 인터페이스나 모듈 혹은 함수와 같은 모듈에 선언이 있을 때 이러한 선언을 심벌로 보고 심벌 간의 규칙을 정의한다. 타입 시스템은 바인더를 통해 명명된 선언을 추론 할 수 있게 된다.</li><li>타입 체커(type checker) : 타입이 선언된 구문을 분석하고 타입이 적절한지 체크한다.</li><li>에미터(emitter) : 입력된 *.ts 같은 타입스크립트 파일을 *.js, *.d.ts, *.js.map 유형의 파일로 생성하는 기능을 수행한다.</li><li>전처리기(pre-processor) : 타입스크립트 파일에 선언된 import문이나 “/// <reference = 경로>” 같은 외부 호출 선언이 있을 때 참조 할 수 있는 파일을 가져와 정렬된 파일 목록을 생성한다.</li></ul></blockquote><h3 id="언어-서비스"><a href="#언어-서비스" class="headerlink" title="언어 서비스"></a>언어 서비스</h3><p>언어 서비스는 코드를 컴파일해 도움말이나 코드의 포매팅, 코드 생상 지정 같은 편집기에 필요한 기능을 제공합니다. 언어 서비스는 편집기에서 코드 어시스트를 제공하는 근간입니다.</p><h3 id="독립서버-standalone-server"><a href="#독립서버-standalone-server" class="headerlink" title="독립서버(standalone server)"></a>독립서버(standalone server)</h3><p>독립서버는 컴파일러와 언어 서비스 같은 하위 레이어를 래핑해 JSON 형식을 통해 외부에 정보를 노출할 수 있게 합니다. 독립서버의 다른 이름은 tsserver 입니다.<br>IDE 나 편집기 개발에 필요한 기능을 명령어 형식으로 제공, 서버 형식에 맞게 JSON으로 요청하면 결과를 응답합니다.<br>독립서버는 타입스크립트의 개발 환경이므로 타입스크립트를 이용한 응용 개발에서 직접 다룰 일은 없습니다.</p><h3 id="편집기"><a href="#편집기" class="headerlink" title="편집기"></a>편집기</h3><p>타입스크립트코드에 구문 오류나 타입 오류가 있는지 실시간으로 파악 할 수 있도록 코드 어시스트를 지원합니다.</p><h2 id="개발환경-구축"><a href="#개발환경-구축" class="headerlink" title="개발환경 구축"></a>개발환경 구축</h2><p>타입스크립트는 npm을 통해 설치 할수 있다. npm의 사용을 위해 Node.js 를 설치한다.<br><a href="https://nodejs.org/ko/" rel="external nofollow noopener noreferrer" target="_blank">https://nodejs.org/ko/</a></p><p>Node.js 가 재대로 설치됐다면 npm 명령어를 사용해 타입스크립트를 설치한다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g typescript</span><br></pre></td></tr></tbody></table></figure><p>아래 명령어를 사용하여 타입스크립트 버전을 확인 할수 있다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc -v</span><br></pre></td></tr></tbody></table></figure><h3 id="타입스크립트-컴파일러"><a href="#타입스크립트-컴파일러" class="headerlink" title="타입스크립트 컴파일러"></a>타입스크립트 컴파일러</h3><p>TypeScript 컴파일러(tsc)는 TypeScript 파일(.ts)을 입력받아 ECMA 스크립트(자바스크립트)의 특정 버전으로로 반환합니다.</p><blockquote><p>컴파일링 : 한 언어의 소스코드를 다른 언어로 바꾸는 것<br>트랜스파일링: 한 언어의 소스코드를 비슷한 추상화 수준의 다른 언어로 바꾸는 것 </p></blockquote><p>관점에 따라 타입스크립트는 다른 언어인 자바스크립트로 바꾸므로 컴파일링 한다고 볼수 있지만 비슷한 추상화 수준의 다른 언어로 트랜스파일링 한다고 볼수도 있다. </p><p>간단한 코드를 작성해서 타입스크립트 코드를 자바스크립트 코드로 컴파일하고 이를 실행 해보자.</p><figure class="highlight typescript hljs"><figcaption><span>hello.ts</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> hello: <span class="hljs-built_in">string</span> = <span class="hljs-string">"hello TypeScript"</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(hello);</span><br></pre></td></tr></tbody></table></figure><p>tsc 명령어로 컴파일 할 수 있다. tsc 명령어 뒤에 컴파일 대상 파일명을 작성하다. 이때 확장자 .ts 는 생략이 가능합니다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello</span><br></pre></td></tr></tbody></table></figure><p>변환 결과 hello 변수 타입인 string 이 삭제되고 hello.js 파일이 생성 됩니다.</p><figure class="highlight javascript hljs"><figcaption><span>hello.js</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> hello = <span class="hljs-string">"hello typeScript"</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(hello);</span><br></pre></td></tr></tbody></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>타입스크립트 퀵스타트 - 루비페이퍼<br><a href="https://poiemaweb.com/typescript-introduction" rel="external nofollow noopener noreferrer" target="_blank">TypeScript의 소개와 개발 환경 구축 - Poiemaweb</a></p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/11/TypeScript-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue 에서 Axios를 사용하여 서버통신 해보기</title>
      <link>https://mishka.kr/2020/02/19/axios/</link>
      <guid>https://mishka.kr/2020/02/19/axios/</guid>
      <pubDate>Wed, 19 Feb 2020 10:06:25 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;Axios-란&quot;&gt;&lt;a href=&quot;#Axios-란&quot; class=&quot;headerlink&quot; title=&quot;Axios 란?&quot;&gt;&lt;/a&gt;Axios 란?&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Axios&lt;/code&gt;는 &lt;strong&gt;HTTP 클라이언트 라이브러리&lt;/strong&gt; 중 하나이다.&lt;br&gt;비동기 방식으로 HTTP 데이터 요청을 실행하고 또한 IE8 이상을 포함한 모든 최신 브라우저를 지원한다.&lt;br&gt;&lt;code&gt;Axios&lt;/code&gt;는 &lt;strong&gt;Promise&lt;/strong&gt;를 기반의 자바스크립트 비동기 처리 방식을 사용합니다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h2 id="Axios-란"><a href="#Axios-란" class="headerlink" title="Axios 란?"></a>Axios 란?</h2><p><code>Axios</code>는 <strong>HTTP 클라이언트 라이브러리</strong> 중 하나이다.<br>비동기 방식으로 HTTP 데이터 요청을 실행하고 또한 IE8 이상을 포함한 모든 최신 브라우저를 지원한다.<br><code>Axios</code>는 <strong>Promise</strong>를 기반의 자바스크립트 비동기 처리 방식을 사용합니다.</p><a id="more"></a><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>보통 npm을 통해 설치를 진행합니다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></tbody></table></figure><p>이밖에도 yarn,bower,CDN 을 통해 설치도 가능합니다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// yarn</span><br><span class="line">yarn add axios</span><br><span class="line"></span><br><span class="line">// bower</span><br><span class="line">bower install axios</span><br><span class="line"></span><br><span class="line">// Using unpkg CDN</span><br><span class="line"><script src=<span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span>></script></span><br></pre></td></tr></tbody></table></figure><h2 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h2><p>Axios는 여러가지 <strong>별칭 method</strong>를 제공하고 있습니다.</p><blockquote><p>axios.get(url[, config])<br>axios.post(url[, data[, config]])<br>axios.patch(url[, data[, config]])<br>axios.delete(url[, config])<br>위에 자주 쓰이는 4가지 이외에도 여러가지 를 지원 하고 있다.<br>axios.request(config)<br>axios.head(url[, config])<br>axios.options(url[, config])<br>axios.put(url[, data[, config]])</p></blockquote><p>별칭으로 사용하는 경우에는 url, method 및 data 특성을 구성에 지정할 필요가 없습니다.</p><h2 id="GET-불러오기"><a href="#GET-불러오기" class="headerlink" title="GET (불러오기)"></a>GET (불러오기)</h2><p>GET은 말 그대로 서버에서 데이터를 가져오는데 사용합니다. 많이 사용하는 명령어 중에 하나입니다.<br>서버 주소 <code>/api</code>로 부터 값을 가져올때는 아래와 같이 사용합니다.</p><figure class="highlight javascript hljs"><figcaption><span>GET</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="hljs-string">'/api'</span>)</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(res); </span><br><span class="line">  })</span><br><span class="line">  .catch(err) => {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(err);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><p>axios 요청할 때 메소드의 두번째 인자인 config 객체에 요청값을 같이 넘길 수 있습니다.</p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="hljs-string">'/api'</span>, {</span><br><span class="line">  params: { <span class="hljs-attr">title</span>: <span class="hljs-string">'타이틀'</span> },</span><br><span class="line">  headers: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },</span><br><span class="line">  timeout: <span class="hljs-number">1000</span>  </span><br><span class="line">}).then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(res);</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><h2 id="POST-입력하기"><a href="#POST-입력하기" class="headerlink" title="POST (입력하기)"></a>POST (입력하기)</h2><p>서버에 값을 입력 할 때 사용합니다. 서버의 데이터 리스트의 마지막에 넘기는 정보를 추가합니다.</p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="hljs-string">'/api'</span>, { <span class="hljs-attr">title</span>: <span class="hljs-string">'타이틀'</span> })</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(res);  </span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><h2 id="PATCH-수정하기"><a href="#PATCH-수정하기" class="headerlink" title="PATCH (수정하기)"></a>PATCH (수정하기)</h2><p>서버의 특정 데이터를 수정합니다. </p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.patch(<span class="hljs-string">'/api'</span>, { <span class="hljs-attr">title</span>: <span class="hljs-string">'타이틀변경'</span> })</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(res);  </span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><h2 id="DELETE-삭제하기"><a href="#DELETE-삭제하기" class="headerlink" title="DELETE (삭제하기)"></a>DELETE (삭제하기)</h2><p>서버의 특정 값을 삭제합니다.</p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.delete(<span class="hljs-string">'/api/val'</span>) <span class="hljs-comment">//val = 특정 값</span></span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(res);  </span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><h2 id="Vue-에서-Axios-사용하기"><a href="#Vue-에서-Axios-사용하기" class="headerlink" title="Vue 에서 Axios 사용하기"></a>Vue 에서 Axios 사용하기</h2><p>vue 에서 axios 를 사용하려면 Vue.prototype에 axios를 추가하면 됩니다. main.js에 아래와 같은 내용을 추가한다.</p><figure class="highlight javascript hljs"><figcaption><span>main.js</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span></span><br><span class="line"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span></span><br><span class="line"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'.axios'</span> <span class="hljs-comment">// import axios</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$axios = axios; <span class="hljs-comment">// prototype에 axios 추가</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="hljs-literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">new</span> Vue({</span><br><span class="line">    render: <span class="hljs-function"><span class="hljs-params">h</span> =></span> h(App),</span><br><span class="line">}).$mount(<span class="hljs-string">'#app'</span>)</span><br></pre></td></tr></tbody></table></figure><p>위와 같이 작성하면 Vue 인스턴스 내부에서 axios를 따로 import 하지 않아도 <code>this.$axios</code>를 이용해서 사용 할 수 있다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/axios/axios" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/axios/axios</a><br><a href="https://tuhbm.github.io/2019/03/21/axios/" rel="external nofollow noopener noreferrer" target="_blank">https://tuhbm.github.io/2019/03/21/axios/</a><br><a href="https://ux.stories.pe.kr/138" rel="external nofollow noopener noreferrer" target="_blank">https://ux.stories.pe.kr/138</a><br><a href="https://luji.tistory.com/83" rel="external nofollow noopener noreferrer" target="_blank">https://luji.tistory.com/83</a></p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/02/19/axios/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Github 블로그에 Custom 도메인 연결하기</title>
      <link>https://mishka.kr/2020/01/10/github-domain/</link>
      <guid>https://mishka.kr/2020/01/10/github-domain/</guid>
      <pubDate>Fri, 10 Jan 2020 00:55:52 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;블로그를 운영하다보니 조금씩 욕심이 생기는것 같다 ㅎㅎ &lt;a href=&quot;https://mishka.kr/2019/06/12/hexo-blog/&quot;&gt;Hexo를 이용해 github 블로그&lt;/a&gt;를 만들고 &lt;a href=&quot;https://mishka.kr/2019/06/11/Hexo-seo/&quot;&gt;SEO&lt;/a&gt;를
적용시켜보기도 하고 &lt;a href=&quot;https://mishka.kr/2019/07/02/hexo-comment-disqus/&quot;&gt;댓글 시스템&lt;/a&gt;도 연결하고 &lt;a href=&quot;https://mishka.kr/2019/07/29/hexo-post-setting/&quot;&gt;스타일&lt;/a&gt;도 조금씩 건들여보고 하다보니 결국에 나만의 도메인을 만들어서 연결해 보고 싶었다.  &lt;/p&gt;
&lt;p&gt;그래서 여러가지를 알아보다보니 Github 자체에서 Custom Domain을 간편하게 연결할수 있도록 해주고 있었다.&lt;br&gt;기본적으로 Github를 통해서 정적페이지를 호스팅 하게되면 기본도메인이 주어는데 아래와 같은 형식으로 생성됩니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;USERNAME.github.io&lt;br&gt;그래서 저는 &lt;a href=&quot;mishka86.github.io&quot;&gt;mishka86.github.io&lt;/a&gt; 로 설정되었습니다. &lt;/p&gt;
&lt;/blockquote&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>블로그를 운영하다보니 조금씩 욕심이 생기는것 같다 ㅎㅎ <a href="https://mishka.kr/2019/06/12/hexo-blog/">Hexo를 이용해 github 블로그</a>를 만들고 <a href="https://mishka.kr/2019/06/11/Hexo-seo/">SEO</a>를적용시켜보기도 하고 <a href="https://mishka.kr/2019/07/02/hexo-comment-disqus/">댓글 시스템</a>도 연결하고 <a href="https://mishka.kr/2019/07/29/hexo-post-setting/">스타일</a>도 조금씩 건들여보고 하다보니 결국에 나만의 도메인을 만들어서 연결해 보고 싶었다.  </p><p>그래서 여러가지를 알아보다보니 Github 자체에서 Custom Domain을 간편하게 연결할수 있도록 해주고 있었다.<br>기본적으로 Github를 통해서 정적페이지를 호스팅 하게되면 기본도메인이 주어는데 아래와 같은 형식으로 생성됩니다.</p><blockquote><p>USERNAME.github.io<br>그래서 저는 <a href="mishka86.github.io">mishka86.github.io</a> 로 설정되었습니다. </p></blockquote><a id="more"></a><p>원하는 도메인을 연결하려면 원하시는 도메인 주소를 구입하신 후에 도메인 연결을 하시면 됩니다.<br>저는 <code>mishka.kr</code> 도메인을 <a href="https://www.hosting.kr/" rel="external nofollow noopener noreferrer" target="_blank">hosting.kr</a>을 통해서 구입했습니다.</p><h2 id="DNS-설정-방법"><a href="#DNS-설정-방법" class="headerlink" title="DNS 설정 방법"></a>DNS 설정 방법</h2><p>저는 hosting.kr 설정을 위주로 설명하겠지만 다른 도메인 서비스에서도 비슷한 루트로 변경이 가능 하니 참고하시기 바랍니다.<br>도메인의 네임서버를 변경해 주어야합니다. hosting.kr에서는 부가서비스로 구분이 되어있네요.<br>Home > 도메인 > 부가서비스 > 네임서버 설정 관리 들어가서 github에서 요구 하는데로 변경을 시켜줍니다.</p><table><thead><tr><th align="center">Type</th><th align="center">서브 도메인</th><th align="center">IP주소 / 레코드 값</th></tr></thead><tbody><tr><td align="center">A Record</td><td align="center"></td><td align="center">185.199.108.153</td></tr><tr><td align="center">A Record</td><td align="center"></td><td align="center">185.199.109.153</td></tr><tr><td align="center">A Record</td><td align="center"></td><td align="center">185.199.110.153</td></tr><tr><td align="center">A Record</td><td align="center"></td><td align="center">185.199.111.153</td></tr><tr><td align="center">CName Record</td><td align="center">www</td><td align="center">USERNAME.github.io</td></tr></tbody></table><p>A Record는 Domain을 물리적인 IP 주소로 연결 할 수 있도록 합니다.<br>CName은 물리적인 IP 주소가 아닌 다른 Domain을 연결 합니다.</p><p>A Record의 경우 위에 것에서 하나를 선택해서 입력해 주면됩니다.<br><img src="/img/domain-setting.png" alt="네임서버 설정 관리"><br>저는 A Record와 CName을 위와 같이 세팅 해주었습니다.</p><h2 id="Github-Pages-설정"><a href="#Github-Pages-설정" class="headerlink" title="Github Pages 설정"></a>Github Pages 설정</h2><p>Github에서 블로그가 있는 Repository 로 이동합니다.<br>메뉴에서 Settings > Options 에 <strong>Gihub Pages</strong> 항목에서<br>Costom domain 을 자신이 가지고 있는 도메인 주소로 변경하고 Save 버튼을 눌러줍니다.<br>HTTPS주소를 사용하시려면 하단에 Enfoce HTTPS 항목을 체크해 주시면 됩니다.</p><blockquote><p>2018년 5월 1일 <a href="https://github.blog/2018-05-01-github-pages-custom-domains-https/" rel="external nofollow noopener noreferrer" target="_blank">Github 공식 블로그</a> 에서 정식 지원 소식이 올라왔습니다.</p></blockquote><p><img src="/img/githubpage-setting.png" alt="Github Setting"><br>위와 같이 설정을 하면 이후에 USERNAME.github.io 로 접근되는 요청이 설정하신 도메인으로 Redirect 됩니다.<br>이렇게 설정을 하면 설정하신 도메인으로 <strong>정상적으로 노출</strong>이 됩니다.</p><p>이렇게 진행을 했는데 저는 문제가 한가지 발생했는데요 블로그를 배포하면 Custom domain 설정이 날아가는거였습니다.<br>혹은 CNAME 파일이 정상적으로 생성되지 않은 경우도 발생 할 수도 있다고 하는데요 그럴 경우에 아래와 같은 해결법이 있습니다.</p><p>hexo의 CNAME 생성을 위한 패키지를 설치 합니다.<br> </p><figure class="highlight bash hljs"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-cname --save</span><br></pre></td></tr></tbody></table></figure><p></p><p>그리고 <strong>_config.yml</strong> 파일에서 아래와 같이 플러그인 설정을 해줍니다.</p><figure class="highlight yaml hljs"><figcaption><span>_config.yml</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">plugins:</span> <span class="hljs-string">hexo-generator-cname</span></span><br></pre></td></tr></tbody></table></figure><p>그리고  <strong>_config.yml</strong> 에서 url 이름도 적용한 도메인과 같게 변경해 주세요.</p><figure class="highlight yaml hljs"><figcaption><span>_config.yml</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">url:</span> <span class="hljs-attr">https://mishka.kr</span></span><br></pre></td></tr></tbody></table></figure><p>이렇게 Github 블로그에 Custom Domain을 연결해 주었습니다. 여러분들도 자신만의 도메인을 연결해서 자신만의 블로그에 특징을 더해보세요.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.holaxprogramming.com/2017/05/15/github-page-and-custom-domain/" rel="external nofollow noopener noreferrer" target="_blank">Github Pages에 Custom Domain 적용하기</a><br><a href="https://blog.chulgil.me/how-to-make-blog-using-github-3/" rel="external nofollow noopener noreferrer" target="_blank">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a><br><a href="https://blog.gaerae.com/2018/05/github-pages-custom-domains-https.html" rel="external nofollow noopener noreferrer" target="_blank">Github Pages 개인 도메인도 무료로 HTTPS 지원 시작!</a></p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/01/10/github-domain/#disqus_thread</comments>
    </item>
    
    <item>
      <title>클로저(closure)에 대하여</title>
      <link>https://mishka.kr/2020/01/04/closure/</link>
      <guid>https://mishka.kr/2020/01/04/closure/</guid>
      <pubDate>Sat, 04 Jan 2020 09:07:43 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;클로저의-의미&quot;&gt;&lt;a href=&quot;#클로저의-의미&quot; class=&quot;headerlink&quot; title=&quot;클로저의 의미&quot;&gt;&lt;/a&gt;클로저의 의미&lt;/h1&gt;&lt;p&gt;&lt;code&gt;클로저(closure)&lt;/code&gt;라는 영어단어의 사전적 의미는 ‘닫혀있음’, ‘폐쇄성’, ‘완결성’ 정도의 의미를 가집니다.&lt;br&gt;그렇다면 자바스크립트에서의 클로저는 무슨 의미를 가지고 있을까요? &lt;/p&gt;
&lt;p&gt;클로저(closure)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특징입니다.&lt;br&gt;자바스크립트에서만 사용하는 개념이 아니다 보니 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있습니다.&lt;br&gt;다양한 서적에서 클로저를 정의하고 있는 문장들을 한번 살펴보겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;자신을 내포하는 함수의 컨텍스트에 접근 할 수 있는 함수 - &lt;small&gt;더글라스 크록포드, ‘자바스크립트 핵심 가이드’(한빛 미디어)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의 하는 것 - &lt;small&gt;에단 브라운, ‘러닝 자바스크립트’(한빛 미디어)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출 할 수 있는 함수 - &lt;small&gt;존 레식, ‘자바스크립트 닌자 비급’(인사이트)&lt;/small&gt; &lt;/li&gt;
&lt;li&gt;이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수 - &lt;small&gt;송현주, 고현준, ‘인사이드 자바스크립트’(한빛 미디어)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합 - &lt;small&gt;에릭 프리먼, ‘Head First Javascript Programing’(한빛 미디어)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;로컬 변수를 참조하고 있는 함수 내의 함수 - &lt;small&gt;야마다 요시히로, ‘자바스크립트 마스터 북’(제이펍)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수 - &lt;small&gt;유인동, ‘함수형 자바스크립트 프로그래밍’(인사이트)&lt;/small&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h1 id="클로저의-의미"><a href="#클로저의-의미" class="headerlink" title="클로저의 의미"></a>클로저의 의미</h1><p><code>클로저(closure)</code>라는 영어단어의 사전적 의미는 ‘닫혀있음’, ‘폐쇄성’, ‘완결성’ 정도의 의미를 가집니다.<br>그렇다면 자바스크립트에서의 클로저는 무슨 의미를 가지고 있을까요? </p><p>클로저(closure)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특징입니다.<br>자바스크립트에서만 사용하는 개념이 아니다 보니 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있습니다.<br>다양한 서적에서 클로저를 정의하고 있는 문장들을 한번 살펴보겠습니다.</p><blockquote><ul><li>자신을 내포하는 함수의 컨텍스트에 접근 할 수 있는 함수 - <small>더글라스 크록포드, ‘자바스크립트 핵심 가이드’(한빛 미디어)</small></li><li>함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의 하는 것 - <small>에단 브라운, ‘러닝 자바스크립트’(한빛 미디어)</small></li><li>함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출 할 수 있는 함수 - <small>존 레식, ‘자바스크립트 닌자 비급’(인사이트)</small> </li><li>이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수 - <small>송현주, 고현준, ‘인사이드 자바스크립트’(한빛 미디어)</small></li><li>자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합 - <small>에릭 프리먼, ‘Head First Javascript Programing’(한빛 미디어)</small></li><li>로컬 변수를 참조하고 있는 함수 내의 함수 - <small>야마다 요시히로, ‘자바스크립트 마스터 북’(제이펍)</small></li><li>자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수 - <small>유인동, ‘함수형 자바스크립트 프로그래밍’(인사이트)</small></li></ul></blockquote><a id="more"></a><p>MDN 에서는 클로저에 대해</p><blockquote><p>“A closure is the combination of a function and the lexical environment within which that function was declared.”<br>직역해 보면<br><strong>“클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상”</strong> 정도가 되겠습니다.</p></blockquote><p>A함수 내부에서 B함수를 선언 했을 경우에<br>A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에서 선언한 변수에 접근 가능합니다.<br>내부 함수 B가 A의 lexical enviroment를 언제나 사용하는 것은 아닙니다. 내부함수에서 외부 변수를 <strong>참조하는 경우</strong>에 한해서만 사용 가능합니다.</p><p>간단하게 한번 정리해 보자면 <code>"어떤 함수에서 선언한 변수를 참조하는 내부 함수에서만 발생하는 현상"</code>이라고 볼 수 있겠습니다.</p><figure class="highlight javascript hljs"><figcaption><span>예제 1</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span></span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(++a)</span><br><span class="line">  }</span><br><span class="line">  inner()</span><br><span class="line">}</span><br><span class="line">outer()</span><br><span class="line">outer()</span><br><span class="line">outer()</span><br></pre></td></tr></tbody></table></figure><p><a href="https://codepen.io/mishka86/pen/gObXZpR" rel="external nofollow noopener noreferrer" target="_blank">코드펜 링크</a></p><p>실행순서를 살펴보면 outer 함수에서 변수 a를 선언했고, outer의 내부함수인 inner 함수에서 a의 값을 1만큼 증가시킨 다음 출력합니다.<br>inner 함수에서는 a를 선언하지 않았기 때문에 스코프체인을 타고 outer 함수에 접근해서 a를 찾습니다.<br>그리고 4번째 줄에서 2가 출력됩니다. outer 함수가 종료되면 저장된 식별자들(a, inner)에 대한 참조를 지웁니다.<br>그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 <code>가비지 컬렉터의 수집 대상</code>이 됩니다.<br>그래서 2를 3번 출력하게 됩니다.`</p><figure class="highlight javascript hljs"><figcaption><span>예제 2</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span></span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">return</span> ++a</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> inner</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">var</span> outerFunc = outer()</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br></pre></td></tr></tbody></table></figure><p><a href="https://codepen.io/mishka86/pen/WNbXLry" rel="external nofollow noopener noreferrer" target="_blank">코드펜 링크</a></p><p>위 예제를 살펴보면 inner함수의 실행 시점에는 outer함수는 이미 실행이 종료된 상태인데 왜 outer함수의 Lexical environment에<br>접근할 수 있는 걸까요? 이는 <code>가비지 컬렉터의 동작 방식</code> 때문입니다.<br>가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다.<br>그래서 예제를 보면 outer 함수는 실행 종료 시점에 inner 함수를 반환합니다.<br>외부 함수인 outer 의 실행이 종료되더라도 내부 함수인 inner 함수는 언젠가 outerFunc를 실행함으로써 호출될 가능성이 열린 겁니다.<br>언젠가 inner 함수의 실행 컨텍스트가 활성화되면 outer함수 a 의 값을 필요로 할것이므로 수집대상에서 제외됩니다.</p><p>예제1과 2의 다른점은 변수가 가비지 컬렉터에 포함 되었느냐 제외 되었느냐 입니다.<br>함수의 실행 컨텍스트가 종료돈 후에도 lexical environment가 가비지 컬렉터의 수집대상에서 제외되는 경우는 지역변수를 참조하는 내부 함수가 외부로 전달된 경우가 유일합니다.<br>위 현상을 토대로 클로저의 정의를 다시 고쳐보자면 “어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상”이라고 할 수 있습니다.</p><p>외부로 전달하는 방법으로는 return 외에도 Window의 메서드(setTimeout 또는 setInterval), DOM의 메서드(addEventListener) 같은 경우도<br>지역변수를 참조하는 내부함수를 외부로 전달 했기 때문에 클로저라고 할 수 있습니다.</p><h1 id="클로저의-메모리-관리"><a href="#클로저의-메모리-관리" class="headerlink" title="클로저의 메모리 관리"></a>클로저의 메모리 관리</h1><p>클로저의 메모리 소모는 본질적인 특정일 뿐입니다. ‘메모리 누수’라는 표현은 개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC(Garbage Collector)의 수거 대상이 되지 않는 경우에는 맞는 표현이지만 개발자가 의도적으로 참조 카운트를 0이되지 않게 설계한 경우는 ‘누수’라고 할 수는 없습니다.<br>클로저의 메모리 관리 방법은 간단합니다.<br>클로저는 어떤 필요의 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다. 그러면 필요성이 사라진 시점에 메모리를 소모하지 않도록 해주면 됩니다. 참조 카운트를 0으로 만들면 GC가 수거 해가고 이때 소모됐던 메모리가 회수 됩니다.<br>참조 카운트를 0으로 만드는 방법은 식별자의 참조형이 아닌 기본형 데이터(null 이나 undefined)를 할당하면 됩니다.</p><figure class="highlight javascript hljs"><figcaption><span>예제 3 메모리 관리</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span></span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">return</span> ++a</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> inner</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">var</span> outerFunc = outer()</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line">outer = <span class="hljs-literal">null</span>  <span class="hljs-comment">// outer 식별자의 inner 함수 참조를 끊음</span></span><br></pre></td></tr></tbody></table></figure><h1 id="클로저-활용-사례"><a href="#클로저-활용-사례" class="headerlink" title="클로저 활용 사례"></a>클로저 활용 사례</h1><h2 id="콜백-함수와-클로저"><a href="#콜백-함수와-클로저" class="headerlink" title="콜백 함수와 클로저"></a>콜백 함수와 클로저</h2><p>콜백 함수 내부에서 외부변수를 참조하기 위한 방법으로 세가지가 있습니다.</p><ul><li>콜백 함수를 내부 함수로 선언해서 외부 변수를 직접 참조하는 방법으로 클로저를 사용하는 방법</li><li>bind 메서드로 값을 직접 넘겨줘서 클로저를 발생 시키지 않는 대신 여러가지 제약이 있는 방법</li><li>콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용한 방법</li></ul><h2 id="접근-권한-제어-정보은닉"><a href="#접근-권한-제어-정보은닉" class="headerlink" title="접근 권한 제어(정보은닉)"></a>접근 권한 제어(정보은닉)</h2><p>정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나 입니다.<br>흔히 접근 권한에는 public, private, protected 의 세 종류가 있습니다.</p><ul><li>public은 외부에서 접근 가능한 것</li><li>private은 내부에서만 사용하며 외부에 노출되지 않는 것</li><li>protected는 상속받은 클래스 또는 같은 패키지에서만 접근이 가능한 것(java)</li></ul><p>자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직업 부여하도록 설계되어 있지 않습니다.<br>그렇다고 접근 제한이 불가능 한 것을 아닙니다. 클로저를 활용해서 함수차원에서 public한 값과 private 한 값을 구분하는 것이 가능합니다.</p><figure class="highlight javascript hljs"><figcaption><span>정보은닉</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> </span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">return</span> ++a</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> inner</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">var</span> outerFunc = outer()</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br></pre></td></tr></tbody></table></figure><p>outer 함수를 종료할 때 inner 함수를 반환함으로써 outer 함수의 지역변수인 a의 값을 외부에서도 읽을 수 있게 됐습니다.<br>외부에서는 outer라는 변수를 통해 outer함수를 실행 할 수는 있지만 outer함수 내부에는 어떤한 개입도 할 수 없습니다.<br>외부에서는 오직 outer함수가 return한 정보에만 접근 할수 있습니다.<br>그러니까 외부에 제공하고자 하는 정보들을 모아서 return하고, 내부에서만 사용 할 정보들은 return 하지 않는 것으로 접근 권한 제어가 가능한것입니다.<br>return한 변수들은 공개맴버(public member)가 되고, 그렇지 않는 변수들은 비공개 멤버(private member)가 되는 것입니다.</p><h2 id="부분-적용-함수-partially-applied-function"><a href="#부분-적용-함수-partially-applied-function" class="headerlink" title="부분 적용 함수 (partially applied function)"></a>부분 적용 함수 (partially applied function)</h2><p>부분 적용 함수란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가,<br>나중에 (n-m) 개의 인자를 넘기면 비로소 원래 함수의 실행 결과를 얻을 수 있게끔 하는 함수 입니다.</p><h2 id="커링-함수-currying-function"><a href="#커링-함수-currying-function" class="headerlink" title="커링 함수 (currying function)"></a>커링 함수 (currying function)</h2><p>커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말합니다.<br>부분 적용 함수와 다른 점은 커링은 한 번에 하나의 인자만 전달하는 것을 원칙으로 합니다.<br>또한 중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 할 뿐으로, 마지막 인자가 전달되기 전 까지는 원본 함수가 실행되지 않습니다<br>(부분 적용 함수는 여러 개의 인자를 전달할 수 있고, 실행 결과를 재실행할때 원본 함수가 무조건 실행됩니다).</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>코어 자바스크립트 (위키북스)</li></ul></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/01/04/closure/#disqus_thread</comments>
    </item>
    
    <item>
      <title>실행 컨텍스트(execution context)</title>
      <link>https://mishka.kr/2020/01/02/execution_context/</link>
      <guid>https://mishka.kr/2020/01/02/execution_context/</guid>
      <pubDate>Thu, 02 Jan 2020 08:40:32 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;실행 컨텍스트(execution context)는 쉽게 보면 코드가 실행되고 있는 구역,범위에 대한 개념정도로 볼 수 있다.&lt;br&gt;실행 컨텍스트는 실행할 코드에 제공할 환경정보들을 모아놓은 객체이다.&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/%EC%96%B8%EC%96%B4_%EB%A6%AC%EC%86%8C%EC%8A%A4&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;ECMAScript&lt;/a&gt; 스펙에서는 실행 컨텍스트를 ‘실행 가능한 코드를 형상화하고 구분하는 추상적인 개념’이라고 정의 한다.&lt;/p&gt;
&lt;p&gt;자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러가지 정보들을 알고 있어야 한다고 한다. 실행에 필요한 정보들은 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티&lt;/li&gt;
&lt;li&gt;함수 선언&lt;/li&gt;
&lt;li&gt;변수의 유효범위(Scope)&lt;/li&gt;
&lt;li&gt;this&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>실행 컨텍스트(execution context)는 쉽게 보면 코드가 실행되고 있는 구역,범위에 대한 개념정도로 볼 수 있다.<br>실행 컨텍스트는 실행할 코드에 제공할 환경정보들을 모아놓은 객체이다.<br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/%EC%96%B8%EC%96%B4_%EB%A6%AC%EC%86%8C%EC%8A%A4" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript</a> 스펙에서는 실행 컨텍스트를 ‘실행 가능한 코드를 형상화하고 구분하는 추상적인 개념’이라고 정의 한다.</p><p>자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러가지 정보들을 알고 있어야 한다고 한다. 실행에 필요한 정보들은 아래와 같다.</p><blockquote><ul><li>변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티</li><li>함수 선언</li><li>변수의 유효범위(Scope)</li><li>this</li></ul></blockquote><a id="more"></a><p>코드를 실행하면 ‘전역 컨텍스트(Global execution Context)’가 생깁니다. 전역 컨텍스트는 브라우저가 종료 될 때까지 유지됩니다.<br>특정 ‘함수’안에서 실행되는 코드가 아니라면 코드는 전역 컨텍스트에서 실행됩니다.</p><p>함수가 호출 될때 해당 함수에 대한 실행 컨텍스트가 생성된다.(Functional Execution Context) 함수들은 각각 자신만의 실행 컨텍스트를 가지지만<br>이를 함수가 호출 되어야 만들어 집니다.</p><p>예제로 한번 보겠습니다.</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// (1)</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// undefined</span></span><br><span class="line">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// 3</span></span><br><span class="line">  }    </span><br><span class="line">  inner()  <span class="hljs-comment">// (2)</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// 1  </span></span><br><span class="line">}</span><br><span class="line">outer()  <span class="hljs-comment">//  (3)</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>위의 코드의 실행 순서를 따라가 보면 </p><ul><li>처음에 자바스크립트 코드를 실행하면(1) 전역 컨텍스트가 콜 스텍에 담깁니다.</li><li>순차적으로 코드를 읽다가 (3)에서 outer 함수를 호출하면 </li><li>outer함수에 대한 실행 컨텍스트를 생성한 후 콜 스텍에 담습니다. </li><li>콜 스텍에 새로운 컨텍스트가 놓인상태가 됐으므로 전역 컨텍스트와 관련된 코드 실행을 일시 중단하고 outer 함수에 대한 실행 컨텍스트를 실행합니다.</li><li>outer 함수 내부의 코드들을 순차로 실행합니다.</li><li>(2)에서 inner 함수가 호출되서 inner함수의 실행 컨켄스트가 콜 스택의 가장 위에 담기면</li><li>outer 컨텍스트와 관련되 코드의 실행을 중단하고</li><li>inner함수 내부의 코드를 순서대로 진행합니다.</li><li>inner함수 내부의 값을 출력하고 나면 inner함수의 실행이 종료되면서 inner  실행 컨텍스트가 콜 스택에서 제거됩니다.</li><li>inner컨텍스트의 의해 중단되었던 outer (2)줄 다음부터 실행됩니다.</li><li>a 변수 값을 출력하고 outer함수의 실행이 종료되며 outer실행 컨텍스트가 종료되며 콜 스택에서 제거됩니다.</li><li>중단되었던 전역 컨텍스트 (3)의 다음 줄부터 실행됩니다.</li><li>a 변수의 값이 출력되고 전역 컨텍스트도 콜 스택에서 제거 됩니다.</li></ul><p>스택구조를 잘 살펴보면 한 실행 컨텍스트가 콜 스택의 맨위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점임을 알 수 있습니다.<br>기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치 할 수 밖에 없기 때문입니다. 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장합니다.</p><h2 id="실행-컨텍스트의-3가지-객체"><a href="#실행-컨텍스트의-3가지-객체" class="headerlink" title="실행 컨텍스트의 3가지 객체"></a>실행 컨텍스트의 3가지 객체</h2><p>실행 컨텍스트 자체는 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 가지며 3가지 프로퍼티를 가진다.</p><h3 id="Variavle-Object-VO-변수객체"><a href="#Variavle-Object-VO-변수객체" class="headerlink" title="Variavle Object (VO / 변수객체)"></a>Variavle Object (VO / 변수객체)</h3><p>변수, 매개변수, 인수정보, 함수 선언의 정보를 담고있는 객체<br>컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 정보를 수집<br>전역 실행 컨텍스트와 함수 실행 컨텍스트 일때 내용이 다르다<br>전역 컨텍스트의 경우 - 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Gloval Object / GO)<br>함수 컨텍스트의 경우 - Acrivation Object(AO / 활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고있는<br>arguments object가 추가됨</p><h3 id="호이스팅"><a href="#호이스팅" class="headerlink" title="호이스팅"></a>호이스팅</h3><p>변수를 선언하고 초기화 했을때 선언 부분이 코드의 최상단으로 끌어올려지는 현상.<br>선언부만 올라가므로 최기화 또는 대입 부분은 그대로 남아있음<br>함수 선언식의 경우에는 함수 전체가 통째로 끌어올려짐</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params">x</span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">  <span class="hljs-keyword">var</span> x;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">  <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">}</span><br><span class="line">a(<span class="hljs-number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>위의 코드를 호이스팅 개념처럼 변경하면</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> x;</span><br><span class="line">  <span class="hljs-keyword">var</span> x;</span><br><span class="line">  <span class="hljs-keyword">var</span> x;</span><br><span class="line">  </span><br><span class="line">  x = <span class="hljs-number">1</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">  x = <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">}</span><br><span class="line">a()</span><br></pre></td></tr></tbody></table></figure><p>인자들과 함께 함수를 호출한 경우의 동작은 전달된 인자를 arguments object에 담는 것을 제외하면 코드내부에서 변수를 선언한 것과 다르지 않아서 함수 내부의 코드 최상단에서 선언 및 할당이 이뤄진것으로 간주하여 적용 </p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">  <span class="hljs-keyword">var</span> b = <span class="hljs-string">'bbb'</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span> (<span class="hljs-params"></span>) </span>{};</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">}</span><br><span class="line">a();</span><br></pre></td></tr></tbody></table></figure><p>위의 코드를 호이스팅 개념처럼 변경하면</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> b;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span> (<span class="hljs-params"></span>) </span>{};</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">  b = <span class="hljs-string">'bbb'</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">}</span><br><span class="line">a();</span><br></pre></td></tr></tbody></table></figure><p>함수 선언식의 경우는 식이 통째로 끌어올려지는것에 주의합니다.</p><h3 id="Scope-Chain-SC"><a href="#Scope-Chain-SC" class="headerlink" title="Scope Chain(SC)"></a>Scope Chain(SC)</h3><p>스코프 체인은 일종의 리스트, 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장<br>해당 전역 또는 함수가 참조 할 수 있는 변수, 함수 선언 등의 정보를 담고있는 전역 객체 또는 활성 객체의 리스트<br>현재 실행 컨텍스트의 활성 객체로 시작해서 순차적으로 상위 컨텍스트의 활성 객체를 가리키며 마지막에는 전역 객체를 가리킴<br>스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하며 스코프 체인은 식별자 중에서 변수를 검색하는 메커니즘</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;</span><br><span class="line">  };</span><br><span class="line">  inner();</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">};</span><br><span class="line">outer();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(a);</span><br></pre></td></tr></tbody></table></figure><h3 id="this-value"><a href="#this-value" class="headerlink" title="this value"></a>this value</h3><p>this 프로퍼티에는  this 값이 할당 됨<br>this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li>코어 자바스크립트 - 위키북스</li><li><a href="https://poiemaweb.com/js-execution-context" rel="external nofollow noopener noreferrer" target="_blank">실행 컨텍스트와 자바스크립트의 동작 원리</a></li><li><a href="https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy" rel="external nofollow noopener noreferrer" target="_blank">[JS] 자바스크립트의 The Execution Context (실행 컨텍스트) 와 Hoisting (호이스팅)</a></li><li><a href="https://velog.io/@stampid/Execution-Context%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80" rel="external nofollow noopener noreferrer" target="_blank">Execution Context(실행 컨텍스트)란?</a></li><li><a href="https://reinvint.tistory.com/6" rel="external nofollow noopener noreferrer" target="_blank">실행 컨텍스트(Execution Context)</a></li></ul></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/01/02/execution_context/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1. 프로그레시브 프레임워크 Vue.js - part 2</title>
      <link>https://mishka.kr/2019/11/08/Vue-study-1.1/</link>
      <guid>https://mishka.kr/2019/11/08/Vue-study-1.1/</guid>
      <pubDate>Fri, 08 Nov 2019 09:11:05 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;Vue-js-의-특징&quot;&gt;&lt;a href=&quot;#Vue-js-의-특징&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 의 특징&quot;&gt;&lt;/a&gt;Vue.js 의 특징&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Vue.js&lt;/code&gt;는 그 자체로는 뷰만을 다루는 단순한 라이브러리다. Vue.js 본체 뿐만 아니라 관련 라이브러리도 Vue.js 공식 프로젝트의 일부로서 개발 및 관리 된다. 이 때문에 몇가지 라이브러리를 조합하면 마치 종합적인 &lt;strong&gt;프레임워크&lt;/strong&gt;처럼 사용 할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;낮은-학습-비용&quot;&gt;&lt;a href=&quot;#낮은-학습-비용&quot; class=&quot;headerlink&quot; title=&quot;낮은 학습 비용&quot;&gt;&lt;/a&gt;낮은 학습 비용&lt;/h3&gt;&lt;p&gt;Vue.js 가 제공하는 API는 매운 단순하다. UI를 구성하는 데는 HTML을 기반으로 하는 평범한 템플릿을 사용한다. HTML이나 자바스크립트에 이미 익숙하면 Vue.js 에 대해 특별히 더 배우지 않고서도 라이브러리를 사용할 수 있다. 기본적인 사용만 한다면 빌드 도구나 패키징, EC2015 이후 문법에 대한 지식이 없어도 바로 동작하는 코드를 작성할 수 있다. Vue.js 는 앞서 언급한 모던 웹 프런트 엔드 개발의 어려움을 잘 극복했다. HTML5 이후 고도화된 개발 스타일에 부응하면서도 개발 환경 구축이 쉬워서 개발을 바로 시작할 수 있으며 자바스크립트에 대한 사전지식과 라이브러리 고유의 문법을 학습하지 않아도 라이브러리를 사용할 수 있다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><h2 id="Vue-js-의-특징"><a href="#Vue-js-의-특징" class="headerlink" title="Vue.js 의 특징"></a>Vue.js 의 특징</h2><p><code>Vue.js</code>는 그 자체로는 뷰만을 다루는 단순한 라이브러리다. Vue.js 본체 뿐만 아니라 관련 라이브러리도 Vue.js 공식 프로젝트의 일부로서 개발 및 관리 된다. 이 때문에 몇가지 라이브러리를 조합하면 마치 종합적인 <strong>프레임워크</strong>처럼 사용 할 수 있다.</p><h3 id="낮은-학습-비용"><a href="#낮은-학습-비용" class="headerlink" title="낮은 학습 비용"></a>낮은 학습 비용</h3><p>Vue.js 가 제공하는 API는 매운 단순하다. UI를 구성하는 데는 HTML을 기반으로 하는 평범한 템플릿을 사용한다. HTML이나 자바스크립트에 이미 익숙하면 Vue.js 에 대해 특별히 더 배우지 않고서도 라이브러리를 사용할 수 있다. 기본적인 사용만 한다면 빌드 도구나 패키징, EC2015 이후 문법에 대한 지식이 없어도 바로 동작하는 코드를 작성할 수 있다. Vue.js 는 앞서 언급한 모던 웹 프런트 엔드 개발의 어려움을 잘 극복했다. HTML5 이후 고도화된 개발 스타일에 부응하면서도 개발 환경 구축이 쉬워서 개발을 바로 시작할 수 있으며 자바스크립트에 대한 사전지식과 라이브러리 고유의 문법을 학습하지 않아도 라이브러리를 사용할 수 있다.</p><a id="more"></a><h3 id="컴포넌트-지향을-통한-UI-구조화"><a href="#컴포넌트-지향을-통한-UI-구조화" class="headerlink" title="컴포넌트 지향을 통한 UI 구조화"></a>컴포넌트 지향을 통한 UI 구조화</h3><p>Vue.js 는 구조화해 <code>컴포넌트로 재사용</code>할 수 있다. UI 구성 요소를 컴포넌트로 만들면 시스템 전체를 컴포넌트의 집합 형태로 개발 할 수 있다. 개발에 컴포넌트를 적용하면 컴포넌트 분리에서 오는 유지보수성 개선 및 컴포넌트 재사용 등 여러 장점이 있다.</p><h3 id="리액티브-데이터-바인딩"><a href="#리액티브-데이터-바인딩" class="headerlink" title="리액티브 데이터 바인딩"></a>리액티브 데이터 바인딩</h3><p>Vue.js 는 DOM요소와 <strong>리액티브 데이터 바인딩</strong>을 통해 자바스크립트 데이터를 연결해 준다. <code>리액티브 데이터 바인딩</code>이란 HTML 템플릿 안에서 대상 DOM 요소에 바인딩 을 지정해 Vue.js 가 해당 데이터의 변화를 감지할 때마다 바인딩된 DOM 요소에 표시되는 내용도 함께 업데이트하는 것을 말한다. 값은 자바스크립트에서 DOM요소로 일방적으로 전달된다. 이것을 <strong>단방향 바인딩</strong>이라고 한다. 자바스크립트쪽에서 위치한 데이터 값이 변경되면 변경된 값이 웹 페이지에도 자동으로 반영되는 기능이다. input 요소등 사용자의 입력을 받는 DOM요소는 요소에서 받아온 데이터와 자바스크립트 데이터를 서로동기화하는 바인딩을 지정한다. 이런 경우 자바스크립트의 데이터 값이 변경될때마다 DOM요소의 표시 내용이 수정되며, 사용자의 입력이 감지될때마다 자바스크립트 데이터가 수정된다. 이런 방법으로 자바스크립트 데이터와 DOM요소 데이터의 동기화 상태를 유지한다. 이 방법은 자바스크립트와 DOM요소가 서로 최신 데이터를 주고받으므로 양방향 바인딩이라고 한다. 바인딩을 이용함으로써 귀찮은 표시 내용 업데이트 처리와 DOM 요소와 자바스크립트 간 데이터 동기화 상태 유지로부터 해당됐으며 데이터 중심 웹 애플리케이션 설계 및 구현이 가능해졌다.</p><h2 id="Vue-js의-설계사상"><a href="#Vue-js의-설계사상" class="headerlink" title="Vue.js의 설계사상"></a>Vue.js의 설계사상</h2><p>Vue.js는 사용성 면에서도 뛰어난 라이브러리지만, 성능적인 측면을 비롯해 다른 장점도 많은 라이브러리다. 그러나 이와 비슷한 장점이 많은 라이브러리도 있다. Vue.js 가 이런 다른 라이브러리와 분명이 차별화 되는 점이 있다. 바로 밑바탕이 되는 설계사상이다. Vue.js의 설계 밑 바탕에는 <code>프로그래시브 프레임워크(Progressive framework)</code> 라는 아이디어가 깔려있다.<br>‘프레임워크는 어떤 경우든지 규모와 상관없이 단계적으로 유연하게 사용할 수 있어야 한다.’ 라고 Vue.js를 만든 에반유가 처음 주창했다.</p><h3 id="프레임워크의-복잡성"><a href="#프레임워크의-복잡성" class="headerlink" title="프레임워크의 복잡성"></a>프레임워크의 복잡성</h3><p>웹 프런트 엔트 분야에는 React와 Angular 등 라이브러리와 프레임워크가 여러 가지 있다. 프레임워크는 애플리케이션 개발의 복잡성을 해소해주는 도구다. 그러나 애플리케이션과 마찬가지로 프레임워크에도 프레임워크 자체의 복잡성이 있다. 프레임워크라는 도구를 사용하려면 도구 자체의 복잡성에서 오는 비용과 애플리케이션 개발의 복잡성에서 오는 비용이 균형을 이루도록 적합한 프레임워크를 선택하는 것이 중요하다.</p><h3 id="요구-사항의-변화를-수용할수-있는-프레임워크"><a href="#요구-사항의-변화를-수용할수-있는-프레임워크" class="headerlink" title="요구 사항의 변화를 수용할수 있는 프레임워크"></a>요구 사항의 변화를 수용할수 있는 프레임워크</h3><p>사이트 및 애플리케이션의 요구사항은 끊임없이 변화한다. 프레임워크도 이렇게 변화하는 요구사항에 맞춰 가치를 제공하려면 그만큼 유연하지 않으면 안 된다. 애플리케이션이 최초 완성되고 나면 변화하는 요구사항에 대응하기 위해 애플리케이션의 규모가 지족해서 커지게 마련이다. 대부분 애플리케이션 개발을 지원하는 라이브러리나 도구를 추가로 도입해 새로운 비즈니스 요구사항을 만족시키게 된다. 그러나 이렇게 새로운 요소를 덧붙이는 방법은 생각대로 되지 않는 경우가 많다. 웹 프런트엔드 생태계는 최근 끊임없이 변화하고 있기 때문에 애플리케이션에 도입한 프레임워크나 개발 환경이 얼마 지나지 않아 시대에 뒤떨어지게 되고 다시 어떤 프레임워크로 갈아타야 하는지조차 알 수 없는 상황에 직면하게 된다. 이런 상황에 대처하려면 요구 사항 변과에 단계적으로 대응해야 한다. 이러한 아이디어를 반영한 것이 바로 프로그래시브 프레임워크다. 프로그래시브 프레임워크는 무제를 해결할 수 있는 적합한 라이브러리를 적시에 도입해 문제를 해결한다. Vue.js는 <strong>뷰 계층에 초점을 맞춘 라이브러리</strong>다. Vue.js 프로젝트가 제공하는 부가적인 라이브러리와 개발환경 도구를 사용하면 프로그래시브 프레임워크가 된다.</p><h2 id="프로그레시브-프레임워크가-제공하는-단계적-영역"><a href="#프로그레시브-프레임워크가-제공하는-단계적-영역" class="headerlink" title="프로그레시브 프레임워크가 제공하는 단계적 영역"></a>프로그레시브 프레임워크가 제공하는 단계적 영역</h2><h3 id="선언적-렌더링"><a href="#선언적-렌더링" class="headerlink" title="선언적 렌더링"></a>선언적 렌더링</h3><p>이 영역은 선언적 DOM 렌더링과 관련된 영역이다. HTML 템플릿에 렌더링 대상을 선언적으로 기술해 데이터가 변경될 때마다 DOM을 반응적으로 렌더링하고 사용자 입력 데이터를 동기화 할 수 있다,<br>Vue.js 본체가 제공하는 기능이다.</p><h3 id="컴포넌트-시스템"><a href="#컴포넌트-시스템" class="headerlink" title="컴포넌트 시스템"></a>컴포넌트 시스템</h3><p>UI를 모듈화해 재사용할수 있게 해주는 영역, 이 영역 역시 UI 를 컴포넌트로 만들어주는 Vue.js 본체가 제공하는 기능이다.</p><h3 id="클라이언트-사이드-라우팅"><a href="#클라이언트-사이드-라우팅" class="headerlink" title="클라이언트 사이드 라우팅"></a>클라이언트 사이드 라우팅</h3><p>단일 페이지 애플리케이션이 동작하기 위해 필요한 영역이다. 라우팅이란 간단히 말해 애플리케이션의 URL 설계, 지시와 같은 것이다. Vue.js의 공식 라우팅 라이브러리인 Vue Router를 사용하면 기존에 개발한 컴포넌트로 당일 페이지 애플리케이션을 만들 수 있다.</p><h3 id="대규모-상태관리"><a href="#대규모-상태관리" class="headerlink" title="대규모 상태관리"></a>대규모 상태관리</h3><p>컴포넌트 간에 상태를 고유하는 방법을 필요로 하는 영역이다. Vue.js의 공식 데이터플로 아키텍처를 따라 만든 상태관리 라이브러리인 VUEX 를 사용하면 이 영역의 문제를 해결할 수 있다, 기존 컴포넌트를 확장하는 형태로 상태를 중앙에서 관리 할 수 있다.</p><h3 id="빌드시스템"><a href="#빌드시스템" class="headerlink" title="빌드시스템"></a>빌드시스템</h3><p>웹 애플리케이션을 구성하는 컴포넌트 관리, 운영환경배포, 프로젝트 구성등과 관련된 영역이다. Vue.js의 공식 개발지원 도구를 이용해 이 영역의 문제를 해결할 수 있다, 프로젝트의 환경구축, 구성관리에 수고를 들이는 대신 개발에 집중할 수 있다. (Vue Cli)</p><h3 id="클라이언트-서버데이터-퍼시스턴스"><a href="#클라이언트-서버데이터-퍼시스턴스" class="headerlink" title="클라이언트-서버데이터 퍼시스턴스"></a>클라이언트-서버데이터 퍼시스턴스</h3><p>웹애프리케이션의 복잡한 데이터는 클라이언트 사이드와 서버사이트 양쪽 모두에서 퍼시스턴스 데이터로 유지돼야 한다. 이 책을 쓰는 시점에는 이러한 분야의 문제를 해결해 주는 Vue.js공식 라이브러리가 아직 없으며 서드파티 라이브러리 사용자들이 직접 작성한 라이브러리를 사용해 구현한다.</p><h2 id="Vue-js의-기반-기술"><a href="#Vue-js의-기반-기술" class="headerlink" title="Vue.js의 기반 기술"></a>Vue.js의 기반 기술</h2><h3 id="컴포넌트-시스템-1"><a href="#컴포넌트-시스템-1" class="headerlink" title="컴포넌트 시스템"></a>컴포넌트 시스템</h3><p>Vue.js는 컴포넌트를 쉽게 다루기 위한 라이브러리다. 컴포넌트 시스템에서 특기할 만한 기능은 단일 파일 컴포넌트다. Vue.js는 단일 파일에 HTML과 유사한 방식으로 컴포넌트를 작성할 수 있다. 이 파일은 .vue라는 독자적인 확장자를 사용한다. Vue.js 컴포넌트는 기존 웹 표준을 구성하는 기술과 유사한 형태로 정의되기 때문에 학습비용이 매우 낮은것이 특정이다. 파일하나에 컴포넌트의 모든 요소를 함께 담을 수 있다는 점은 큰 장점이다. 컴포넌트의 요점은 언어의 역할과는 별도로 기능이나 관심사를 기준으로 코드를 분리하는 것이기 때문이다. 하나의 관심사만을 같은 GUI 컴포넌트를 분리하려고 할때 HTML/CSS/JavaScript 3가지 요소를 하나의 파일로 합쳐 컴포넌트로 분리 할 수 있으므로 이해하기 쉽다.</p><h3 id="리액티브-시스템"><a href="#리액티브-시스템" class="headerlink" title="리액티브 시스템"></a>리액티브 시스템</h3><p>Vue.js의 리액티브 시스템은 옵저버 패턴을 기반으로 구현 좀더 쉽게 셜명하면 상태의 변화를 Vue.js가 감지해 자동으로 그 변화를 DOM에 반영하는 구조라고 할 수 있다. DOM 을 더욱 정교하고 잦은 비도로 조작해야 하는 애플리케이션에서는 데이터 바인딩이 매우 유용하다. 라이브러리에 이러한 기능이 없다면 값의 변화에 따라 변화해야 하는 곳을 직접 변경하거나 갑의 변경에 따른 사이드 이펙트를 완전히 파악하지 못하고 임시변통으로 틀어막게 되기 쉽다. 뒤에 설명할 계산 프로퍼티는 이러한 리액티브 시스템 덕을 가장 크게보는 사례다. 계산 프로퍼티란 값의 변화를 탐지해 자동으로 업데이트 되는 프로퍼티를 말한다. Vue.js 템플릿에서 빼놓을 수 없는 기능이다. 리액티브 시트템은 리액티브 프로퍼티와 와처가 한 쌍을 이뤄 구현된다.</p><h3 id="리액티브-시스템의-내부"><a href="#리액티브-시스템의-내부" class="headerlink" title="리액티브 시스템의 내부"></a>리액티브 시스템의 내부</h3><p>계산프로퍼티에서는 와처 내부의 게터가 계산 프로터티로 정의하는 함수 역할을 한다. 계산프로퍼티를 처음 참조하면 와처내부에 있는 게터를 거쳐 리액티브 프로퍼티의 계산 결과가 와처에 캐싱되며 이와 함께 리액티브 프로퍼티의 의존관계 추적도 완료된다. 그 다음 이 계산 프로퍼티가 다시 참조될 때는 캐싱된 값을 반환해 계산 비용을 절약할 수 있다, 이후에 계산 프로퍼티에서 이 값이 의존하는 리액티브 프로퍼티의 일부가 대입 등의 이유로 변경되면 후크 처리를 통해 와처에 이 변경이 통지되면 내부 게터가 이 통지를 전달받아 프로퍼티 값을 다시 계산해 그 결과가 와처에 새로 캐싱된다. 반면 컴포넌트 렌더링에서는 와처 내부의 게터가 컴포넌트를 렌더링하는 함수 역할을 한다. 모든 컴포넌트가 와처를 갖고 있기 때문에 컴포넌트의 모든 데이터를 래액티브 프로퍼티로 모니터링 한다. 컴포넌트 렌더링은 모니터링 대상 중 어떤 리액티브 프로퍼티가 값이 변경됐다는 통지를 보내면 그때마다 와처의 게터가 실행돼 컴포넌트가 렌더링되는 구조다.</p><h3 id="렌더링시스템"><a href="#렌더링시스템" class="headerlink" title="렌더링시스템"></a>렌더링시스템</h3><p>Vue.js는 가장 DOM을 이용해 DOM을 고속으로 렌더링한다. 가상 DOM은 DOM을 간편하고 빠르게 제어하기 위한 기술이다. 더 편리하고 빠르게 다룰 수 있는 DOM 구조의 대체물을 만든 다음 이 대체물을 조작하고 그 결과를 실제 DOM에 반영한다. 다른라이브러리와 다른 점은 템플릿이 HTML과 유사해 개발이 쉽고 최적화가 잘 돼 있어 빠른 렌더링이 가능하다는 점이다.</p><h2 id="Vue-js의-생태계"><a href="#Vue-js의-생태계" class="headerlink" title="Vue.js의 생태계"></a>Vue.js의 생태계</h2><p>Vue.js는 뷰 계층에 초점을 맞춘 라이브러리이므로 엄밀히 말해 프레임워크는 아니다. 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능처럼 UI외적인 기능을 이용하는 웹애플리케이션을 개발하려면 추가 라이브러리가 필요하다. 웹애플리케이션 테스트 및 빌드, 개발 환경역시 직접 구축하지 않으면 안 된다.</p><ul><li>Vue Router : 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능을 제공하는 플러그인</li><li>Vuex : 대규모 웹 애플리케이션을 구축하기 위한 상태 관리 플러그인</li><li>Vue Loader : 컴포넌트의 고급 기능을 이용하기 위한 webpack 용 로더 라이브러리</li><li>Vue CLI : 웹 애플리케이션을 구축하기 위한 템플릿 프로젝트 생성 및 프로토타입을 추가 설정없이 빌드하기 위한 명령행</li><li>Vue DevToolls : Vue.js 애플리케이션을 브라우저의 개발자 도구로 디버깅할 수 있게 해주는 도구</li><li>Nuxt.js : 단일 페이지 애플리케이션과 서버 사이드 렌더링을 지원하는 Vue.js 애플리케이션을 개발하기 위한 프레임워크</li><li>Weex : Vue.js 문법을 사용해 IOS 및 안드로이드 애플리케이션을 개발할 수 있는 프레임워크</li><li>Onsen UI : 모바일 웹 애플리케이션을 개발하기 위한 프레임워크</li></ul><p>커뮤니티에서 추천 플러그인, 라이브러리, 도구 등의 정보를 얻을 수 있다.</p><ul><li>Awesome Vue : Vue.js와 관련된 오픈 소스 프로젝트나 Vue.js가 사용된 웹 사이트 및 애플리케이션 정보를 공유하는 사이트</li><li>Vue Curated : Vue.js 코어 팀에서 엄선한 플러그인, 라이브러리, 프레임워크 등을 검색 할수 있는 공식 사이트</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Vue.js 참조문서 - 공식사이트 참고(<a href="https://vuejs.org" rel="external nofollow noopener noreferrer" target="_blank">https://vuejs.org</a>)</li><li>Vue.js 사용자 커뮤니티</li><li>Vue.js 포럼 : Vue.js 를 사용하다가 발생하는 트러블이나 질문 사항을 논의하는 사이트</li><li>Vue Land : Vue.js 사용자와 코어 팀 멤버 및 컨트리뷰터가 채팅을 커뮤니케이션 하는 커뮤니티</li><li>Vue.js 밋업 : 한국 Vue.js 사용자들이 Vue.js 지식과 정보를 공유하는 밋업 이벤트</li></ul></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/11/08/Vue-study-1.1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1. 프로그레시브 프레임워크 Vue.js - part 1</title>
      <link>https://mishka.kr/2019/11/08/Vue-study-1/</link>
      <guid>https://mishka.kr/2019/11/08/Vue-study-1/</guid>
      <pubDate>Fri, 08 Nov 2019 08:48:32 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;Vue.js 철저입문&lt;/strong&gt; 책을 읽으면서 간단하게 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;Vue.js는 &lt;strong&gt;뷰 레이어에 특화&lt;/strong&gt;된 라이브러리이다. &lt;strong&gt;MVVM패턴&lt;/strong&gt;의 영향을 받은 설계를 채택하고 있어서 대규모 애플리케이션 개발에도 사용할 수 있습니다. 이러한 특징은 애플리케이션의 규모와 상관없이 어떠한 경우에도 단계적으로 유연한 적용이 가능해지는 &lt;code&gt;프로그래시브 프레임워크&lt;/code&gt;라는 Vue.js의 설계사상에서 기인한다고 한다. 이 설계사상으로 인해 프로젝트 초기에는 최소한의 학습비용만으로 시험 적용이 가능하며 대규모 시스템에서는 단계적으로 필요한 기능및 라이브러리를 조합해 덧붙여 가는 독특한 스타일의 개발이 가능하다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p><strong>Vue.js 철저입문</strong> 책을 읽으면서 간단하게 정리해 보고자 한다.</p><p>Vue.js는 <strong>뷰 레이어에 특화</strong>된 라이브러리이다. <strong>MVVM패턴</strong>의 영향을 받은 설계를 채택하고 있어서 대규모 애플리케이션 개발에도 사용할 수 있습니다. 이러한 특징은 애플리케이션의 규모와 상관없이 어떠한 경우에도 단계적으로 유연한 적용이 가능해지는 <code>프로그래시브 프레임워크</code>라는 Vue.js의 설계사상에서 기인한다고 한다. 이 설계사상으로 인해 프로젝트 초기에는 최소한의 학습비용만으로 시험 적용이 가능하며 대규모 시스템에서는 단계적으로 필요한 기능및 라이브러리를 조합해 덧붙여 가는 독특한 스타일의 개발이 가능하다.</p><a id="more"></a><h2 id="Vue-js의-역사"><a href="#Vue-js의-역사" class="headerlink" title="Vue.js의 역사"></a>Vue.js의 역사</h2><p>Vue.js는 2013년 <code>에반유(Evan You)</code>가 시작한 개인 프로젝트로 출발</p><blockquote><ul><li>2014년 2월 <strong>V0.8</strong>이 정식발표</li><li>2015년 5월에 PHP웹 애플리케이션 프레임워크인 <strong>라라벨</strong>에 표준 탑재된 것을 계기로 라라벨 커뮤니티에서 화제</li><li>2015년 10월 <strong>V1.0</strong>이 출시</li><li>2016년 10월 1일 <strong>V2.0</strong>이 출시</li></ul></blockquote><h2 id="복잡해진-모던-웹-프론트엔드-개발"><a href="#복잡해진-모던-웹-프론트엔드-개발" class="headerlink" title="복잡해진 모던 웹 프론트엔드 개발"></a>복잡해진 모던 웹 프론트엔드 개발</h2><p>모던 웹 프로트엔드 개발은 크게 고도화 되고 <code>단일 페이지 애플리케이션(SPA)</code>을 중심으로 프런트엔드 에서 복잡한 처리를 맡는 경우가 늘었으며 애플리케이션 데이터플로 설계, 라우팅, 유효성 체크 등 기존에는 백 엔드에서 맡았던 역할을 프런트 엔드가 맡게 됐다. 자바스크립트 역시 최근 몇년 사이 용도가 급격히 늘어났다. 이와 함께 업무와 관련된 개념과 도구가 함께 복잡해지는 경향을 보였다.</p><h2 id="웹-탄생과-웹-기반-시스템의-발전"><a href="#웹-탄생과-웹-기반-시스템의-발전" class="headerlink" title="웹 탄생과 웹 기반 시스템의 발전"></a>웹 탄생과 웹 기반 시스템의 발전</h2><p>웹(World Wide Web)은 지금부터 20년도 더 전인 <strong>1991년</strong>에 인터넷상에 처음 등장. 탄생 초기에는 문서 열람만을 목적으로 했으므로 당연히 지금 사용하는 SNS나 스프레드시트 같은 인터렉티브한 콘텐츠 는 구현이 불가능 했다. 1990년 후반부터 CSS와 자바스크립트가 웹 브라우저에 탑재됐다. 당시의 자바스크립트는 매우 빈약해 CSS와 함께 문서를 꾸미는 용도에 주로 사용 됐다. 비록 제약은 많았지만. 이들의 등장으로 웹페이지를 GUI 애플리케이션처럼 꾸밀 수 있게 됐다.</p><ul><li>CGI(Common Gateway Interface)로 대표되는 웹에서 사용되는 서버 사이드 프로그래밍 기술이 등장</li><li>웹 브라우저를 프리젠테이션 계층으로 삼는 웹기반 3계층 아키텍처 시스템이 등장</li><li>루비 온 레이즈로 대표되는 MVC기반 웹애플리케이션 프레임워크도 등장</li></ul><p>당시 프런트엔드가 담당했던 기능은 css등을 이용한 시작적효과와 자바스크립트를 이용한 알림창, 입력을 받는 기능 정도가 고작이었다.</p><h2 id="Ajax의-등장"><a href="#Ajax의-등장" class="headerlink" title="Ajax의 등장"></a>Ajax의 등장</h2><p>프런트엔드의 기능은 보여주는 것에만 한정된다는 것이 상식이었던 적이 있다. 그러나 2005년에 구글이 지도 서비스 구글맵스를 출시하면서 이러한 상식이 뒤집어졌다. 같은 페이지 안에서 콘텐츠를 빠르고 인터랙티브하게 변화시키는 경쾌한 사용자 경험이 <strong>Ajax</strong>를 통해 가능해졌다. Ajax 의 등장 이후 클라이언트 사이드에서는 Ajax및 이를 이용한 DOM을 정교하게 조작하는 기능이 필요해졌다.</p><ul><li>필요에 따라 등장한 <strong>jQuery</strong>등이 인기를 얻었다.</li><li>서버사이드 분야는 웹서버가 HTML 렌더링을 넘어 <strong>RESTful 기반</strong> 웹API 를 제공하게 됐다.</li><li>2000년대 말에는 <strong>HTML5</strong>와 <strong>ECMAScript</strong>를 중심으로 웹이 다시 크게 진화</li><li><strong>Node.js</strong>가 등장하면서 웹프런트엔드 개발이 한층 복잡해졌다.</li></ul><h2 id="HTML5의-등장"><a href="#HTML5의-등장" class="headerlink" title="HTML5의 등장"></a>HTML5의 등장</h2><p>HTML5는 2014년에 권고안이 나온 표준규격이다.<br>그중 중요한 것은 <code>Histrory API</code> 인데 덕분에 페이지이동을 웹브라우저대신 자바스크립트로 핸들링할 수 있게 됐다. 이를 통해 화면이동없이 URL과 히스토리를 관리하며 전환할 수 있는 단일 페이지 애플리케이션을 만들수 있게 됐다. 이러한 변화에 따라 프리젠테이션 레이어의 프로그램이 서버사이드 에서 클라이언트 사이드로 옮겨오게 된다. 기존에는 HTML렌더링을 서버에서 수행했지만, 웹 API로 데이터를 받아올수 있게 되면서 클라이언트에서도 HTML 렌더링이 가능해졌기 때문이다. 이런 방식이 화면이동이 적기 때문에 더 뛰어난 사용자 경험을 제공할 수 있다.</p><h2 id="Node-js-와-자바스크립트-생태계의-진화"><a href="#Node-js-와-자바스크립트-생태계의-진화" class="headerlink" title="Node.js 와 자바스크립트 생태계의 진화"></a>Node.js 와 자바스크립트 생태계의 진화</h2><p>2009년 에는 <strong>Node.js</strong> 가 등장</p><ul><li>첫번째 변화는 자바스크립트 실행환경이 브라우저를 벗어난 것이다. Node.js 는 프런트엔드 개발과 테스트에 매우 유용한 환경이다.</li><li>두번째 변화는 패키지 관리자이자 패키지 리포지토리인 <strong>npm</strong>의 보급이다.</li></ul><p>이에 따라 모듈(패키지)을 사용할수 있게 됐고 개발된 산출물을 다시 모듈화해 npm을 통해 배포하는 문화가 정착했다.</p><h2 id="ES2015-와-프로그래밍-언어로서의-진화"><a href="#ES2015-와-프로그래밍-언어로서의-진화" class="headerlink" title="ES2015 와 프로그래밍 언어로서의 진화"></a>ES2015 와 프로그래밍 언어로서의 진화</h2><p>웹 프런트엔드 개발이 고도화되던 와중에 문제가 된것이 자바스크립트의 빈약한 언어 기능이었다. 그래서 대대적인 규격 업데이트가 필요 했고 이에 <code>ES2015(ES6)</code> 가 등장했다.<br>ES2015 는 자바스크립트 역사상 가장 큰 규모의 업데이트였다. 문법이 확장되고 <code>const</code>나 <code>let</code>등이 널리 쓰이게 되는 등 작성스타일에도 대대적인 변화가 있었다. 표준규격이 제안 됐다고 해서 곧바로 모든 브라우저에 구현이 적용되지는 않는다. 그러나 새로운 규격에는 기존의 불만을 해소할수 잇는 매력적인 것들이 많았고 그래서 이러한 규격을 브라우저에 구현해 사용하려는 움직임이 있었다.<br><strong>Babel</strong> 은 이러한 수요에 대응해 자바스크립트를 자바스크립트로 번역하는 컴파일러다. 차세대 문법을 따른 자바스크립트 코드를 아직 해당 규격이 구현되지 않은 브라우저에서 사용할 수 있는 자바스크립트 코드로 변화하는 것이다.</p><h2 id="React등-프런트엔드-라이브러리의-출현"><a href="#React등-프런트엔드-라이브러리의-출현" class="headerlink" title="React등 프런트엔드 라이브러리의 출현"></a>React등 프런트엔드 라이브러리의 출현</h2><p>애플리케이션 데이터플로를 프런트엔드로 가져오는 등 설계 단계부터 개발 난이도를 상승시키는 것이 많았다. DOM을 웹 API와 연동시키는 것도 생각 없이 할수 있는 일이 아니다.<br>애플리케이션을 구조화 할수 없는 jQuery등을 사용해서는 구현하기가 어렵다 그러므로 MVC와 같은 애플리케이션구조를 지원하는 프레임워크가 필요해졌다. 그에따라 <strong>Backbone.js</strong>, <strong>AngularJS</strong>등 새로운 웹 애플리케이션 프레임워크 및 라이브러리가 속속 나타났다. 이런 상황에서 나타난 것이 페이스북이 개발한 <strong>React</strong>와 <strong>Flux</strong> 다.<br><code>React</code>는 뷰 라이브러리이고, <code>Flux</code>는 애플리케이션 아키텍처다. React 중심의 개발 스타일은 <strong>가상 DOM</strong>을 이용해 DOM 조작을 빠르게 수행했고, Flux 는 혼란스러워지기 쉬운 아케텍처에 방향을 제시해 큰 인기를 모았다.</p><h2 id="현재-당면과제와-Vue-js"><a href="#현재-당면과제와-Vue-js" class="headerlink" title="현재 당면과제와 Vue.js"></a>현재 당면과제와 Vue.js</h2><p>모던 프런트 엔드 개발은 현재에 이르기까지 다음과 같은 변화와 새로운 문제점을 낳았다.</p><ul><li>HTML5 이후 웹이 애플리케이션 플랫폼으로 기능하게 되면서 API가 고도화 됨</li><li>Node.js 생태계의 발전과 개발 환경 구축의 난이도 증가</li><li>ES2015 이후 문법이 보강되면서 학습할 내용이 증가</li><li>React 이후 프런트 엔드 개발이 프레임워크화되면서 그에 따른 학습비용증가</li></ul><p>정리하다보니 모던 프론트엔드 개발의 역사와 같이 나와있어서 생각보다 정리해야될 내용이 많았다.<br>그래서 2파트로 나누어서 정리하기로 했다.</p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/11/08/Vue-study-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Github SSH key 생성 및 적용하기</title>
      <link>https://mishka.kr/2019/10/18/ssh-setting/</link>
      <guid>https://mishka.kr/2019/10/18/ssh-setting/</guid>
      <pubDate>Fri, 18 Oct 2019 06:56:32 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;많은 Git 서버들은 SSH 공개키로 인증을 합니다. 또한 Github 연결시마다 계정정보를 입력해야 하는 번거로움을 제거해 준다. 이번에 입사한 회사에서도 서버에서 SSH를 사용해서 인증하는 시스템을 가지고 있어서 이 기회에 세팅을하면서 적용방법을 정리해 보았다.&lt;/p&gt;
&lt;h2 id=&quot;SSH-공개키-생성&quot;&gt;&lt;a href=&quot;#SSH-공개키-생성&quot; class=&quot;headerlink&quot; title=&quot;SSH 공개키 생성&quot;&gt;&lt;/a&gt;SSH 공개키 생성&lt;/h2&gt;&lt;p&gt;일단 공개키를 사용하려면 공개키를 만들어야 한다. 그 전에 공개키가 있는지 확인이 필요하다. 기본적으로 사용자의 SSH키들은 사용자의 &lt;code&gt;~/.ssh&lt;/code&gt; 디텍토리에 저장한다. 디텍토리의 파일을 살펴서 공개키가 있는지 확인 할 수 있다. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>많은 Git 서버들은 SSH 공개키로 인증을 합니다. 또한 Github 연결시마다 계정정보를 입력해야 하는 번거로움을 제거해 준다. 이번에 입사한 회사에서도 서버에서 SSH를 사용해서 인증하는 시스템을 가지고 있어서 이 기회에 세팅을하면서 적용방법을 정리해 보았다.</p><h2 id="SSH-공개키-생성"><a href="#SSH-공개키-생성" class="headerlink" title="SSH 공개키 생성"></a>SSH 공개키 생성</h2><p>일단 공개키를 사용하려면 공개키를 만들어야 한다. 그 전에 공개키가 있는지 확인이 필요하다. 기본적으로 사용자의 SSH키들은 사용자의 <code>~/.ssh</code> 디텍토리에 저장한다. 디텍토리의 파일을 살펴서 공개키가 있는지 확인 할 수 있다. </p><a id="more"></a><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">cd</span> ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></tbody></table></figure><p>보통 <code>id_dsa</code>나 <code>id_rsa</code>라고 되어 있다. 그 중 <code>.pub</code> 파일이 <strong>공개키</strong>이고 다른 파일은 <strong>개인키</strong> 입니다.<br>이 파일이 없거나 .ssh 디텍토리가 없으면 <code>ssh-keygen</code> 프로그램으로 키를 생성하여 준다.</p><h3 id="터미널-실행하여-다음-명령어를-실행"><a href="#터미널-실행하여-다음-명령어를-실행" class="headerlink" title="터미널 실행하여 다음 명령어를 실행"></a>터미널 실행하여 다음 명령어를 실행</h3><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">"your_email@example.com"</span></span><br></pre></td></tr></tbody></table></figure><p>적은 이메일을 레이블로 사용해서 새 SSH 키를 작성한다는 메세지가 출력됩니다.(아래와 같은 메세지가 나온다면 성공입니다.)</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">> Generating public/private rsa key pair.</span><br></pre></td></tr></tbody></table></figure><h3 id="SSH-Key-저장위치-설정"><a href="#SSH-Key-저장위치-설정" class="headerlink" title="SSH Key 저장위치 설정"></a>SSH Key 저장위치 설정</h3><p>“키를 저정할 파일을 입력하십시오” 라는 프로프트가 표시되면 Enter를 누르십시오.(기본위치로 지정)</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">> Enter a file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></tbody></table></figure><h3 id="SSH-Key-비밀번호-설정"><a href="#SSH-Key-비밀번호-설정" class="headerlink" title="SSH Key 비밀번호 설정"></a>SSH Key 비밀번호 설정</h3><p>비밀번호 없이 설정할경우 엔터 두번을 눌러주면된다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">> Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): [Type a passphrase]</span><br><span class="line">> Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></tbody></table></figure><h2 id="SSH-Key-등록"><a href="#SSH-Key-등록" class="headerlink" title="SSH Key 등록"></a>SSH Key 등록</h2><p>생성한 SSH Key를 등록해 봅시다</p><h3 id="터미널을-실행하여-아래-명령어를-실행하여-백그라운드에서-ssh-agent를-시작"><a href="#터미널을-실행하여-아래-명령어를-실행하여-백그라운드에서-ssh-agent를-시작" class="headerlink" title="터미널을 실행하여 아래 명령어를 실행하여 백그라운드에서 ssh-agent를 시작"></a>터미널을 실행하여 아래 명령어를 실행하여 백그라운드에서 ssh-agent를 시작</h3><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">eval</span> <span class="hljs-string">"<span class="hljs-variable">$(ssh-agent -s)</span>"</span></span><br><span class="line">> Agent pid 59566</span><br></pre></td></tr></tbody></table></figure><h3 id="ssh의-config-파일에-아래-text를-입력"><a href="#ssh의-config-파일에-아래-text를-입력" class="headerlink" title="ssh의 config 파일에 아래 text를 입력"></a>ssh의 config 파일에 아래 text를 입력</h3><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.ssh/config</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Host * AddKeysToAgent yes<br> UseKeychain yes<br> IdentityFile ~/.ssh/id_rsa</p></blockquote><h3 id="아래-명령어를-입력하여-SSH-Key-값을-ssh-agent에-추가"><a href="#아래-명령어를-입력하여-SSH-Key-값을-ssh-agent에-추가" class="headerlink" title="아래 명령어를 입력하여 SSH Key 값을 ssh-agent에 추가"></a>아래 명령어를 입력하여 SSH Key 값을 ssh-agent에 추가</h3><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/id_rsa</span><br></pre></td></tr></tbody></table></figure><h2 id="SSH-Key를-Github-계정에-추가"><a href="#SSH-Key를-Github-계정에-추가" class="headerlink" title="SSH Key를 Github 계정에 추가"></a>SSH Key를 Github 계정에 추가</h2><p>Github 로그인후 우측상단 메뉴에서 <code>Setting</code>을 클릭<br><img src="/img/github-setting.png" width="200px"></p><p>좌측의 <strong>Personal settings</strong> 메뉴 중에 <code>SSH and GPG keys</code> 클릭<br><img src="/img/personal-setting.png" width="200px"></p><p><code>New SSH Key</code>를 눌러서 Title과 Key를 입력후 <code>Add SSH Key</code> 버튼을 눌러준다.</p><p>Key 에는 아래명령어를 사용해서 .pub 의 공개키를 입력해 준다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>id_rsa.pub 예시</strong><br>ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU<br>GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3<br>Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA<br>t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En<br>mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx<br>NrRFi9wrf+M7Q== <a href="mailto:schacon@agadorlaptop.local" rel="external nofollow noopener noreferrer" target="_blank">schacon@agadorlaptop.local</a></p></blockquote><p>Github SSH key 생성 및 적용하기를 해보았다. Github 연결시 계정정보를 입력해야 하는 번거로움에서 해방돠었다.</p><h2 id="SSH-연결-테스트"><a href="#SSH-연결-테스트" class="headerlink" title="SSH 연결 테스트"></a>SSH 연결 테스트</h2><p>SSH 를 연결하고 나서 직접 커밋하기 전에 테스트를 해보는 방법을 알아보았다. 연결테스트를 하기 전에 아래 작업들을 모두 완료해야한다.</p><blockquote><ul><li>SSH 공개키 생성</li><li>SSH Key 등록</li><li>SSH Key를 Github 계정에 추가 </li></ul></blockquote><p>먼저 <strong>터미널을 엽니다.</strong> 그리고 아래 문구를 입력해 줍니다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></tbody></table></figure><p>그러면 아래와 같은 경고가 경고문구를 보실 수 있습니다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="hljs-string">'github.com (IP ADDRESS)'</span> can<span class="hljs-string">'t be established.</span></span><br><span class="line"><span class="hljs-string">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span></span><br><span class="line"><span class="hljs-string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></tbody></table></figure><p>또는</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="hljs-string">'github.com (IP ADDRESS)'</span> can<span class="hljs-string">'t be established.</span></span><br><span class="line"><span class="hljs-string">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class="line"><span class="hljs-string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></tbody></table></figure><p>위의 같은 메시지중 하나와 일치하는지 확인 후 <strong>yes</strong> 를 입력해 줍니다. 아래와 같은 멘트가 나오면 성공입니다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You<span class="hljs-string">'ve successfully authenticated, but GitHub does not</span></span><br><span class="line"><span class="hljs-string">provide shell access.</span></span><br></pre></td></tr></tbody></table></figure><p>자세한 내용은 아래 링크를 통해 확인 하실 수 있습니다.<br><a href="https://help.github.com/en/github/authenticating-to-github/testing-your-ssh-connection" rel="external nofollow noopener noreferrer" target="_blank">https://help.github.com/en/github/authenticating-to-github/testing-your-ssh-connection</a></p></body></html>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/10/18/ssh-setting/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
