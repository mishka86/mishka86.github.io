<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mishka&#39;s Blog</title>
    <link>https://mishka.kr/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>미슈카의 개발 블로그 입니다.</description>
    <pubDate>Tue, 31 Mar 2020 01:04:06 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>webstorm 과 jira 연동해서 사용하기</title>
      <link>https://mishka.kr/2020/03/30/webstorm-jira/</link>
      <guid>https://mishka.kr/2020/03/30/webstorm-jira/</guid>
      <pubDate>Mon, 30 Mar 2020 10:00:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;webstorm을 사용하고 업무를 진행할 때 &lt;code&gt;jira&lt;/code&gt;를 사용하다보니 jira를 별도의 창으로 띄워놓고 이슈를 생성하고, webstorm에서 작업하다가 커밋하면서&lt;br&gt;jira 티켓번호 생성하고 푸시한 다음에 티켓을 이동시켜주고 하는 반복작업이 많아졌습니다. 어떻게 보면 별거아닌 작업일 수 있지만 까먹게 되는 일이&lt;br&gt;많고 바쁠때는 모아서 하기도 하다보니 이슈 트레킹 하는데 문제가 있어보여 찾아보다가 연동하는 방법을 찾아 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;단축키는 &lt;code&gt;Mac OS&lt;/code&gt;를 기준으로 정리하였습니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>webstorm을 사용하고 업무를 진행할 때 <code>jira</code>를 사용하다보니 jira를 별도의 창으로 띄워놓고 이슈를 생성하고, webstorm에서 작업하다가 커밋하면서<br>jira 티켓번호 생성하고 푸시한 다음에 티켓을 이동시켜주고 하는 반복작업이 많아졌습니다. 어떻게 보면 별거아닌 작업일 수 있지만 까먹게 되는 일이<br>많고 바쁠때는 모아서 하기도 하다보니 이슈 트레킹 하는데 문제가 있어보여 찾아보다가 연동하는 방법을 찾아 정리해 보았습니다.</p><p>단축키는 <code>Mac OS</code>를 기준으로 정리하였습니다.</p><a id="more"></a><h2 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h2><p>webstorm에서 <code>preferences &gt; Tasks &gt; Servers</code> 로 이동합니다. 화면에서 <strong>+</strong> 버튼을 클릭해서 <strong>JIRA</strong>를 선택합니다.</p><p><img src="/img/webstorm/jira-select.png" alt><br>JIRA 외에 다른 이슈 트레커들도 연동해서 사용할 수 있습니다.</p><p>JIRA 버튼을 누르면 설정창이 뜨는데 설정창에서 Server URL 에는 JIRA 주소를 입력합니다. 그리고 계정/비밀번호를 입력해 줍니다.<br>저는 회사계정으로 입력했더니 비밀번호 입력하는 칸이 <code>API Token</code> 을 입력하는 칸으로 변경되더라구요. </p><p><img src="/img/webstorm/jira-apitoken.png" alt></p><blockquote><p>API 토큰 생성 방법은 atlassian 사이트를 참고 하셔서 발급 받으시면됩니다. -<a href="https://confluence.atlassian.com/cloud/api-tokens-938839638.html" rel="external nofollow noopener noreferrer" target="_blank">사이트 링크</a><br>API token은 한번 발급 받으면 다시 볼수 없으니 계속해서 사용하고 싶으시면 개인저장소에 저장해놓거나 잃어버리면 새로 발급 받아야합니다.</p></blockquote><p>Search 입력란은 Task 목록을 방식을 설정하는 방식을 이야기하는데 기본값으로 최신정렬순으로 되어있으니 필요하신분만 수정하시면 됩니다.</p><p><img src="/img/webstorm/jira-setting.png" alt><br>설정이 끝나면 우측 하단에 있는 <code>Test</code> 버튼을 클릭하여 테스트를 해볼수 있습니다. <strong>Connection is successful</strong> 이라는 메세지가 나오면 됩니다.<br>그리고 나서 Apply &gt; OK 눌러주시면 설정은 끝났습니다.</p><h2 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h2><p>사용해본 결과 현재(2020.03.30일 기준 2019.3 버전) webstorm에서는 JIRA 티켓 생성은 지원하고 있지 않았습니다.<br>기존에 되어있는 티켓을 Task 가져오는게 아니라면 티켓 생성은 JIRA 사이트에서 해주어야 합니다. </p><p><code>Tools &gt; Tasks &amp; contexts &gt; Open Task</code> 로 <strong>본인에게 할당된 티켓 목록</strong>을 볼 수 있습니다. 단축키는 <code>option+shift+n</code> 입니다.</p><p><img src="/img/webstorm/jira-ticket.png" alt></p><p>테스트를 위해 티켓을 별도로 하나 생성했습니다. FE-66 티켓을 선택해 주면 아래와 같은 창이 열립니다.<br>update issue state는 티켓의 state를 원하는 상태로 변경할 수 있습니다. clear current context는 현재 편집기에 열려있는 모든 탭을 닫습니다.<br>create branch 를 하면 원하는 브런치를 생성 할수도 있고, gitflow 메뉴를 이용하면 gitflow 정책대로 브런치를 생성 할 수도 있습니다.<br>gitflow 정책에 대해서는 지난 블로그 내용을 참고 바랍니다. <a href="/2020/03/30/webstorm-gitflow/">webstorm에서 gitflow 사용하기</a><br><img src="/img/webstorm/jira-task.png" alt></p><p>개발이 완료되면 커밋을 해줍니다. 단축키는 <code>command+k</code> 입니다.</p><p><img src="/img/webstorm/jira-commit.png" alt><br>커밋 메세지는 자동생성되는데 기본 옵션으로 <code>티켓ID + 제목</code> 으로 되어있고 설정을 변경할 수 있습니다.<br><code>Preferences &gt; Tasks &gt; Servers</code> <strong>Commit Message 탭</strong>을 클릭해서 원하는 규칙으로 수정 할 수 있습니다.</p><p><img src="/img/webstorm/jira-commit-message.png" alt></p><p>티켓 상태도 상황에 맞게 변경 할 수 있습니다. 단축키는 <code>option+shift+w</code> 입니다.</p><p><img src="/img/webstorm/jira-state.png" alt></p><h2 id="추가-설정"><a href="#추가-설정" class="headerlink" title="추가 설정"></a>추가 설정</h2><p>기본적으로 Task에서 생성해주는 브랜치 명은 티켓ID 로 자동할당됩니다. 생성 템플릿을 변경하려면<br><code>Preferences &gt; Tasks</code>에서 <strong>Feature branch name format</strong>을 원하는 규칙으로 수정하면됩니다.</p><p><img src="/img/webstorm/jira-format.png" alt></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://jojoldu.tistory.com/260" rel="external nofollow noopener noreferrer" target="_blank">IntelliJ를 JIRA와 연동해서 사용하기</a><br><a href="https://www.jetbrains.com/help/idea/managing-tasks-and-context.html#" rel="external nofollow noopener noreferrer" target="_blank">IntelliJ IDEA</a><br><a href="https://confluence.atlassian.com/cloud/api-tokens-938839638.html" rel="external nofollow noopener noreferrer" target="_blank">API tokens</a></p>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/30/webstorm-jira/#disqus_thread</comments>
    </item>
    
    <item>
      <title>webstorm에서 gitflow 사용하기</title>
      <link>https://mishka.kr/2020/03/30/webstorm-gitflow/</link>
      <guid>https://mishka.kr/2020/03/30/webstorm-gitflow/</guid>
      <pubDate>Mon, 30 Mar 2020 09:30:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;vscode 에서 webstorm으로 갈아타면서 플러그인으로 사용하던 몇가지 기능들을 webstorm 에서도 사용해 보고 싶었습니다.&lt;br&gt;그중에 git 을 사용하다 보면 대부분의 경우 &lt;strong&gt;&lt;a href=&quot;/2020/03/30/gitflow&quot;&gt;git-flow&lt;/a&gt;&lt;/strong&gt; 를 따라서 작업을 진행하게 됩니다. 물론 cli 를 이용해서&lt;br&gt;정책만을 따라 가며 작업할 수 있지만 번거로운 작업들도 있고 급할때는 까먹기도 하기 때문에 편하게 사용하는 방법을 찾아보았습니다.&lt;br&gt;&lt;strong&gt;&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7315-git-flow-integration&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;IntelliJ Git Flow Integration&lt;/a&gt;&lt;/strong&gt;를 이용한 방법입니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>vscode 에서 webstorm으로 갈아타면서 플러그인으로 사용하던 몇가지 기능들을 webstorm 에서도 사용해 보고 싶었습니다.<br>그중에 git 을 사용하다 보면 대부분의 경우 <strong><a href="/2020/03/30/gitflow">git-flow</a></strong> 를 따라서 작업을 진행하게 됩니다. 물론 cli 를 이용해서<br>정책만을 따라 가며 작업할 수 있지만 번거로운 작업들도 있고 급할때는 까먹기도 하기 때문에 편하게 사용하는 방법을 찾아보았습니다.<br><strong><a href="https://plugins.jetbrains.com/plugin/7315-git-flow-integration" rel="external nofollow noopener noreferrer" target="_blank">IntelliJ Git Flow Integration</a></strong>를 이용한 방법입니다.</p><a id="more"></a><h2 id="gitflow-설치"><a href="#gitflow-설치" class="headerlink" title="gitflow 설치"></a>gitflow 설치</h2><p>그전에 gitflow 를 사용할때는 별도로 gitflow 를 설치하지 않았었는데 webstorm에서 gitflow 를 사용하려면 <code>avh</code> 버전으로 설치가 필요하다.<br>mac OS의 경우 <strong><a href="/2019/09/27/zsh-setting">homebrew</a></strong> 를 통해 gitflow 를 설치해줍니다. </p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git-flow-avh</span><br></pre></td></tr></table></figure><blockquote><p>다른 OS 환경에서의 설치 방법은 <a href="https://github.com/petervanderdoes/gitflow-avh/wiki/Installation" rel="external nofollow noopener noreferrer" target="_blank">링크</a>를 참고하세요</p></blockquote><p>gitflow 를 설치하고 나면 preferences &gt; plugins &gt; marketplace 에서 <code>Git Flow Integration</code> 를 검색하여 설치해 줍니다.</p><p><img src="/img/webstorm/gitflow-integration.png" alt="Git Flow Integration"></p><p>Webstorm을 재시작하면 설치가 완료됩니다.</p><h2 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h2><p>플러그인 설치 후 webstorm 우측 하단을 보시면 아래그림과 같이 No Gitflow 를 보이시면 정상적으로 설치가 완료된것입니다.</p><p><img src="/img/webstorm/gitflow-nogitflow.png" alt></p><p>No Gitflow 를 클릭하셔셔 init Repo 를 선택하면 아래와 같은 설정화면이 나옵니다.</p><center><img src="/img/webstorm/gitflow-setting.png" alt="Option for gitflow init"></center><p>기본 옵션이 git-flow 규칙을 따라 설정되어있어서 똑같은 규칙으로 사용하시다면 별도의 수정없이 OK 눌러 주시면됩니다.</p><p>기본 옵션을 설정하고 나면 No gitflow 에서 gitflow 로 변경되고 gitflow 를 클릭하면 원하시는 동작을 할 수 있습니다.</p><p><img src="/img/webstorm/gitflow-start.png" alt></p><p>Start Feature를 눌러 feature 브런치를 생성하고 finish feature를 하면 자동으로 develop 브런치에 merge 가 이루어집니다.<br>Git flow 전략에 따라 버튼만 선택해주면 모든 이벤트가 자동으로 진행됩니다. 별도로 브랜치를 체크아웃하면서 merge, remove, tag 등을 할 필요가 없어서 반복작업의 시간을 줄일 수 있습니다.</p><p>merge의 기본옵션은 fast-forward 입니다. 이를 변경하여 merge도 하나의 커밋으로 취급하고 싶으신 분들은 prefereces &gt; Other Settings &gt;<br>gitflow 에서 Do not fast-forward when merging, always create commit(–no-ff) 옵션에 체크 하시면됩니다.</p><p><img src="/img/webstorm/gitflow-fast-forward.png" alt></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://jojoldu.tistory.com/268" rel="external nofollow noopener noreferrer" target="_blank">Git Flow Integration으로 Git Flow 심플하게 운영하기</a><br><a href="https://plugins.jetbrains.com/plugin/7315-git-flow-integration" rel="external nofollow noopener noreferrer" target="_blank">Git Flow Integration</a><br><a href="https://k39335.tistory.com/82" rel="external nofollow noopener noreferrer" target="_blank">Gitflow로 branch를 관리하자!!</a></p>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/30/webstorm-gitflow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>gitflow 란? git-flow 를 사용한 브랜치 전략</title>
      <link>https://mishka.kr/2020/03/30/gitflow/</link>
      <guid>https://mishka.kr/2020/03/30/gitflow/</guid>
      <pubDate>Mon, 30 Mar 2020 09:05:57 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;GitFlow&quot;&gt;&lt;a href=&quot;#GitFlow&quot; class=&quot;headerlink&quot; title=&quot;GitFlow?&quot;&gt;&lt;/a&gt;GitFlow?&lt;/h2&gt;&lt;p&gt;깃플로우(git-flow) 전략은 소프트웨어의 소스코드를 관리하고 출시하기 위한 &lt;strong&gt;‘브랜치 관리 전략(branch management strategy)’&lt;/strong&gt;중 하나이다.&lt;br&gt;git-flow 전략외에도 &lt;a href=&quot;https://guides.github.com/introduction/flow/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;github flow&lt;/a&gt; 와 &lt;a href=&quot;https://about.gitlab.com/blog/2014/09/29/gitlab-flow/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;gitlab flow&lt;/a&gt; 전략등도 있다. 각자에게 맞는 전략을 선택해서 사용하는게 가장 중요하다.&lt;br&gt;git-flow 는 Vicent Driessen 이 제안한 git 의 workflow 디자인에 기반한 브랜칭 모델입니다. git-flow 에서 사용하는 브랜치의 종류는 5가지이며,&lt;br&gt;크게 항상 유지되는 메인브렌치(master, develop)와 일정 기간 유지되는 보조 브랜치(feature, realease, hotfix)로 나뉩니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow?"></a>GitFlow?</h2><p>깃플로우(git-flow) 전략은 소프트웨어의 소스코드를 관리하고 출시하기 위한 <strong>‘브랜치 관리 전략(branch management strategy)’</strong>중 하나이다.<br>git-flow 전략외에도 <a href="https://guides.github.com/introduction/flow/" rel="external nofollow noopener noreferrer" target="_blank">github flow</a> 와 <a href="https://about.gitlab.com/blog/2014/09/29/gitlab-flow/" rel="external nofollow noopener noreferrer" target="_blank">gitlab flow</a> 전략등도 있다. 각자에게 맞는 전략을 선택해서 사용하는게 가장 중요하다.<br>git-flow 는 Vicent Driessen 이 제안한 git 의 workflow 디자인에 기반한 브랜칭 모델입니다. git-flow 에서 사용하는 브랜치의 종류는 5가지이며,<br>크게 항상 유지되는 메인브렌치(master, develop)와 일정 기간 유지되는 보조 브랜치(feature, realease, hotfix)로 나뉩니다.</p><a id="more"></a><blockquote><ul><li>Master - 제품으로 출시 되는 브랜치</li><li>Develop - 다음 출시 버전을 개발하는 브랜치</li><li>Feature - 기능을 개발하는 브랜치</li><li>Realease - 이번 출시 버전을 준비하는 브랜치</li><li>Hotfix - 출시 버전에서 발생한 버그를 수정하는 브랜치</li></ul></blockquote><p>많은 그림들 중에 역시 아래의 그림이 git-flow를 한눈에 이해하기에는 가장 좋은 것 같아서 가져왔습니다.<br><img src="/img/git-flow-model.png" alt="git-flow-model"></p><h2 id="개발-흐름"><a href="#개발-흐름" class="headerlink" title="개발 흐름"></a>개발 흐름</h2><p>위의 그림을 토대로 개발 흐름을 보자면 처음에 <code>Master</code> 와 <code>Develop</code> 브랜치를 만듭니다. Develop는 Master에서 부터 시작되는 브랜치 입니다.<br>새로운 추가 작업이 있는 경우 <strong>Develop</strong> 에서 <code>Feature</code> 브랜치를 생성한다.<br>Feature는 언제나 Develop에서 시작해야 합니다. 기능추가 작업이 완료되면 Feature는 Develop로 <strong>Merge</strong>한다.<br>QA를 위해 <strong>Develop</strong>에서 <code>Release</code> 브랜치를 생성한다. QA를 진행 하면서 발생한 버그들은 Release에 수정된다.<br>QA가 끝나면 Release 브랜치를 <strong>Develop</strong> 와 <strong>Master</strong> 브랜치로 각각 <strong>Merge</strong> 한다.<br><code>Hotfix</code> 브랜치는 언제나 Master에서 시작해야 합니다. 작업이 완료되면 Hotfix는 <strong>Master</strong> 와 <strong>Develop</strong> 브랜치로 각각 <strong>Merge</strong> 한다.</p><p>자세한 내용은 <a href="https://nvie.com/posts/a-successful-git-branching-model/" rel="external nofollow noopener noreferrer" target="_blank">A successful Git branching model</a> 여기를 참고하세요.</p><p>git 을 여러사람이 함께 사용하다보면 필연적으로 브랜치 전략을 세워서 git을 관리해야됩니다. 어떤 브랜치 전략을 사용하는지는 해당 팀의 성격에 맞게 선택하고 함께 공유하는게 중요하다고 생각합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>A successful Git branching model - <a href="https://nvie.com/posts/a-successful-git-branching-model/" rel="external nofollow noopener noreferrer" target="_blank">링크</a><br>우린 Git-flow를 사용하고 있어요 - 우아한형제들 기술 블로그 <a href="https://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html" rel="external nofollow noopener noreferrer" target="_blank">링크</a></p>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/30/gitflow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 제어문 과 연산자</title>
      <link>https://mishka.kr/2020/03/25/TypeScript-4/</link>
      <guid>https://mishka.kr/2020/03/25/TypeScript-4/</guid>
      <pubDate>Wed, 25 Mar 2020 09:30:24 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;조건문&quot;&gt;&lt;a href=&quot;#조건문&quot; class=&quot;headerlink&quot; title=&quot;조건문&quot;&gt;&lt;/a&gt;조건문&lt;/h2&gt;&lt;p&gt;타입스크립트는 자바스크립트에서 사용했던 조건문을 사용할 수 있습니다. 대표적으로 &lt;code&gt;if 문과 switch&lt;/code&gt; 문이 있습니다.&lt;br&gt;if 문은 조건의 참과 거짓에 따라 분기를 수행하는 조건문, switch 문은 입력값에 따라 분기를 결정하는 조건문입니다.&lt;/p&gt;
&lt;h3 id=&quot;if-문&quot;&gt;&lt;a href=&quot;#if-문&quot; class=&quot;headerlink&quot; title=&quot;if 문&quot;&gt;&lt;/a&gt;if 문&lt;/h3&gt;&lt;p&gt;if 문은 조건이 참인지 거짓인지 판단하고 분기를 수행합니다.&lt;/p&gt;
&lt;figure class=&quot;highlight typescript hljs&quot;&gt;&lt;figcaption&gt;&lt;span&gt;if 문 형식&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (조건) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  명령문;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;이때 if 문에 지정하는 조건은 참과 거짓을 판단할 수 있는 &lt;strong&gt;불리언(boolean) 타입&lt;/strong&gt;이어야 합니다. 이때 if 문에 사용할 변수도 다음과 같이 명시적으로 불리언 타입으로 선언해야 합니다.&lt;/p&gt;
&lt;figure class=&quot;highlight typescript hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; idEnable: &lt;span class=&quot;hljs-built_in&quot;&gt;boolean&lt;/span&gt; = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h2><p>타입스크립트는 자바스크립트에서 사용했던 조건문을 사용할 수 있습니다. 대표적으로 <code>if 문과 switch</code> 문이 있습니다.<br>if 문은 조건의 참과 거짓에 따라 분기를 수행하는 조건문, switch 문은 입력값에 따라 분기를 결정하는 조건문입니다.</p><h3 id="if-문"><a href="#if-문" class="headerlink" title="if 문"></a>if 문</h3><p>if 문은 조건이 참인지 거짓인지 판단하고 분기를 수행합니다.</p><figure class="highlight typescript hljs"><figcaption><span>if 문 형식</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (조건) &#123;</span><br><span class="line">  명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 if 문에 지정하는 조건은 참과 거짓을 판단할 수 있는 <strong>불리언(boolean) 타입</strong>이어야 합니다. 이때 if 문에 사용할 변수도 다음과 같이 명시적으로 불리언 타입으로 선언해야 합니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> idEnable: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>if 문의 조건이 만족하면 if 블록을 실행합니다. if문 뒤에 바로 if 문이 오는 경우 <strong>중첩이 가능하고 괄호를 생략</strong>할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-number">10</span>&gt;<span class="hljs-number">1</span>)</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>&lt;<span class="hljs-number">1</span>) &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>이어서 if 문의 조건이 false 일때 예외 사항을 처리하기 위해 else 문을 추가할 수 있습니다.</p><p>숫자열 타입에서 숫자가 0이면 false 이고, 0 이 아닌 나머지 값은 true 입니다.<br>문자열 타입은 빈 값일 때는 false 이고, 값이 있을 때는 true 입니다. </p><h3 id="switch-문"><a href="#switch-문" class="headerlink" title="switch 문"></a>switch 문</h3><p>switch 문은 비교할 대상이 많을 때 단순한 형태로 비교를 수행하기 위해 사용합니다. 타입스크립트의 switch 문은 자바스크립트의 switch 문과 형식이 같습니다.</p><figure class="highlight typescript hljs"><figcaption><span>switch 문 형식 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">switch</span> (표현식) &#123;</span><br><span class="line">  <span class="hljs-keyword">case</span> 값<span class="hljs-number">1</span>:</span><br><span class="line">    명령문;</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">  <span class="hljs-keyword">case</span> 값<span class="hljs-number">2</span>:</span><br><span class="line">    명령문;</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">  <span class="hljs-keyword">default</span>:</span><br><span class="line">    명령문;</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch/case 절에서는 <code>break</code> 문을 통해 switch 문을 벗어날 수 있어야 하고, case 절에 부합하지 않는 예외 조건을 처리하기 위해 때로는 <code>default</code> 절을<br>추가할 필요가 있습니다. switch 문의 표현식에는 변수가 올 수 있고 표현식의 값과 일치하는 case 절이 실행됩니다. 이때 case 절에 선언한 값에 표현식 값<br>과 다른 타입이 오는 것을 방지하기 위해 표현식에 사용할 변수에 타입을 지정할 수 있습니다. 이렇게 하면 switch 문에 있는 표현식 값과 case 절에 오는 값의 타입이 일치하게 됩니다. </p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> command: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:</span><br><span class="line">    <span class="hljs-comment">// 명령문</span></span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:</span><br><span class="line">    <span class="hljs-comment">// 명령문</span></span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 문의 조건은 number 타입이므로 case 절의 값은 모두 number 타입이어야 합니다.<br>switch 문을 사용할 때 case 절에 사용할 타입이 고정적이라면 반드시 입력 변수에 타입을 선언해야 하고, 그렇지 않다면 any 타입을 지정해야 합니다.</p><h4 id="폴스루"><a href="#폴스루" class="headerlink" title="폴스루"></a>폴스루</h4><p>case 절에서는 break 문을 사용해 switch 문을 벗어납니다. 그런데 때에 따라 break 문을 생략할 수 있습니다. 만약 break 문을 생략하면 다음 case 절이<br>실행됩니다. 이러한 상태를 <strong>폴스루(fall-through)</strong>라고 합니다.<br>noFallthroughCaseInSwitch 옵션의 기본값은 false 이므로 폴스루를 허용할 것 이라면 false 로 지정하거나 위 옵션을 추가하지 않고 생략하면 됩니다.</p><figure class="highlight bash hljs"><figcaption><span>tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="hljs-string">"noFallthroughCaseInSwitch"</span>: <span class="hljs-literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파일 단위로 컴파일할 때 폴스루를 방지하려면 tsc 명령어 뒤에 –noFallthroughCaseInSwitch 옵션을 추가합니다.</p><p>예외적으로 noFallthroughCaseInSwitch 옵션을 true 로 설정하더라고 폴스루를 허용하는 방법은 case 절에 <code>아무런 명령문도 넣지 않는 것</code>입니다.</p><h2 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h2><p>타입스크립트는 ECMA 스크립트를 따르므로 자바스크립트의 반복문을 지원합니다.</p><h3 id="for-문"><a href="#for-문" class="headerlink" title="for 문"></a>for 문</h3><figure class="highlight typescript hljs"><figcaption><span>for 문 형식</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (변수 초기화; 조건식; 증감식) &#123;</span><br><span class="line">  명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 문에서 사용할 변수에 ES6에서 지원되는 let 키워드와 타입을 지정할 수 있습니다.</p><h3 id="for-in-문"><a href="#for-in-문" class="headerlink" title="for in 문"></a>for in 문</h3><p>for in 문은 ES5의 자바스크립트에서 배열이나 객체를 순화할 때 사용, for in 문에 선언된 index 변수는 인덱스를 나타냅니다. 이때 배열의 요소를 가져오려면 인덱스를 통해 값에 접근 할 수 있습니다.<br>만약 인덱스가 숫자가 아닌 키라고 한다면 객체 리터럴을 이용하면 됩니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> island = [<span class="hljs-string">"jejudo"</span>, <span class="hljs-string">"Jindo"</span>, <span class="hljs-string">"Geojedo"</span>];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> island) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(index, island[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// for in 문을 이용해 객체 리터럴을 순회</span></span><br><span class="line"><span class="hljs-keyword">let</span> fruits = &#123; <span class="hljs-string">"a"</span> : <span class="hljs-string">"apple"</span>, <span class="hljs-string">"b"</span>: <span class="hljs-string">"banana"</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> property <span class="hljs-keyword">in</span> fruits) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(property, fruits[property]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-of-문"><a href="#for-of-문" class="headerlink" title="for of 문"></a>for of 문</h3><p>for of 문은 ES6 표준에 추가된 특징으로 타입스크립트 1.5부터 지원, for in 문과 달리 for of 문은 <code>곧바로 값을 가져올 수 있습니다.</code></p><figure class="highlight typescript hljs"><figcaption><span>for of 문 형식</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (변수 <span class="hljs-keyword">if</span> 이터러블) &#123;</span><br><span class="line">  명령문; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>이터러블(iterable)</code>은 반복 가능한 객체인 배열, 문자열, DOM 콜렉션, 맵과 셋 등을 말합니다.</p><p>일반 for 문에서는 let 선언자가 아닌 const 를 사용할 수 없습니다. 만약 일반 for문에서 let 대신 const 응 사용하면 상수가 되어 증가 값이 바꾸지 않기 때문에 <code>무한 루프</code>가 됩니다.<br>그런데 for of 문은 <code>Symbol.iterator</code> 의 구현을 통해 각 이터레이션 값의 요소를 가져오기 때문에 const를 사용할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value of [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="맵과-셋"><a href="#맵과-셋" class="headerlink" title="맵과 셋"></a>맵과 셋</h3><p>ES6에 추가된 이터러블 객체로 맵과 셋이 있습니다. 맵과 셋은 tsconfig.json 파일의 <code>target 속성이 ES5</code>이면 컴파일되지 않습니다.<br>이는 ES5에 <code>맵과 셋에 대응할 만한 문법이 존재하지 않기 때문</code>입니다. 맵과 셋을 이용하는 for of 문을 정상적으로 실행하려면 tsconfig.json 파일의 target을 es2015 로 수정해야 합니다.</p><p>셋 객체는 어떤 타입의 값이든 유일한 값을 저장할 수 있습니다. 셋 객체는 맵처럼 타입스크립트 컴파일러 target 속성값이 es2015일 때 컴파일됩니다.</p><p>Set 객체가 제공하는 메서드는 값을 추가하거나(add), 값을 비우거나(clear), 값을 삭제하는 것(delete)과 같이 키가 아닌 값을 메서드를 제공합니다.<br>Set 객체는 ES5에 존재하지 않으므로 ES5로 컴파일하면 for 문으로 변환됩니다. </p><h3 id="Symbol-iterator-메서드"><a href="#Symbol-iterator-메서드" class="headerlink" title="[Symbol.iterator]() 메서드"></a>[Symbol.iterator]() 메서드</h3><p>[Symbol.iterator]() 메서드는 ES6에 추가된 특징으로 배열, 맵, 셋 과 같은 이터러블 객체를 순회하는데 사용합니다.<br>사용자가 새로운 이터러블 객체를 만들어 for of, for in 문에 적용하려면 [Symbol.iterator]() 메서드를 이용해 이터러블 객체로 구현해야 합니다.</p><h3 id="while-문"><a href="#while-문" class="headerlink" title="while 문"></a>while 문</h3><p>타입스크립트의 while 문은 자바스크립트 ES5와 동일한 문법을 사용합니다. while 문은 <code>조건이 참이면 명령문을 실행하며 조건이 거짓이면 명령문의 실행을 끝내는 반복문</code>입니다.</p><figure class="highlight typescript hljs"><figcaption><span>while 문 형식</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> (참/거짓을 판별할 수 있는 조건문) &#123;</span><br><span class="line">  명령문</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while 문은 for 문과 달리 while 문에서 변수를 초기화할 수 없지만, 루프를 반복할지 여부를 루프 내부에서 결정할 수 있다는 장점이 있습니다.</p><h3 id="do-while-문"><a href="#do-while-문" class="headerlink" title="do-while 문"></a>do-while 문</h3><p>타입스크립트의 do-while 문은 자바스크립트 ES5와 동일합니다. do-while 문은 명령문을 실행하고 나서 조건이 참이면 명령문을 실행하고 거짓이면 명령문을 실행을 끝내는 반복문입니다.</p><figure class="highlight typescript hljs"><figcaption><span>do-while 문 형식</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> cnt: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(cnt);</span><br><span class="line">  cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">while</span> (cnt !=<span class="hljs-number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><h3 id="산술연산자"><a href="#산술연산자" class="headerlink" title="산술연산자"></a>산술연산자</h3><p>타입스크립트는 자바스크립트와 동일한 산술연산자를 지원합니다. 산술연산자로는 더하기, 빼기, 곱하기, 나누기 같은 사칙연산과 나머지 연산을 수행할 수 있는 % 연산자가 있습니다.<br>추가로 ES7의 지수 연산자인 **를 지원하므로 Math.pow 를 대체해 사용할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">10</span> + <span class="hljs-number">2</span>, <span class="hljs-number">10</span> - <span class="hljs-number">2</span>, <span class="hljs-number">10</span> / <span class="hljs-number">2</span>, <span class="hljs-number">10</span> % <span class="hljs-number">2</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">10</span> ** <span class="hljs-number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>+ <span class="hljs-string">"happy"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-string">"happy"</span> );</span><br></pre></td></tr></table></figure><p>산술연산자가 포함된 코드를 컴파일하면 산술 연산자가 포함된 식은 변하지 않습니다. 다만 지수 연산자가 포함된 10 ** 3 은 ES5나 ES6로 컴파일 하면<br>Math.pow(10,3)로 변환돼 컴파일 됩니다. 문자열간의 더하기 연산은 자바스크립트처럼 문자열 결합으로 인식합니다.</p><p>타입스크립트에서는 숫자 값과 불리언 값은 연산할 수 없으며, 자바스크립트처럼 false 값을 0으로 인식하지 않습니다. 따라서 <code>숫자값과 불리언 값의 덧셈은연산할 수 없으며</code> 불리언 값끼리의 연산식도 타입오류가 발생합니다. 타입스크립트에서는 문자열 타입의 숫자를 연산식에 사용할 수 없습니다.</p><h3 id="비교-논리-조건-연산자"><a href="#비교-논리-조건-연산자" class="headerlink" title="비교, 논리, 조건 연산자"></a>비교, 논리, 조건 연산자</h3><p>타입스크립트에서 조건문에 사용할 수 있는 연산는 크게 세가지로 나눌수 있습니다.</p><blockquote><ul><li>비교 연산자</li><li>논리 연산자</li><li>조건 연산자</li></ul></blockquote><p>비교연산자로는 ==, ===, !=, !==, &gt;, &lt;, &gt;=, &lt;= 가 있습니다. 자바스크립트와 다른점은 1 == true, 1 == “1” 과 같이 <code>피연산자간에 타입이 다르면 연산을 허용하지 않습니다.</code><br>이는 피연산자 간의 비교연산을 할 때 타입 안전성을 고려하기 때문입니다.</p><p>논리 연산자로는 &amp;&amp;, ||, ! 가 있습니다. 비교 연산자와 달리 논리 연산자는 피연산자끼리 타입이 일치하지 않아도 됩니다.<br>&amp;&amp; 은 피연산자가 모두 참일 때 참, ||은 피연산자 가운데 하나 이상이 참일 때 참을 의미합니다.<br>!은 부정 연산자 !true 와 같이 true 를 부정하면 false 이고 !false 와 같이 false 를 부정하면 true 입니다.</p><p>조건 연산자는 피연산자 3개를 사용하는 삼항 연산자 입니다.<br>형식은 <code>판별조건? 표현식1 : 표현식2</code> 이고 판별 조건에 따라 표현식1과 표현식2 가운데 하나를 반환합니다. 이때 판별 조건의 결과는 true/false 여야<br>하며, true 일 때는 표현식1이 실행되고 false 일때는 표현식2가 실행됩니다.</p><blockquote><p>Boolean 메서드를 이용하면 입력값을 고려해 불리언 타입으로 변환할 수 있습니다.</p></blockquote><h2 id="디스트럭처링"><a href="#디스트럭처링" class="headerlink" title="디스트럭처링"></a>디스트럭처링</h2><p>타입스크립트는 ES6의 디스트럭처링(destructuring)을 지원합니다. 디스트럭쳐링이라는 말의 뜻은 <code>객체의 구조를 제거한다는 의미</code>가 있습니다.</p><blockquote><ul><li>객체 디스트럭처링</li><li>배열 디스트럭처링</li></ul></blockquote><h3 id="객체-디스트럭처링"><a href="#객체-디스트럭처링" class="headerlink" title="객체 디스트럭처링"></a>객체 디스트럭처링</h3><p>객체 디스트럭처링은 객체 리터럴에서 변수명에 대응하는 속성값을 추출해 변수로 할당하는데 유용합니다.<br>이렇게 객체의 속성값을 변수에 할당하는 것을 <code>디스트럭처링 할당</code> 이라고 합니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> &#123; id, country &#125; = &#123; id: <span class="hljs-string">"happy"</span>, country: <span class="hljs-number">88</span> &#125;;</span><br></pre></td></tr></table></figure><p>디스트럭처링 할당 표현식은 { id, country } 와 같습니다. 디스트럭처링 할당 시 표현식 내부의 id와 country 변수는 객체의 속성값과 대응합니다. 따라서 id에는 happy 가 country 에는 88 이 할당됩니다.<br>디스트럭처링 할당 시 할당할 객체의 속성에 새로운 이름을 부여해 할당하려면 속성 재명명을 이용할 수 있습니다.</p><p>type 키워드를 이용해 매개변수의 타입을 선언함으로써 객체 디스트럭처링을 수행할 수 있습니다.</p><h3 id="배열-디스트럭처링"><a href="#배열-디스트럭처링" class="headerlink" title="배열 디스트럭처링"></a>배열 디스트럭처링</h3><p>배열 디스트럭처링은 배열 요소를 간결한 방법으로 변수에 할당하는 방법을 제공합니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> numbers = [ <span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span> ];</span><br><span class="line"><span class="hljs-keyword">let</span> [num1, num2] = numbers;</span><br></pre></td></tr></table></figure><p>만약 numbers 배열의 세 번째, 네 번째 요소를 변수에 할당하려면 앞의 요소는 쉼표로 건너뛰고 원하는 위치에 있는 요소만 변수로 지정합니다.</p><p>배열 디스트럭처링을 이용하면 함수에 배열을 전달할 때 배열 요소를 디스트럭처링 매개변수로 전달할 수 있다는 장점이 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params">[first, second]: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]</span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params">[100, "hello"]</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="전개-연산자"><a href="#전개-연산자" class="headerlink" title="전개 연산자"></a>전개 연산자</h2><p>타입스크립트는 ES6의 전개 연산자를 지원합니다. 전개 연산자는 ‘…’ 로 나타내는데 다음 세가지 경우에 사용됩니다.</p><blockquote><ul><li>나머지 매개변수를 선언할 때</li><li>배열 요소를 확장할 때</li><li>객체 요소를 확장할 때</li></ul></blockquote><h3 id="나머지-매개변수"><a href="#나머지-매개변수" class="headerlink" title="나머지 매개변수"></a>나머지 매개변수</h3><p>나머지 매개변수는 여러 인수를 배열로 받는데 “…매개변수” 와 같은 형태로 선언해 받습니다.</p><h3 id="배열-요소-확장"><a href="#배열-요소-확장" class="headerlink" title="배열 요소 확장"></a>배열 요소 확장</h3><p>전개 속성에 전개 연산자를 사용해 배열을 합칠 수 있습니다. </p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, ...arr];</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr2);</span><br><span class="line"><span class="hljs-comment">// 출력 [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><p>이때 전개 속성은 위치를 조정할 수 있습니다. ([…arr, 1, 2])</p><p>배열 디스트럭처링이 수행되면 배열은 해체해 여러 변수에 할당하는데, 할당받는 변수에 전개 연산자인 “…”을 사용하면 배열의 나머지 요소를 배열로 받을 수 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> [firstItem, ...rest]: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];</span><br></pre></td></tr></table></figure><h3 id="객체-요소-확장"><a href="#객체-요소-확장" class="headerlink" title="객체 요소 확장"></a>객체 요소 확장</h3><p>객체 합치기를 수행할 때는 전개 속성에 전개 연산자인 “…”를 사용해 합칠 수 있습니다. </p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> obj = &#123; c:<span class="hljs-number">3</span>, d:<span class="hljs-number">4</span>, e:<span class="hljs-number">5</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">let</span> obj2 = &#123; a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, ...obj &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj2);</span><br><span class="line"><span class="hljs-comment">// 출력 &#123; a:1, b:2, c:3, d:4, e:5 &#125;</span></span><br></pre></td></tr></table></figure><p>전개 연산자는 얕은 복사(shallow copy)방식으로 obj2 객체로 복사합니다. </p><p>객체 디스트럭처링은 객체를 해체해 속성값을 변수에 할당할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> &#123;n1, ...rest&#125; = &#123; n1:<span class="hljs-number">1</span>, n2:<span class="hljs-number">2</span>, n3:<span class="hljs-number">3</span> &#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/25/TypeScript-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트 - 변수 선언과 기본 타입</title>
      <link>https://mishka.kr/2020/03/18/TypeSctipt-3-var/</link>
      <guid>https://mishka.kr/2020/03/18/TypeSctipt-3-var/</guid>
      <pubDate>Wed, 18 Mar 2020 10:44:32 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;var-의-특징&quot;&gt;&lt;a href=&quot;#var-의-특징&quot; class=&quot;headerlink&quot; title=&quot;var 의 특징&quot;&gt;&lt;/a&gt;var 의 특징&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;호이스팅&lt;/li&gt;
&lt;li&gt;함수 레벨 스코프(블록 레벨 스코프 지원 되지 않음)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;var의 첫 번째 특징은 &lt;strong&gt;호이스팅&lt;/strong&gt; 입니다. 호이스팅은 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상입니다.&lt;br&gt;두 번째 특징은 &lt;strong&gt;함수 레벨 스코프(function level scope)&lt;/strong&gt;를 지원하므로 함수 내에서 선언한 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없다는 것이다. var 는 블록 레벨 스코프(block level scope)를 지원하지 않는다. 블록 레벨 스코프란 블록{} 내에서만 유효하고 블록 외부에서는 참조 할 수 없는 것을 말한다.&lt;/p&gt;
&lt;p&gt;블록 레벨 스코프를 지원하는 하는 대표적인 선언은 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;let, const&lt;/li&gt;
&lt;li&gt;클래스, 인터페이스, 타입 에일리어스(type alias), enum 선언&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="var-의-특징"><a href="#var-의-특징" class="headerlink" title="var 의 특징"></a>var 의 특징</h2><blockquote><ul><li>호이스팅</li><li>함수 레벨 스코프(블록 레벨 스코프 지원 되지 않음)</li></ul></blockquote><p>var의 첫 번째 특징은 <strong>호이스팅</strong> 입니다. 호이스팅은 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상입니다.<br>두 번째 특징은 <strong>함수 레벨 스코프(function level scope)</strong>를 지원하므로 함수 내에서 선언한 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없다는 것이다. var 는 블록 레벨 스코프(block level scope)를 지원하지 않는다. 블록 레벨 스코프란 블록{} 내에서만 유효하고 블록 외부에서는 참조 할 수 없는 것을 말한다.</p><p>블록 레벨 스코프를 지원하는 하는 대표적인 선언은 다음과 같다.</p><blockquote><ul><li>let, const</li><li>클래스, 인터페이스, 타입 에일리어스(type alias), enum 선언</li></ul></blockquote><a id="more"></a><h2 id="let-의-특징"><a href="#let-의-특징" class="headerlink" title="let 의 특징"></a>let 의 특징</h2><p>호이스팅 방지와 블록 레벨 스코프를 지원할 방법으로 ES6에서 let 선언자가 나왔고, 타입스크립트에서도 let 선언자를 지원합니다. 다음과 같은 특징을 가지고 있습니다.</p><blockquote><ul><li>블록 내에서 변수를 중복 선언 방지</li><li>호이스팅 방지</li><li>선언할 변수에 블록 레벨 스코프 적용</li></ul></blockquote><h2 id="const-의-특징"><a href="#const-의-특징" class="headerlink" title="const 의 특징"></a>const 의 특징</h2><p>const는 ES6의 특징이며 타입스크립트에서도 지원한다. let과 같은 블록 레벨 스코프를 지원하며 호이스팅을 일으키지 않습니다.<br>let과 다른 점은 const는 변수를 상수로 선언할 때 사용한다는 점이다. const를 이용해 변수를 상수로 선언하면 선언할 때 초기화는 가능하지만 재할당되지 않는 읽기전용(read only) 변수가 됩니다.<br>예외적으로 const로 선언한 변수라도 객체 리터럴의 속성으로는 변경할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> profile = &#123;</span><br><span class="line">  name : <span class="hljs-string">"happy"</span>,</span><br><span class="line">  month: <span class="hljs-number">8</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// const profile = "unhappy"; 재할당 불가능</span></span><br><span class="line">profile.name = <span class="hljs-string">"happy2"</span>; <span class="hljs-comment">// 속성에 할당 가능</span></span><br></pre></td></tr></table></figure><p>이는 타입스크립트가 값 자체를 재할당하는 것은 허용하지 않지만, 속성값의 변경을 허용하는 특성이 있기 때문이다.</p><h2 id="타입-검사와-타입선언"><a href="#타입-검사와-타입선언" class="headerlink" title="타입 검사와 타입선언"></a>타입 검사와 타입선언</h2><h3 id="타입-검사의-종류"><a href="#타입-검사의-종류" class="headerlink" title="타입 검사의 종류"></a>타입 검사의 종류</h3><p>언어에 따라 수행하는 타입 검사의 종류는 크게 ‘정적 타입 검사(statically type checking)’와 ‘동적 타입 검사(dynamically type checking)’로 나뉩니다. 정적 타입 검사는 자바, C++ 등의 언어에서 사용하고, 동적 타입 검사는 실행시간에 타입검사를 수행하며 대표적으로는 자바스크립트가 있습니다.</p><p>타입스크립트는 ‘점진적 타입 검사(gradually type checking)’를 수행합니다. 점진적 검사를 하는 대표적인 언어로는 타입스크립트와 파이썬등이 있습니다. 점진적 타입 검사는 컴파일 시간에 타입 검사를 수행하면서 필요에 따라 타입 선언의 생략을 허용합니다. 타입스크립트에서 점진적 타이핑을 성명할 때 적절한 타입으로 <strong>any</strong>가 있습니다.<br>any 타입은 모든 타입의 최상위 타입이며, 동적 타입과 정적 타입의 경계선에 있는 타입으로 타입스크립트에서는 특별히 다뤄집니다.<br>any 타입으로 선언된 변수는 어떤 타입의 변수도 받아들이면서 심지어 타입이 없는 변수도 받아들입니다.</p><h3 id="자바스크립트의-동적-타이핑"><a href="#자바스크립트의-동적-타이핑" class="headerlink" title="자바스크립트의 동적 타이핑"></a>자바스크립트의 동적 타이핑</h3><p>자바스크립트에는 기본타입과 객체타입이 있습니다. 기본 타입은 Number, Boolean, String 과 같은 타입을 말하고, 객체 타입으로는 객체 리터럴, 배열, 내장객체가 있습니다.<br>자바스크립트에는 타입이 있지만 <code>타입을 강제할 수는 없고 값을 할당할 때 타입이 추론됩니다.</code> 값을 변수에 할당 할때 타입이 정해지는 것을 <strong>동적 타이핑(dynamic typing)</strong>이라 합니다. </p><p>타입을 명시하지 않고 값을 할당하면 입력값에 따라 타입이 동적으로 정해지므로 정해진 타입을 예측할 수 없습니다. 따라서 변수의 안전한 사용을 위해서는 타입을 검사하는 코드를 불가피하게 추가 해야 합나다.</p><h2 id="타입-스크립트-계층도"><a href="#타입-스크립트-계층도" class="headerlink" title="타입 스크립트 계층도"></a>타입 스크립트 계층도</h2><center><img src="/img/Typescript_Type.png" alt="타입스크립트 타입계층도"></center><h3 id="기본-타입"><a href="#기본-타입" class="headerlink" title="기본 타입"></a>기본 타입</h3><p>기본 타입은 보편적으로 많이 사용되는 내장 타입으로서 타입 스크립트에서 지원하는 기본 타입의 종류는 다음과 같습니다.</p><blockquote><ul><li>String, number, boolean</li><li>symbol(ECMA 2015에 추가)</li><li>enum</li><li>문자열 리터럴</li></ul></blockquote><p>문자열 값을 표현할 때 역따옴표를 이용할수 있는데 역따옴표를 이용하면 줄 구분 없이 문장을 입력할 수 있습니다. 또한, 역따옴표 내에는 내장 표현식을 이용할 수 있습니다.</p><h3 id="객체-타입"><a href="#객체-타입" class="headerlink" title="객체 타입"></a>객체 타입</h3><p>객체 타입은 속성을 포함하고 있으며, 호출 시그니처, 생성자 시그니처 등으로 구성된 타입입니다. 타입스크립트에서 지원하는 객체 타입의 종류는 다음과 같습니다.</p><blockquote><ul><li>Array</li><li>Tuple</li><li>Function</li><li>Constructor</li><li>Class</li><li>Interface</li></ul></blockquote><p>tuple은 배열 요소가 n개로 정해질 때 각 요소별로 타입을 지정한 타입입니다. 예를 들어 배열 요소가 문자열과 숫자라면 <code>[string, number]</code> 같은 형태로 타입을 정의합니다.</p><h3 id="기타-타입"><a href="#기타-타입" class="headerlink" title="기타 타입"></a>기타 타입</h3><blockquote><ul><li>유니언(Union)</li><li>인터섹션(Intersection)</li><li>특수 타입</li></ul></blockquote><p>유니언 타입은 <code>2개 이상의 타입을 하나의 타입으로 정의한 타입</code>입니다. 특수 타입으로 타입 계층도의 가장 아래쪽에 위치한 void, null, undefined 있습니다. void는 빈 값을 나타내는 타입입니다.<br>함수에 반환값이 없을 때 void 타입을 선언할 수 있는데 undefined 나 null 값을 받을 때 사용합니다.</p><p><code>non-nullable</code>은 null이나 undefined를 허용하지 않는 타입이고, <code>룩업(lookup)</code> 타입은 인터페이스를 이용해 키값을 설정할 수 있는 타입입니다.</p><ul><li>객체 타입의 상위 타입으로 any 추가</li><li>any 타입의 특수 타입으로 유니언 타입과 인터섹션 타입추가</li><li>객체 타임의 하위 타입으로 Array, Interface, Tuple 추가</li><li>Void 타입 추가</li></ul><h3 id="변수에-타입-지정"><a href="#변수에-타입-지정" class="headerlink" title="변수에 타입 지정"></a>변수에 타입 지정</h3><blockquote><p><strong>[형식]</strong><br>var &lt;변수 식별자&gt;:&lt;타입&gt; = &lt;값&gt;;</p></blockquote><p>변수에 타입을 명시적으로 지정할 수 있습니다. 명시적 타입표기를 하면 변수에 어떤 값이 할당될지 직관적으로 알 수 있습니다.</p><h2 id="자바스크립트의-타입"><a href="#자바스크립트의-타입" class="headerlink" title="자바스크립트의 타입"></a>자바스크립트의 타입</h2><p>타입을 지정할 수 있는 타입스크립트와 달리 자바스크립트에서는 별도로 타입을 지정하는 절차가 없고, 런타임 시 변수에 값이 할당되면 동적으로 타입이 결정됩니다.</p><h3 id="symbol-타입"><a href="#symbol-타입" class="headerlink" title="symbol 타입"></a>symbol 타입</h3><p>ES6에서 추가된 특징으로 객체 속성의 <strong>유일하고 불변적인 식별자</strong>로 사용된다. Symbol 타입은 Symbol 함수를 이용해 다음과 같은 형태로 선언한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> hello = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>Symbol 함수는 심벌 객체를 반환, 이때 Symbol 함수가 유일한 식별자를 생성하는 팩토리 함수의 역할을 합니다. Symbol 함수를 호출할 때 “hello” 인수는 심벌의 설명을 의미한다.<br>설명은 심벌에 접근할 때 사용할 수 있으며, 생략할 수 있다. </p><h3 id="enum-타입"><a href="#enum-타입" class="headerlink" title="enum 타입"></a>enum 타입</h3><p>enum 타입은 ES6에 제안된 타입으로, 컴파일 시간에 평가된다. 타입 계층도로 보면 number 타입의 하위 타입으로 자바스크립트로 컴파일된 후에는 객체 리터럴이나 배열처럼 객체 타입이 됩니다.<br>typeof를 통해 타입 이름을 표시하면 <code>object</code>로 표시됩니다.</p><p>enum은 명명된 숫자 상수의 집합을 정의할 때 사용합니다. 명명된 숫자 상수는 enum의 속성에 대응하는 값으로서 속성은 열거해 선언할 수 있습니다.</p><blockquote><p>[형식]<br>enum Day { 속성: 값, 속성: 값, 속성: 값, … };</p></blockquote><h2 id="타입스크립트의-내장-타입"><a href="#타입스크립트의-내장-타입" class="headerlink" title="타입스크립트의 내장 타입"></a>타입스크립트의 내장 타입</h2><h3 id="any-타입"><a href="#any-타입" class="headerlink" title="any 타입"></a>any 타입</h3><p>any 타입은 제약이 없는 타입으로 <code>어떤 타입의 값도 받아들일 수 있습니다</code>. 자바스크립트가 최소한의 정적 타입 검사를 수행하는 것처럼 최소한의 타입 검사만 수행 합니다.<br>임의의 값을 받아들일 때 any 타입은 any 키워드로 선언할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> basket: <span class="hljs-built_in">any</span> = <span class="hljs-number">10</span>;</span><br><span class="line">basket = <span class="hljs-literal">true</span>;</span><br><span class="line">basket = <span class="hljs-string">"banana"</span>;</span><br></pre></td></tr></table></figure><p>any는 확정된 타입은 아니지만 어떤 값이든 할당받을 수 있습니다. 뿐만아니라 배열의 타입으로 사용하면 어떤 타입의 요소도 받아들일 수 있으므로 유연하게 활용할 수 있습니다.</p><p>any 타입은 모든 타입의 <code>가장 최상위 타입</code>입니다. 다시 말해 모든 타입은 any 타입의 하위 타입입니다. 그래서 any 타입은 자바스크립트의 모든 값을 할당 받을 수 있습니다.</p><p><code>object 타입</code>은 any 타입처럼 타입 구분 없이 값을 할당할 수 있는 특성이 있어 any 타입과 비슷하지만 속성 유무를 검사하는 시점이 다릅니다.<br>any 타입으로 선언한 변수는 속성의 유무를 런타임 시에 검사하지만, object 타입으로 선언한 변수는 컴파일 시간에 속성의 유무를 검사합니다.<br>따라서 object 타입의 변수에 숫자를 할당하더라고 컴파일 시에 숫자 메서드를 인식하지 못하므로 컴파일 시간에 에러가 발생합니다.</p><h3 id="noImplicitAny-옵션"><a href="#noImplicitAny-옵션" class="headerlink" title="noImplicitAny 옵션"></a>noImplicitAny 옵션</h3><p>any 타입의 사용을 강제할때 컴파일 옵션 중 noImplicitAny를 true 로 설정합니다.</p><figure class="highlight bash hljs"><figcaption><span>tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="hljs-string">"noImplicitAny"</span>: <span class="hljs-literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>noImplicitAny 옵션은 false 가 기본값이므로 noImplicitAny 옵션을 생략한다면 any 타입을 생략해도 괜찮습니다.</p><h2 id="배열-타입과-제네릭-배열-타입"><a href="#배열-타입과-제네릭-배열-타입" class="headerlink" title="배열 타입과 제네릭 배열 타입"></a>배열 타입과 제네릭 배열 타입</h2><p>배열은 여러 개의 값을 하나의 변수에 담아 관리하는 자료구조이다. 여러 값을 모아 담기 때문에 컬렉션(collections) 이라 불리기도 합니다.<br>타입스크립트에서 배열 타입은 두 가지 형태로 나뉩니다.</p><blockquote><ul><li>배열 타입 (array type)</li><li>제네릭 배열 타입 (generic array type)</li></ul></blockquote><h3 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h3><p>배열 타입은 타입스크립트 0.9 버전 부터 지원 됐으며 다음 같이 선언합니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> myVar: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];</span><br></pre></td></tr></table></figure><p>배열 타입은 요소 타입에 []를 붙여 선언합니다. 요소 타입으로는 string, number, boolean 과 같은 내장 타입뿐 아니라 클래스나 인터페이스도 올 수 있습니다.<br>베열 요소의 타입이 정해져 있지 않다면 any 타입으로 지정할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> myVal: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-string">"hi"</span>, <span class="hljs-literal">true</span>]</span><br></pre></td></tr></table></figure><p>any 타입으로 지정하면 어떤 요소든 배열의 요소로 추가할 수 있습니다. 타입이 느슨하므로 타입을 제약하려면 유니언 타입을 이용해 선언합니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> myVal: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">"hi"</span>, <span class="hljs-literal">true</span>]</span><br></pre></td></tr></table></figure><h3 id="제네릭-배열"><a href="#제네릭-배열" class="headerlink" title="제네릭 배열"></a>제네릭 배열</h3><p>제네릭 배열 타입은 타입스크립트 0.9 버전부터 지원됐으며 제네릭 배열 타입은 Array<t>형태로 선언합니다. 이때 T 는 타입을 의미합니다.</t></p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num:<span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br></pre></td></tr></table></figure><p>타입을 숫자나 문자열 타입으로 제약하려면 유니언 타입으로 선언</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num:<span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-string">"hello"</span>];</span><br></pre></td></tr></table></figure><p>제네릭 타입 인수로 사용된 T는 컴파일 시점에 타입을 검사합니다. 타입스크립트에서 선언한 배열,제네릭 배열타입은 컴파일시 타입 검사를 위해 필요하고, 컴파일 후에는 타입이 제거된 배열만 남습니다.</p><h3 id="튜플-타입"><a href="#튜플-타입" class="headerlink" title="튜플 타입"></a>튜플 타입</h3><p>튜플 타입은 n 개의 요소로 이뤄진 배열에 대응하는 타입을 의미합니다. 튜플은 배열과 비슷한데, 배열은 배열 요소의 개수에 제한이 없고 string[]처럼 특정 타입으로 배열 요소의 타입을 강제할 수 있습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">string</span>[] = [ <span class="hljs-string">"tuple1"</span>,  <span class="hljs-string">"tuple2"</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> x: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [ <span class="hljs-string">"tuple1"</span>,  <span class="hljs-number">100</span>];</span><br></pre></td></tr></table></figure><p>타입 스크립트2.7 이전에는 배열의 요소가 튜플타입에 선언된 개수를 초과하면 유니언 타입을 적용받았습니다. 그런데 2.7이 되면서 튜플 타입에 따라 할당 배열의 요소 수도 고정됐습니다.</p><h3 id="void-null-undefined"><a href="#void-null-undefined" class="headerlink" title="void, null, undefined"></a>void, null, undefined</h3><p>void는 함수의 반환값이 없을 때 지정하는 타입입니다. void 타입에는 null이나 undefiend만 할당할 수 있습니다.<br>반환값이 없을 때 이를 명시적으로 나타내기 위해 void를 지정합니다.<br>null 이든 undefined 이든 불필요한 선언이 되거나 초기화하지 않았을 때 불안정한 연산을 초래할 수 있으므로 컴파일러 옵션에서 사용하지 못하게 막을 필요가 있습니다.</p><figure class="highlight bash hljs"><figcaption><span>tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="hljs-string">"strincNullChecks"</span>: <span class="hljs-literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그럼 기본적으로 변수에 할당되번 null 과 undefined는 더 이상 할당되지 못하고 컴파일 오류를 발생시킵니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>타입스크립트 퀵스타트 - 루비페이퍼</p>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/18/TypeSctipt-3-var/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript? 타입스크립트 소개 및 개발환경 구축</title>
      <link>https://mishka.kr/2020/03/11/TypeScript-1/</link>
      <guid>https://mishka.kr/2020/03/11/TypeScript-1/</guid>
      <pubDate>Wed, 11 Mar 2020 08:15:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;타입스크립트-TypeScript&quot;&gt;&lt;a href=&quot;#타입스크립트-TypeScript&quot; class=&quot;headerlink&quot; title=&quot;타입스크립트(TypeScript)&quot;&gt;&lt;/a&gt;타입스크립트(TypeScript)&lt;/h2&gt;&lt;p&gt;타입스크립트(TypeScript)는 오픈소스 프로그래밍 언어입니다. &lt;strong&gt;마이크로소프트&lt;/strong&gt;가 개발했고 유지 관리하고 있습니다.&lt;br&gt;독자적인 표준을 가지고 있지 않고 &lt;code&gt;ECMA스크립트 표준&lt;/code&gt;을 따르기 때문에 자바스크립트의 특성을 침범하지 않고 최신 ECMA 표준을 지원합니다.&lt;br&gt;그래서 타입스크립트는 &lt;strong&gt;자바스크립트의 상위 집합(superset)언어&lt;/strong&gt;라고 합니다.&lt;br&gt;타입스크립트가 ECMA 스크립트를 따르므로 자바스크립트 문법을 타입스크립트에서 이용 할수 있으며, 최신 ECMA 표준을 지원함으로써 하위 ECMA 표준에 대한 컴파일도 지원합니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="타입스크립트-TypeScript"><a href="#타입스크립트-TypeScript" class="headerlink" title="타입스크립트(TypeScript)"></a>타입스크립트(TypeScript)</h2><p>타입스크립트(TypeScript)는 오픈소스 프로그래밍 언어입니다. <strong>마이크로소프트</strong>가 개발했고 유지 관리하고 있습니다.<br>독자적인 표준을 가지고 있지 않고 <code>ECMA스크립트 표준</code>을 따르기 때문에 자바스크립트의 특성을 침범하지 않고 최신 ECMA 표준을 지원합니다.<br>그래서 타입스크립트는 <strong>자바스크립트의 상위 집합(superset)언어</strong>라고 합니다.<br>타입스크립트가 ECMA 스크립트를 따르므로 자바스크립트 문법을 타입스크립트에서 이용 할수 있으며, 최신 ECMA 표준을 지원함으로써 하위 ECMA 표준에 대한 컴파일도 지원합니다.</p><a id="more"></a><h3 id="ECMA-스크립트의-역사"><a href="#ECMA-스크립트의-역사" class="headerlink" title="ECMA 스크립트의 역사"></a>ECMA 스크립트의 역사</h3><p>ECMA는 유럽 컴퓨터 제조사 연합<code>(European Computer Manufacturers Association)</code>의 약자로 스크립트의 표준을 만들고 관리하는 단체입니다.<br>이 단체는 자바스크립트 뿐아니라 C#, 다트(Dart) 같은 언어의 표준과 JSON, XML과 같은 데이터 교환 형식의 표준도 관리하고 있습니다.<br>간단하게 역사를 살펴보면 </p><blockquote><p>ECMA 스크립트 표준은 1997년에 처음 등장한 스크립트 표준이고, 첫번째 판이라는 의미로 ‘Ed.1’이라는 버전 형식을 추가해<br>‘ECMA-262 Ed.1’ 이라고 명명됐습니다. 이를 줄여서 <strong>ES1</strong> 이라고 부릅니다.<br><strong>ES2</strong> 버전은 1998년도에 나왔습니다. 새로운 특징이 추가된 것은 아니고 국제 표준화 국제 전기 전자 표준 위원회의 표준인 ISO/IEC 16262에 부합하도록 재편집 됐습니다.<br><strong>ES3</strong>부터는 ECMA 스크립트가 본격적으로 브라우저 지원을 위한 표준으로 발돋움 했고, 이때 추가된 특징으로 <strong>try/catch</strong> 예외 처리 구문 등이 있습니다.<br><strong>ES4</strong>는 스크립트 버전 중 예외적으로 불완전한 표준이 되어 표준으로 채택되지 못했습니다.<br><strong>ES5</strong>는 2009에 나왔고 브라우저에서 가장 안정적으로 동작하는 표준입니다. 이때 ES5표준을 기반으로 한 <strong>Node.js</strong> 플랫폼도 등장했습니다.<br>이로써 자바스크립트가 서버프로그래밍이 가능한 언어로서 영역을 확장했습니다.<br><strong>ES6</strong>는 2015년에 확정되었고 <strong>모듈 시스템, 화살표함수, 클래스, 개선된 객체 리터널, 템플릿 문자열, 심볼, 프로미스, 제너레이터, for of, 디스트럭처링, 프락시, let, const</strong> 등 많은 특징이 추가됐습니다.<br><strong>ES7</strong>은 2016년에 확정되었고, 비동기 함수를 동기화 할 수 있는 <strong>Async/Await</strong> 에 대한 특징 등이 추가됐습니다.<br><strong>ES8</strong>은 2017년에 확정되었고, 문자열패딩, Object, values 메서드, Object.entries 메서드 등 많은 특징이 추가됐습니다.<br><strong>ES9</strong>은 2018년에 확정되었고, Rest/Spread Properties, for await of, Promise.prototype.finally 메서드 등이 추가되었습니다.</p></blockquote><h2 id="타입스크립트의-특징"><a href="#타입스크립트의-특징" class="headerlink" title="타입스크립트의 특징"></a>타입스크립트의 특징</h2><p>타입스크립트를 자바스스크립트와 비교할때 가장 두드러진 특징은 <strong>‘타입’</strong>입니다. 타입은 꽤 사소해 보이지만 타입스크립트에서 중요한 특징입니다.<br>타입이 있음으로써 개별 변수나 함수에 타입 안정성을 더할 뿐 아니라, 대규모 프로젝트를 구성할 수 있는 밑바탕이 됩니다.</p><p>타입스크립트의 공식 홈페이지에 나와있는 슬로건은 <code>&#39;JavaScript that scales&#39;</code> 입니다.<br>타입스크립트는 대규모 애플리케이션 개발을 위해 다음과 같은 특징을 지원합니다.</p><blockquote><ul><li>모듈 시스템- ES6 모듈과 네임스페이스 지원</li><li>클래스와 인터페이스 지원</li><li>타입시스템 지원</li></ul></blockquote><p>타입스크립트의 모듈 시스템은 크게 <code>ES6 모듈</code>과 <code>네임스페이스</code>로 나뉩니다.<br><code>ES6 모듈</code>은 기존 ES5에서 어려웠던 모듈 분활과 결합 기능을 향상 <code>네임스페이스</code>는 ES6에 없는 타입스크립트에 추가된 특징으로 분리된 이름 공간을 제공해 복잡도를 낮춥니다. 또한 ES6의 클래스뿐 아니라 인터페이스를 추가로 지원해 객체지향 프로그래밍을 더욱 완전하게 지원하고,<br>타입시스템을 기반으로 대규모 애플리케이션을 개발 할 수 있게 합니다.</p><h3 id="모듈-시스템"><a href="#모듈-시스템" class="headerlink" title="모듈 시스템"></a>모듈 시스템</h3><p>ES6에서 제공하는 <code>모듈 선언</code>과 <code>모듈 호출</code> 방식을 지원합니다. <code>export</code> 키워드로 외부 모듈을 선언하거나 <code>import</code> 키워드를 이용해 외부 모듈을 호출 할수 있습니다. 네임스페이스는 라이브러리 단위의 모듈 구성에 유리하며 규모있는 모듈 구성에 필요한 특징입니다.<br>각 네임스페이스에는 인터페이스를 비롯해 클래스나 함수 등의 모듈을 선언할 수 있습니다.</p><h3 id="클래스와-인터페이스-지원"><a href="#클래스와-인터페이스-지원" class="headerlink" title="클래스와 인터페이스 지원"></a>클래스와 인터페이스 지원</h3><p>ES6와 동일한 키워드를 이용해 클래스를 정의 할수 있고, 특히 인터페이스를 지원함으로써(interface, extends) 객체지향 언어의 특징을 더욱 풍부하게 지원합니다.</p><h3 id="타입-시스템-지원"><a href="#타입-시스템-지원" class="headerlink" title="타입 시스템 지원"></a>타입 시스템 지원</h3><p>타입스크립트에는 강력한 <code>타입 시스템(type system)</code>이 있습니다 타입시스템은 자바스크립트의 타입을 확장하고 타입 어노테이션(type annotation)을 이용해 변수에 타입을 선언할 수 있게 합니다.<br>변수에 타입을 선언하는 것을 타입 지정(typing) 이라고 합니다. 타입 지정이 이뤄지면 변수는 엄격한 타이핑(strong typing)이 적용돼 타입 안전성(type safety)을 확보합니다.<br>예를 들어 변수에 string을 타입 어노테이션으로 선언하면 지정한 string 타입 외에 다른 타입의 값을 할당할 수 없습니다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 타입 어노테이션</span></span><br><span class="line">val myVal:<span class="hljs-built_in">string</span></span><br></pre></td></tr></table></figure><p>타입스크립트에서 변수는 함수의 매개변수 등에 선언한 타입 어노테이션은 컴파일할 때 타입 검사를 위한 목적으로 사용합니다.<br>타입 검사를 통해 타입 안정성이 확보되면 타입스크립트 컴파일러가 타입 어노테이션을 제거하고 최종적으로 자바스크립트 코드를 생성합니다.</p><h4 id="정적타입"><a href="#정적타입" class="headerlink" title="정적타입"></a>정적타입</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">funxtion sum(a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>)&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>);</span><br><span class="line"><span class="hljs-comment">// error TS2345: Argument of type '"x"' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure><p>TypeScript는 정적 타입을 지원하므로 컴파일 단계에서 오류를 포착 할수 있다는 장점이 있다.<br>명시적인 정적 타입 지적은 개발자의 의도를 명확하게 코드로 기술 할 수 있다. 가독성을 높이고 디버깅을 쉽게 한다.</p><h2 id="타입스크립트의-역사"><a href="#타입스크립트의-역사" class="headerlink" title="타입스크립트의 역사"></a>타입스크립트의 역사</h2><p>타입스크립트는 대규모 애플리케이션을 개발하는 데 있어 자바스크립트는 어렵고 불편하다는 고객사의 불만에 대응하기 위한 목적으로 개발됐습니다.<br>메인 개발자는 앤더스 헤일스버그(Anders Hejlsberg)입니다. C# 언어의 설계를 이끌고 있으며, 델파이의 창시자이기도 합니다.<br>C# 를 설계하고 개발을 주도한 아키텍트가 타입스크립트 개발을 이끌면서 타입스크립트에 많은 영향을 끼쳤습니다.</p><h3 id="버전별-특징"><a href="#버전별-특징" class="headerlink" title="버전별 특징"></a>버전별 특징</h3><p>출시 당시에는 많은 관심을 받지 못함, 여러가지 불편사항들이 있었는데 그 중 IDE 지원이 원할하지 못하다는 것에 대응으로 이후 마이크로소프트는 비주얼 스튜디오를 통해 타입스크립트를 지원하게 됐습니다. 이 후 여러가지 개발도구들에서 타입스크립트를 지원하게 됐습니다.</p><blockquote><ul><li>2012년 10월 1일에 첫번째 버전(0.8)이 출시 됐습니다. 이후에 ECMA 스크립트가 발표될 때마다 곧바로 버전이 업데이트 되었습니다.</li><li>타입스크립트 두 번째 버전(0.9)은 2013년 6월 18일에 발표 됐습니다. 0.9 버전의 가장 큰 특징은 <strong>제네릭(generics)</strong> 지원입니다.</li><li>2014년 4월 2일에 타입스크립트 버전1.0 을 발표 2014년 7월에 타입스크립트만을 위한 <strong>새로운 컴파일러</strong>를 발표</li><li>2016년 8월 26일에 타입스크립트 2.0 이 발표 주요 특징은 <strong>Non-Nullable 타입, .d.ts</strong> 파일을 패키지로 가져올 수 있음</li><li>버전 2.1 에서는 <strong>프로미스에 대한 폴리필이나 Async/Await 의 하위표준(ES3, ES5)으로의 컴파일</strong>을 지원</li><li>2.5 에서는 <strong>함수추출, 메서드 리팩토리, 퀵 픽스</strong> 기능 추가</li><li>2.7 에서는 컴파일러의 타입검사 기능 향상 대표적 특징으로는 <strong>엄격한 클래스 초기화(Strict Class Initialization)와 고정 길이 튜플(Fixed Length Tuples)</strong>이 있습니다.</li></ul></blockquote><h2 id="타입스크립트의-아키텍처"><a href="#타입스크립트의-아키텍처" class="headerlink" title="타입스크립트의 아키텍처"></a>타입스크립트의 아키텍처</h2><blockquote><ul><li>에디터</li><li>독립서버</li><li>언어 서비스 / 독립 TS 컴퍼일러</li><li>코어 타입스크립트 컴파일러</li></ul></blockquote><h3 id="컴파일러"><a href="#컴파일러" class="headerlink" title="컴파일러"></a>컴파일러</h3><p>타입스크립트의 아키텍처는 언어 변환 기능을 수행하는 코어 타입스크립트 컴파일러(core typescript compiler)를 기반으로 합니다.<br>코어 타입스크립트 컴파일러는 파서, 바인더, 타입체커, 에미터, 전처리기로 구성돼 있습니다.</p><blockquote><ul><li>파서(parser) : 읽어 들인 소스코드를 해석해 구문 트리를 만들고, 구문 트리를 다시 해석해 추상 구분 트리(AST: Abstract Syntax Tree)를 생성한다.</li><li>바인더(binder) : 인터페이스나 모듈 혹은 함수와 같은 모듈에 선언이 있을 때 이러한 선언을 심벌로 보고 심벌 간의 규칙을 정의한다. 타입 시스템은 바인더를 통해 명명된 선언을 추론 할 수 있게 된다.</li><li>타입 체커(type checker) : 타입이 선언된 구문을 분석하고 타입이 적절한지 체크한다.</li><li>에미터(emitter) : 입력된 *.ts 같은 타입스크립트 파일을 *.js, *.d.ts, *.js.map 유형의 파일로 생성하는 기능을 수행한다.</li><li>전처리기(pre-processor) : 타입스크립트 파일에 선언된 import문이나 “/// &lt;reference = 경로&gt;” 같은 외부 호출 선언이 있을 때 참조 할 수 있는 파일을 가져와 정렬된 파일 목록을 생성한다.</li></ul></blockquote><h3 id="언어-서비스"><a href="#언어-서비스" class="headerlink" title="언어 서비스"></a>언어 서비스</h3><p>언어 서비스는 코드를 컴파일해 도움말이나 코드의 포매팅, 코드 생상 지정 같은 편집기에 필요한 기능을 제공합니다. 언어 서비스는 편집기에서 코드 어시스트를 제공하는 근간입니다.</p><h3 id="독립서버-standalone-server"><a href="#독립서버-standalone-server" class="headerlink" title="독립서버(standalone server)"></a>독립서버(standalone server)</h3><p>독립서버는 컴파일러와 언어 서비스 같은 하위 레이어를 래핑해 JSON 형식을 통해 외부에 정보를 노출할 수 있게 합니다. 독립서버의 다른 이름은 tsserver 입니다.<br>IDE 나 편집기 개발에 필요한 기능을 명령어 형식으로 제공, 서버 형식에 맞게 JSON으로 요청하면 결과를 응답합니다.<br>독립서버는 타입스크립트의 개발 환경이므로 타입스크립트를 이용한 응용 개발에서 직접 다룰 일은 없습니다.</p><h3 id="편집기"><a href="#편집기" class="headerlink" title="편집기"></a>편집기</h3><p>타입스크립트코드에 구문 오류나 타입 오류가 있는지 실시간으로 파악 할 수 있도록 코드 어시스트를 지원합니다.</p><h2 id="개발환경-구축"><a href="#개발환경-구축" class="headerlink" title="개발환경 구축"></a>개발환경 구축</h2><p>타입스크립트는 npm을 통해 설치 할수 있다. npm의 사용을 위해 Node.js 를 설치한다.<br><a href="https://nodejs.org/ko/" rel="external nofollow noopener noreferrer" target="_blank">https://nodejs.org/ko/</a></p><p>Node.js 가 재대로 설치됐다면 npm 명령어를 사용해 타입스크립트를 설치한다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g typescript</span><br></pre></td></tr></table></figure><p>아래 명령어를 사용하여 타입스크립트 버전을 확인 할수 있다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc -v</span><br></pre></td></tr></table></figure><h3 id="타입스크립트-컴파일러"><a href="#타입스크립트-컴파일러" class="headerlink" title="타입스크립트 컴파일러"></a>타입스크립트 컴파일러</h3><p>TypeScript 컴파일러(tsc)는 TypeScript 파일(.ts)을 입력받아 ECMA 스크립트(자바스크립트)의 특정 버전으로로 반환합니다.</p><blockquote><p>컴파일링 : 한 언어의 소스코드를 다른 언어로 바꾸는 것<br>트랜스파일링: 한 언어의 소스코드를 비슷한 추상화 수준의 다른 언어로 바꾸는 것 </p></blockquote><p>관점에 따라 타입스크립트는 다른 언어인 자바스크립트로 바꾸므로 컴파일링 한다고 볼수 있지만 비슷한 추상화 수준의 다른 언어로 트랜스파일링 한다고 볼수도 있다. </p><p>간단한 코드를 작성해서 타입스크립트 코드를 자바스크립트 코드로 컴파일하고 이를 실행 해보자.</p><figure class="highlight typescript hljs"><figcaption><span>hello.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> hello: <span class="hljs-built_in">string</span> = <span class="hljs-string">"hello TypeScript"</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(hello);</span><br></pre></td></tr></table></figure><p>tsc 명령어로 컴파일 할 수 있다. tsc 명령어 뒤에 컴파일 대상 파일명을 작성하다. 이때 확장자 .ts 는 생략이 가능합니다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello</span><br></pre></td></tr></table></figure><p>변환 결과 hello 변수 타입인 string 이 삭제되고 hello.js 파일이 생성 됩니다.</p><figure class="highlight javascript hljs"><figcaption><span>hello.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> hello = <span class="hljs-string">"hello typeScript"</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(hello);</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>타입스크립트 퀵스타트 - 루비페이퍼<br><a href="https://poiemaweb.com/typescript-introduction" rel="external nofollow noopener noreferrer" target="_blank">TypeScript의 소개와 개발 환경 구축 - Poiemaweb</a></p>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/03/11/TypeScript-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue 에서 Axios를 사용하여 서버통신 해보기</title>
      <link>https://mishka.kr/2020/02/19/axios/</link>
      <guid>https://mishka.kr/2020/02/19/axios/</guid>
      <pubDate>Wed, 19 Feb 2020 10:06:25 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Axios-란&quot;&gt;&lt;a href=&quot;#Axios-란&quot; class=&quot;headerlink&quot; title=&quot;Axios 란?&quot;&gt;&lt;/a&gt;Axios 란?&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Axios&lt;/code&gt;는 &lt;strong&gt;HTTP 클라이언트 라이브러리&lt;/strong&gt; 중 하나이다.&lt;br&gt;비동기 방식으로 HTTP 데이터 요청을 실행하고 또한 IE8 이상을 포함한 모든 최신 브라우저를 지원한다.&lt;br&gt;&lt;code&gt;Axios&lt;/code&gt;는 &lt;strong&gt;Promise&lt;/strong&gt;를 기반의 자바스크립트 비동기 처리 방식을 사용합니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Axios-란"><a href="#Axios-란" class="headerlink" title="Axios 란?"></a>Axios 란?</h2><p><code>Axios</code>는 <strong>HTTP 클라이언트 라이브러리</strong> 중 하나이다.<br>비동기 방식으로 HTTP 데이터 요청을 실행하고 또한 IE8 이상을 포함한 모든 최신 브라우저를 지원한다.<br><code>Axios</code>는 <strong>Promise</strong>를 기반의 자바스크립트 비동기 처리 방식을 사용합니다.</p><a id="more"></a><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>보통 npm을 통해 설치를 진행합니다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>이밖에도 yarn,bower,CDN 을 통해 설치도 가능합니다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// yarn</span><br><span class="line">yarn add axios</span><br><span class="line"></span><br><span class="line">// bower</span><br><span class="line">bower install axios</span><br><span class="line"></span><br><span class="line">// Using unpkg CDN</span><br><span class="line">&lt;script src=<span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h2><p>Axios는 여러가지 별칭 method를 제공하고 있습니다.</p><blockquote><p>axios.get(url[, config])<br>axios.post(url[, data[, config]])<br>axios.patch(url[, data[, config]])<br>axios.delete(url[, config])<br>위에 자주 쓰이는 4가지 이외에도 여러가지 를 지원 하고 있다.<br>axios.request(config)<br>axios.head(url[, config])<br>axios.options(url[, config])<br>axios.put(url[, data[, config]])</p></blockquote><p>별칭으로 사용하는 경우에는 url, method 및 data 특성을 구성에 지정할 필요가 없습니다.</p><h2 id="GET-불러오기"><a href="#GET-불러오기" class="headerlink" title="GET (불러오기)"></a>GET (불러오기)</h2><p>GET은 말 그대로 서버에서 데이터를 가져오는데 사용합니다. 많이 사용하는 명령어 중에 하나입니다.<br>서버 주소 <code>/api</code>로 부터 값을 가져올때는 아래와 같이 사용합니다.</p><figure class="highlight javascript hljs"><figcaption><span>GET</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="hljs-string">'/api'</span>)</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(res); </span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err) =&gt; &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>axios 요청할 때 메소드의 두번제 인자인 config 객체에 요청값을 같이 넘길수 있습니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="hljs-string">'/api'</span>, &#123;</span><br><span class="line">  params: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'타이틀'</span> &#125;,</span><br><span class="line">  headers: &#123; <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> &#125;,</span><br><span class="line">  timeout: <span class="hljs-number">1000</span>  </span><br><span class="line">&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="POST-입력하기"><a href="#POST-입력하기" class="headerlink" title="POST (입력하기)"></a>POST (입력하기)</h2><p>서버에 값을 입력 할 때 사용합니다. 서버의 데이터 리스트의 마지막에 넘기는 정보를 추가합니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="hljs-string">'/api'</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'타이틀'</span> &#125;)</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(res);  </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="PATCH-수정하기"><a href="#PATCH-수정하기" class="headerlink" title="PATCH (수정하기)"></a>PATCH (수정하기)</h2><p>서버의 특정 데이터를 수정합니다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.patch(<span class="hljs-string">'/api'</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'타이틀변경'</span> &#125;)</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(res);  </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="DELETE-삭제하기"><a href="#DELETE-삭제하기" class="headerlink" title="DELETE (삭제하기)"></a>DELETE (삭제하기)</h2><p>서버의 특정 값을 삭제합니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.delete(<span class="hljs-string">'/api/val'</span>) <span class="hljs-comment">//val = 특정 값</span></span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(res);  </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="Vue-에서-Axios-사용하기"><a href="#Vue-에서-Axios-사용하기" class="headerlink" title="Vue 에서 Axios 사용하기"></a>Vue 에서 Axios 사용하기</h2><p>vue 에서 axios 를 사용하려면 Vue.prototype에 axios를 추가하면 된다. main.js에 나래와 같은 내용을 추가한다.</p><figure class="highlight javascript hljs"><figcaption><span>main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span></span><br><span class="line"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span></span><br><span class="line"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'.axios'</span> <span class="hljs-comment">// import axios</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$axios = axios; <span class="hljs-comment">// prototype에 axios 추가</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="hljs-literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="line">    render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="hljs-string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>위와 같이 작성하면 Vue 인스턴스 내부에서 axios를 따로 import 하지 않아도 <code>this.$axios</code>를 이용해서 사용 할 수 있다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/axios/axios" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/axios/axios</a><br><a href="https://tuhbm.github.io/2019/03/21/axios/" rel="external nofollow noopener noreferrer" target="_blank">https://tuhbm.github.io/2019/03/21/axios/</a><br><a href="https://ux.stories.pe.kr/138" rel="external nofollow noopener noreferrer" target="_blank">https://ux.stories.pe.kr/138</a><br><a href="https://luji.tistory.com/83" rel="external nofollow noopener noreferrer" target="_blank">https://luji.tistory.com/83</a></p>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/02/19/axios/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Github 블로그에 Custom 도메인 연결하기</title>
      <link>https://mishka.kr/2020/01/10/github-domain/</link>
      <guid>https://mishka.kr/2020/01/10/github-domain/</guid>
      <pubDate>Fri, 10 Jan 2020 00:55:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;블로그를 운영하다보니 조금씩 욕심이 생기는것 같다 ㅎㅎ &lt;a href=&quot;https://mishka.kr/2019/06/12/hexo-blog/&quot;&gt;Hexo를 이용해 github 블로그&lt;/a&gt;를 만들고 &lt;a href=&quot;https://mishka.kr/2019/06/11/Hexo-seo/&quot;&gt;SEO&lt;/a&gt;를
적용시켜보기도 하고 &lt;a href=&quot;https://mishka.kr/2019/07/02/hexo-comment-disqus/&quot;&gt;댓글 시스템&lt;/a&gt;도 연결하고 &lt;a href=&quot;https://mishka.kr/2019/07/29/hexo-post-setting/&quot;&gt;스타일&lt;/a&gt;도 조금씩 건들여보고 하다보니 결국에 나만의 도메인을 만들어서 연결해 보고 싶었다.  &lt;/p&gt;
&lt;p&gt;그래서 여러가지를 알아보다보니 Github 자체에서 Custom Domain을 간편하게 연결할수 있도록 해주고 있었다.&lt;br&gt;한편 살펴 볼까요? 기본적으로 Github를 통해서 정적페이지를 호스팅 하게되면 기본도메인이 주어집니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;USERNAME.github.io&lt;br&gt;그래서 저는 &lt;a href=&quot;mishka86.github.io&quot;&gt;mishka86.github.io&lt;/a&gt; 로 설정되었습니다. &lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>블로그를 운영하다보니 조금씩 욕심이 생기는것 같다 ㅎㅎ <a href="https://mishka.kr/2019/06/12/hexo-blog/">Hexo를 이용해 github 블로그</a>를 만들고 <a href="https://mishka.kr/2019/06/11/Hexo-seo/">SEO</a>를적용시켜보기도 하고 <a href="https://mishka.kr/2019/07/02/hexo-comment-disqus/">댓글 시스템</a>도 연결하고 <a href="https://mishka.kr/2019/07/29/hexo-post-setting/">스타일</a>도 조금씩 건들여보고 하다보니 결국에 나만의 도메인을 만들어서 연결해 보고 싶었다.  </p><p>그래서 여러가지를 알아보다보니 Github 자체에서 Custom Domain을 간편하게 연결할수 있도록 해주고 있었다.<br>한편 살펴 볼까요? 기본적으로 Github를 통해서 정적페이지를 호스팅 하게되면 기본도메인이 주어집니다.</p><blockquote><p>USERNAME.github.io<br>그래서 저는 <a href="mishka86.github.io">mishka86.github.io</a> 로 설정되었습니다. </p></blockquote><a id="more"></a><p>원하는 도메인을 연결하려면 원하시는 도메인 주소를 구입하신 후에 도메인 연결을 하시면 됩니다.<br>저는 <code>mishka.kr</code> 도메인을 <a href="https://www.hosting.kr/" rel="external nofollow noopener noreferrer" target="_blank">hosting.kr</a>을 통해서 구입했습니다.</p><h2 id="DNS-설정-방법"><a href="#DNS-설정-방법" class="headerlink" title="DNS 설정 방법"></a>DNS 설정 방법</h2><p>저는 hosting.kr 설정을 위주로 설명하겠지만 다른 도메인 서비스에서도 비슷한 루트로 변경이 가능 하니 참고하시기 바랍니다.<br>도메인의 네임서버를 변경해 주어야합니다. hosting.kr에서는 부가서비스로 구분이 되어있네요.<br>Home &gt; 도메인 &gt; 부가서비스 &gt; 네임서버 설정 관리 들어가서 github에서 요구 하는데로 변경을 시켜줍니다.</p><table><thead><tr><th align="center">Type</th><th align="center">서브 도메인</th><th align="center">IP주소 / 레코드 값</th></tr></thead><tbody><tr><td align="center">A Record</td><td align="center"></td><td align="center">185.199.108.153</td></tr><tr><td align="center">A Record</td><td align="center"></td><td align="center">185.199.109.153</td></tr><tr><td align="center">A Record</td><td align="center"></td><td align="center">185.199.110.153</td></tr><tr><td align="center">A Record</td><td align="center"></td><td align="center">185.199.111.153</td></tr><tr><td align="center">CName Record</td><td align="center">www</td><td align="center">USERNAME.github.io</td></tr></tbody></table><p>A Record는 Domain을 물리적인 IP 주소로 연결 할 수 있도록 합니다.<br>CName은 물리적인 IP 주소가 아닌 다른 Domain을 연결 합니다.</p><p>A Record의 경우 위에 것에서 하나를 선택해서 입력해 주면됩니다.<br><img src="/img/domain-setting.png" alt="네임서버 설정 관리"><br>저는 A Record와 CName을 위와 같이 세팅 해주었습니다.</p><h2 id="Github-Pages-설정"><a href="#Github-Pages-설정" class="headerlink" title="Github Pages 설정"></a>Github Pages 설정</h2><p>Github에서 블로그가 있는 Repository 로 이동합니다.<br>메뉴에서 Settings &gt; Options 에 <strong>Gihub Pages</strong> 항목에서<br>Costom domain 을 자신이 가지고 있는 도메인 주소로 변경하고 Save 버튼을 눌러줍니다.<br>HTTPS주소를 사용하시려면 하단에 Enfoce HTTPS 항목을 체크해 주시면 됩니다.</p><blockquote><p>2018년 5월 1일 <a href="https://github.blog/2018-05-01-github-pages-custom-domains-https/" rel="external nofollow noopener noreferrer" target="_blank">Github 공식 블로그</a> 에서 정식 지원 소식이 올라왔습니다.</p></blockquote><p><img src="/img/githubpage-setting.png" alt="Github Setting"><br>위와 같이 설정을 하면 이후에 USERNAME.github.io 로 접근되는 요청이 설정하신 도메인으로 Redirect 됩니다.<br>이렇게 설정을 하면 설정하신 도메인으로 정상적으로 노출이 됩니다.</p><p>이렇게 진행을 했는데 저는 문제가 한가지 발생했는데요 새롭게 블로그를 배포하면 Costom domain 설정이 날아가는거였습니다.<br>혹은 CName 파일이 정상적으로 생성되지 않은 경우도 발생할수도 있다고 하는데요 그럴 경우에 아래와 같은 해결법이 있습니다.</p><p>hexo의 CNAME 생성을 위한 패키지를 설치 합니다.<br> <figure class="highlight bash hljs"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure></p><p>그리고 <strong>_config.yml</strong> 파일에서 아래와 같이 플러그인 설정을 해줍니다.</p><figure class="highlight yaml hljs"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">plugins:</span> <span class="hljs-string">hexo-generator-cname</span></span><br></pre></td></tr></table></figure><p>그리고  <strong>_config.yml</strong> 에서 url 이름도 적용한 도메인과 같게 변경해 주세요.</p><figure class="highlight yaml hljs"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">url:</span> <span class="hljs-attr">https://mishka.kr</span></span><br></pre></td></tr></table></figure><p>이렇게 Github 블로그에 Custom Domain을 연결해 주었습니다. 여러분들도 자신만의 도메인을 연결해서 자신만의 블로그에 특징을 더해보세요.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.holaxprogramming.com/2017/05/15/github-page-and-custom-domain/" rel="external nofollow noopener noreferrer" target="_blank">https://www.holaxprogramming.com</a><br><a href="https://blog.chulgil.me/how-to-make-blog-using-github-3/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.chulgil.me</a><br><a href="https://blog.gaerae.com/2018/05/github-pages-custom-domains-https.html" rel="external nofollow noopener noreferrer" target="_blank">https://blog.gaerae.com</a></p>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/01/10/github-domain/#disqus_thread</comments>
    </item>
    
    <item>
      <title>클로저(closure)에 대하여</title>
      <link>https://mishka.kr/2020/01/04/closure/</link>
      <guid>https://mishka.kr/2020/01/04/closure/</guid>
      <pubDate>Sat, 04 Jan 2020 09:07:43 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;클로저의-의미&quot;&gt;&lt;a href=&quot;#클로저의-의미&quot; class=&quot;headerlink&quot; title=&quot;클로저의 의미&quot;&gt;&lt;/a&gt;클로저의 의미&lt;/h1&gt;&lt;p&gt;&lt;code&gt;클로저(closure)&lt;/code&gt;라는 영어단어의 사전적 의미는 ‘닫혀있음’, ‘폐쇄성’, ‘완결성’ 정도의 의미를 가집니다.&lt;br&gt;그렇다면 자바스크립트에서의 클로저는 무슨 의미를 가지고 있을까요? &lt;/p&gt;
&lt;p&gt;클로저(closure)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특징입니다.&lt;br&gt;자바스크립트에서만 사용하는 개념이 아니다 보니 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있다고 합니다.&lt;br&gt;다양한 서적에서 클로저를 정의하고 있는 문장들을 한번 살펴보겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;자신을 내포하는 함수의 컨텍스트에 접근 할 수 있는 함수 - &lt;small&gt;더글라스 크록포드, ‘자바스크립트 핵심 가이드’(한빛 미디어)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의 하는 것 - &lt;small&gt;에단 브라운, ‘러닝 자바스크립트’(한빛 미디어)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출 할 수 있는 함수 - &lt;small&gt;존 레식, ‘자바스크립트 닌자 비급’(인사이트)&lt;/small&gt; &lt;/li&gt;
&lt;li&gt;이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수 - &lt;small&gt;송현주, 고현준, ‘인사이드 자바스크립트’(한빛 미디어)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합 - &lt;small&gt;에릭 프리먼, ‘Head First Javascript Programing’(한빛 미디어)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;로컬 변수를 참조하고 있는 함수 내의 함수 - &lt;small&gt;야마다 요시히로, ‘자바스크립트 마스터 북’(제이펍)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수 - &lt;small&gt;유인동, ‘함수형 자바스크립트 프로그래밍’(인사이트)&lt;/small&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="클로저의-의미"><a href="#클로저의-의미" class="headerlink" title="클로저의 의미"></a>클로저의 의미</h1><p><code>클로저(closure)</code>라는 영어단어의 사전적 의미는 ‘닫혀있음’, ‘폐쇄성’, ‘완결성’ 정도의 의미를 가집니다.<br>그렇다면 자바스크립트에서의 클로저는 무슨 의미를 가지고 있을까요? </p><p>클로저(closure)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특징입니다.<br>자바스크립트에서만 사용하는 개념이 아니다 보니 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있다고 합니다.<br>다양한 서적에서 클로저를 정의하고 있는 문장들을 한번 살펴보겠습니다.</p><blockquote><ul><li>자신을 내포하는 함수의 컨텍스트에 접근 할 수 있는 함수 - <small>더글라스 크록포드, ‘자바스크립트 핵심 가이드’(한빛 미디어)</small></li><li>함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의 하는 것 - <small>에단 브라운, ‘러닝 자바스크립트’(한빛 미디어)</small></li><li>함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출 할 수 있는 함수 - <small>존 레식, ‘자바스크립트 닌자 비급’(인사이트)</small> </li><li>이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수 - <small>송현주, 고현준, ‘인사이드 자바스크립트’(한빛 미디어)</small></li><li>자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합 - <small>에릭 프리먼, ‘Head First Javascript Programing’(한빛 미디어)</small></li><li>로컬 변수를 참조하고 있는 함수 내의 함수 - <small>야마다 요시히로, ‘자바스크립트 마스터 북’(제이펍)</small></li><li>자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수 - <small>유인동, ‘함수형 자바스크립트 프로그래밍’(인사이트)</small></li></ul></blockquote><a id="more"></a><p>MDN 에서는 클로저에 대해</p><blockquote><p>“A closure is the combination of a function and the lexical environment within which that function was declared.”<br>직역해 보면<br><strong>“클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상”</strong> 정도가 되겠습니다.</p></blockquote><p>A함수 내부에서 B함수를 선언 했을 경우에<br>A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에서 선언한 변수에 접근 가능합니다.<br>내부 함수 B가 A의 lexical enviroment를 언제나 사용하는 것은 아닙니다. 내부함수에서 외부 변수를 <strong>참조하는 경우</strong>에 한해서만 사용 가능합니다.</p><p>간단하게 한번 정리해 보자면 <code>&quot;어떤 함수에서 선언한 변수를 참조하는 내부 함수에서만 발생하는 현상&quot;</code>이라고 볼 수 있겠습니다.</p><figure class="highlight javascript hljs"><figcaption><span>예제 1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span></span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(++a)</span><br><span class="line">  &#125;</span><br><span class="line">  inner()</span><br><span class="line">&#125;</span><br><span class="line">outer()</span><br><span class="line">outer()</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/mishka86/pen/gObXZpR" rel="external nofollow noopener noreferrer" target="_blank">코드펜 링크</a></p><p>실행순서를 살펴보면 outer 함수에서 변수 a를 선언했고, outer의 내부함수인 inner 함수에서 a의 값을 1만큼 증가시킨 다음 출력합니다.<br>inner 함수에서는 a를 선언하지 않았기 때문에 스코프체인을 타고 outer 함수에 접근해서 a를 찾습니다.<br>그리고 4번째 줄에서 2가 출력됩니다. outer 함수가 종료되면 저장된 식별자들(a, inner)에 대한 참조를 지웁니다.<br>그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 <code>가비지 컬렉터의 수집 대상</code>이 됩니다.<br>그래서 2를 3번 출력하게 됩니다.`</p><figure class="highlight javascript hljs"><figcaption><span>예제 2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span></span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> ++a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> outerFunc = outer()</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/mishka86/pen/WNbXLry" rel="external nofollow noopener noreferrer" target="_blank">코드펜 링크</a></p><p>위 예제를 살펴보면 inner함수의 실행 시점에는 outer함수는 이미 실행이 종료된 상태인데 outer함수의 Lexical environment에 접근할 수 있는 걸까요?<br>이는 <code>가비지 컬렉터의 동작 방식</code> 때문입니다. 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다.<br>그래서 예제를 보면 outer 함수는 실행 종료 시점에 inner 함수를 반환합니다.<br>외부 함수인 outer 의 실행이 종료되더라도 내부 함수인 inner 함수는 언젠가 outerFunc를 실행함으로써 호출될 가능성이 열린 겁니다.<br>언젠가 inner 함수의 실행 컨텍스트가 활성화되면 outer함수 a 의 값을 필요로 할것이므로 수집대상에서 제외됩니다.</p><p>예제1과 2의 다른점은 변수가 가비지 컬렉터에 포함 되었느냐 제외 되었느근냐 입니다.<br>함수의 실행 컨텍스트가 종료돈 후에도 lexical environment가 가비지 컬렉터의 수집대상에서 제외되는 경우는 지역변수를 참조하는 내부 함수가 외부로 전달된 경우가 유일합니다.<br>위 현상을 토대로 클로저의 정의를 다시 고쳐보자면 “어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상”이라고 할 수 있습니다.</p><p>외부로 전달하는 방법으로는 return 외에도 Window의 메서드(setTimeout 또는 setInterval), DOM의 메서드(addEventListener) 같은 경우도<br>지역변수를 참조하는 내부함수를 외부로 전달 했기 때문에 클로저라고 할 수 있습니다.</p><h1 id="클로저의-메모리-관리"><a href="#클로저의-메모리-관리" class="headerlink" title="클로저의 메모리 관리"></a>클로저의 메모리 관리</h1><p>클로저의 메모리 소모는 본질적인 특정일 뿐입니다. ‘메모리 누수’라는 표현은 개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC(Garbage Collector)의 수거 대상이 되지 않는 경우에는 맞는 표현이지만 개발자가 의도적으로 참조 카운트를 0이되지 않게 설계한 경우는 ‘누수’라고 할 수는 없습니다.<br>클로저의 메모리 관리 방법은 간단합니다.<br>클로저는 어떤 필요의 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다. 그러면 필요성이 사라진 시점에 메모리를 소모하지 않도록 해주면 됩니다. 참조 카운트를 0으로 만들면 GC가 수거 해가고 이때 소모됐던 메모리가 회수 됩니다.<br>참조 카운트를 0으로 만드는 방법은 식별자의 참조형이 아닌 기본형 데이터(null 이나 undefined)를 할당하면 됩니다.</p><figure class="highlight javascript hljs"><figcaption><span>예제 3 메모리 관리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span></span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> ++a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> outerFunc = outer()</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br><span class="line">outer = <span class="hljs-literal">null</span>  <span class="hljs-comment">// outer 식별자의 inner 함수 참조를 끊음</span></span><br></pre></td></tr></table></figure><h1 id="클로저-활용-사례"><a href="#클로저-활용-사례" class="headerlink" title="클로저 활용 사례"></a>클로저 활용 사례</h1><h2 id="콜백-함수와-클로저"><a href="#콜백-함수와-클로저" class="headerlink" title="콜백 함수와 클로저"></a>콜백 함수와 클로저</h2><p>콜백 함수 내부에서 외부변수를 참조하기 위한 방법으로 세가지가 있습니다.</p><ul><li>콜백 함수를 내부 함수로 선언해서 외부 변수를 직접 참조하는 방법으로 클로저를 사용하는 방법</li><li>bind 메서드로 값을 직접 넘겨줘서 클로저를 발생 시키지 않는 대신 여러가지 제약이 있는 방법</li><li>콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용한 방법</li></ul><h2 id="접근-권한-제어-정보은닉"><a href="#접근-권한-제어-정보은닉" class="headerlink" title="접근 권한 제어(정보은닉)"></a>접근 권한 제어(정보은닉)</h2><p>정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나 입니다.<br>흔희 접근 한에는 public, private, protected 의 세 종류가 있습니다.</p><ul><li>public은 외부에서 접근 가능한 것</li><li>private은 내부에서만 사용하며 외부에 노출되지 않는 것</li><li>protected는 상속받은 클래스 또는 같은 패키지에서만 접근이 가능한 것(java)</li></ul><p>자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직업 부여하도록 설계되어 있지 않습니다.<br>그렇다고 접근 제한이 불가능 한 것을 아닙니다. 클로저를 활용해서 함수차원에서 public한 값과 private 한 값을 구분하는 것이 가능합니다.</p><figure class="highlight javascript hljs"><figcaption><span>정보은닉</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> </span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> ++a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> outerFunc = outer()</span><br><span class="line"><span class="hljs-built_in">console</span>.log(outerFunc())</span><br></pre></td></tr></table></figure><p>outer 함수를 종료할 때 inner 함수를 반환함으로써 outer 함수의 지역변수인 a의 값을 외부에서도 읽을 수 있게 됐습니다.<br>외부에서는 outer라는 변수를 통해 outer함수를 실행 할 수는 있지만 outer함수 내부에는 어떤한 개입도 할 수 없습니다.<br>외부에서는 오직 outer함수가 return한 정보에만 접 할수 있습니다.<br>그러니까 외부에 제공하고자 하는 정보들을 모아서 return하고, 내부에서만 사용 할 정보들은 return 하지 않는 것으로 접근 권한 제어가 가능한것입니다.<br>return한 변수들은 공개맴버(public member) 가 되고, 그렇지 않는 변수들은 비공개 멤버(private member)가 되는 것입니다.</p><h2 id="부분-적용-함수-partially-applied-function"><a href="#부분-적용-함수-partially-applied-function" class="headerlink" title="부분 적용 함수 (partially applied function)"></a>부분 적용 함수 (partially applied function)</h2><p>부분 적용 함수란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가,<br>나중에 (n-m) 개의 인자를 넘기면 비로소 원래 함수의 실행 결과를 얻을 수 있게끔 하는 함수 입니다.</p><h2 id="커링-함수-currying-function"><a href="#커링-함수-currying-function" class="headerlink" title="커링 함수 (currying function)"></a>커링 함수 (currying function)</h2><p>커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말합니다.<br>부분 적용 함수와 다른 점은 커링은 한 번에 하나의 인자만 전달하는 것을 원칙으로 합니다. 또한 중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 할 뿐으로, 마지막 인자가 전달되기 전 까지는 원본 함수가 실행되지 않습니다(부분 적용 함수는 여러 개의 인자를 전달할 수 있고, 실행 결과를 재실행할때 원본 함수가 무조건 실행됩니다).</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>코어 자바스크립트 (위키북스)</li></ul>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/01/04/closure/#disqus_thread</comments>
    </item>
    
    <item>
      <title>실행 컨텍스트(execution context)</title>
      <link>https://mishka.kr/2020/01/02/execution_context/</link>
      <guid>https://mishka.kr/2020/01/02/execution_context/</guid>
      <pubDate>Thu, 02 Jan 2020 08:40:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;실행 컨텍스트(execution context)는 쉽게 보면 코드가 실행되고 있는 구역,범위에 대한 개념정도로 볼 수 있다.&lt;br&gt;실행 컨텍스트는 실행할 코드에 제공할 환경정보들을 모아놓은 객체이다.&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/%EC%96%B8%EC%96%B4_%EB%A6%AC%EC%86%8C%EC%8A%A4&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;ECMAScript&lt;/a&gt; 스펙에서는 실행 컨텍스트를 ‘실행 가능한 코드를 형상화하고 구분하는 추상적인 개념’이라고 정의 한다.&lt;/p&gt;
&lt;p&gt;자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러가지 정보들을 알고 있어야 한다고 한다. 실행에 필요한 정보들을 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티&lt;/li&gt;
&lt;li&gt;함수 선언&lt;/li&gt;
&lt;li&gt;변수의 유효범위(Scope)&lt;/li&gt;
&lt;li&gt;this&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>실행 컨텍스트(execution context)는 쉽게 보면 코드가 실행되고 있는 구역,범위에 대한 개념정도로 볼 수 있다.<br>실행 컨텍스트는 실행할 코드에 제공할 환경정보들을 모아놓은 객체이다.<br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/%EC%96%B8%EC%96%B4_%EB%A6%AC%EC%86%8C%EC%8A%A4" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript</a> 스펙에서는 실행 컨텍스트를 ‘실행 가능한 코드를 형상화하고 구분하는 추상적인 개념’이라고 정의 한다.</p><p>자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러가지 정보들을 알고 있어야 한다고 한다. 실행에 필요한 정보들을 아래와 같다.</p><blockquote><ul><li>변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티</li><li>함수 선언</li><li>변수의 유효범위(Scope)</li><li>this</li></ul></blockquote><a id="more"></a><p>코드를 실행하면 ‘전역 컨텍스트(Global execution Context)’가 생깁니다. 전역 컨텍스트는 브라우저가 종료 될 때까지 유지됩니다.<br>특정 ‘함수’안에서 실행되는 코드가 아니라면 코드는 전역 컨텍스트에서 실행됩니다.</p><p>함수가 호출 될때 해당 함수에 대한 실행 컨텍스트가 생성된다.(Functional Execution Context) 함수들은 각각 자신만의 실행 컨텍스트를 가지지만<br>이를 함수가 호출 되어야 만들어 집니다.</p><p>예제로 한번 보겠습니다.</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// (1)</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// undefined</span></span><br><span class="line">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// 3</span></span><br><span class="line">  &#125;    </span><br><span class="line">  inner()  <span class="hljs-comment">// (2)</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// 1  </span></span><br><span class="line">&#125;</span><br><span class="line">outer()  <span class="hljs-comment">//  (3)</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// 1</span></span><br></pre></td></tr></table></figure><p>위의 코드의 실행 순서를 따라가 보면 </p><ul><li>처음에 자바스크립트 코드를 실행하면(1) 전역 컨텍스트가 콜 스텍에 담깁니다.</li><li>순차적으로 코드를 읽다가 (3)에서 outer 함수를 호출하면 </li><li>outer함수에 대한 실행 컨텍스트를 생성한 후 콜 스텍에 담습니다. </li><li>콜 스텍에 새로운 컨텍스트가 놓인상태가 됐으므로 전역 컨텍스트와 관련된 코드 실행을 일시 중단하고 outer 함수에 대한 실행 컨텍스트를 실행합니다.</li><li>outer 함수 내부의 코드들을 순차로 실행합니다.</li><li>(2)에서 inner 함수가 호출되서 inner함수의 실행 컨켄스트가 콜 스택의 가장 위에 담기면</li><li>outer 컨텍스트와 관련되 코드의 실행을 중단하고</li><li>inner함수 내부의 코드를 순서대로 진행합니다.</li><li>inner함수 내부의 값을 출력하고 나면 inner함수의 실행이 종료되면서 inner  실행 컨텍스트가 콜 스택에서 제거됩니다.</li><li>inner컨텍스트의 의해 중단되었던 outer (2)줄 다음부터 실행됩니다.</li><li>a 변수 값을 출력하고 outer함수의 실행이 종료되며 outer실행 컨텍스트가 종료되며 콜 스택에서 제거됩니다.</li><li>중단되었던 전역 컨텍스트 (3)의 다음 줄부터 실행됩니다.</li><li>a 변수의 값이 출력되고 전역 컨텍스트도 콜 스택에서 제거 됩니다.</li></ul><p>스택구조를 잘 살펴보면 한 실행 컨텍스트가 콜 스택의 맨위에 쌓이는 순간이 곧 현재 실핼할 코드에 관여하게 되는 시점임을 알 수 있습니다.<br>기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치 할 수 밖에 없기 때문입니다. 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장합니다.</p><h2 id="실행-컨텍스트의-3가지-객체"><a href="#실행-컨텍스트의-3가지-객체" class="headerlink" title="실행 컨텍스트의 3가지 객체"></a>실행 컨텍스트의 3가지 객체</h2><p>실행 컨텍스트 자체는 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 가지며 3가지 프로퍼티를 가진다.</p><h3 id="Variavle-Object-VO-변수객체"><a href="#Variavle-Object-VO-변수객체" class="headerlink" title="Variavle Object (VO / 변수객체)"></a>Variavle Object (VO / 변수객체)</h3><p>변수, 매개변수, 인수정보, 함수 선언의 정보를 담고있는 객체<br>컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 정보를 수집<br>전역 실행 컨텍스트와 함수 실행 컨텍스트 일때 내용이 다르다<br>전역 컨텍스트의 경우 - 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Gloval Object / GO)<br>함수 컨텍스트의 경우 - Acrivation Object(AO / 활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고있는<br>arguments object가 추가됨</p><h3 id="호이스팅"><a href="#호이스팅" class="headerlink" title="호이스팅"></a>호이스팅</h3><p>변수를 선언하고 초기화 했을때 선언 부분이 코드의 최상단으로 끌어올려지는 현상.<br>선언부만 올라가므로 최기화 또는 대입 부분은 그대로 남아있음<br>함수 선언식의 경우에는 함수 전체가 통째로 끌어올려짐</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params">x</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">  <span class="hljs-keyword">var</span> x;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">  <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="hljs-number">1</span>)</span><br></pre></td></tr></table></figure><p>위의 코드를 호이스팅 개념처럼 변경하면</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> x;</span><br><span class="line">  <span class="hljs-keyword">var</span> x;</span><br><span class="line">  <span class="hljs-keyword">var</span> x;</span><br><span class="line">  </span><br><span class="line">  x = <span class="hljs-number">1</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">  x = <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>인자들과 함께 함수를 호출한 경우의 동작은 전달된 인자를 arguments object에 담는 것을 제외하면 코드내부에서 변수를 선언한 것과 다르지 않아서 함수 내부의 코드 최상단에서 선언 및 할당이 이뤄진것으로 간주하여 적용 </p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">  <span class="hljs-keyword">var</span> b = <span class="hljs-string">'bbb'</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>위의 코드를 호이스팅 개념처럼 변경하면</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> b;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">  b = <span class="hljs-string">'bbb'</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>함수 선언식의 경우는 식이 통째로 끌어올려지는것에 주의</p><h3 id="Scope-Chain-SC"><a href="#Scope-Chain-SC" class="headerlink" title="Scope Chain(SC)"></a>Scope Chain(SC)</h3><p>스코프 체인은 일종의 리스트, 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장<br>해당 전역 또는 함수가 참조 할 수 있는 변수, 함수 선언 등의 정보를 담고있는 전역 객체 또는 활성 객체의 리스트<br>현재 실행 컨텍스트의 활성 객체로 시작해서 순차적으로 상위 컨텍스트의 활성 객체를 가리키며 마지막에는 전역 객체를 가리킴<br>스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하며 스코프 체인은 식별자 중에서 변수를 검색하는 메커니즘</p><figure class="highlight javascript hljs"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> outer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  inner();</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">outer();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><h3 id="this-value"><a href="#this-value" class="headerlink" title="this value"></a>this value</h3><p>this 프로퍼티에는  this 값이 할당 됨<br>this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li>코어 자바스크립트 - 위키북스</li><li><a href="https://poiemaweb.com/js-execution-context" rel="external nofollow noopener noreferrer" target="_blank">https://poiemaweb.com/js-execution-context</a></li><li><a href="https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy" rel="external nofollow noopener noreferrer" target="_blank">https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy</a></li><li><a href="https://velog.io/@stampid/Execution-Context%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80" rel="external nofollow noopener noreferrer" target="_blank">https://velog.io/@stampid/Execution-Context%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80</a></li><li><a href="https://reinvint.tistory.com/6" rel="external nofollow noopener noreferrer" target="_blank">https://reinvint.tistory.com/6</a></li></ul>]]></content:encoded>
      
      <comments>https://mishka.kr/2020/01/02/execution_context/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1. 프로그레시브 프레임워크 Vue.js - part 2</title>
      <link>https://mishka.kr/2019/11/08/Vue-study-1.1/</link>
      <guid>https://mishka.kr/2019/11/08/Vue-study-1.1/</guid>
      <pubDate>Fri, 08 Nov 2019 09:11:05 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Vue-js-의-특징&quot;&gt;&lt;a href=&quot;#Vue-js-의-특징&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 의 특징&quot;&gt;&lt;/a&gt;Vue.js 의 특징&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Vue.js&lt;/code&gt;는 그 자체로는 뷰만을 다루는 단순한 라이브러리다. Vue.js 본체 뿐만 아니라 관련 라이브러리도 Vue.js 공식 프로젝트의 일부로서 개발 및 관리 된다. 이 때문에 몇가지 라이브러리를 조합하면 마치 종합적인 &lt;strong&gt;프레임워크&lt;/strong&gt;처럼 사용 할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;낮은-학습-비용&quot;&gt;&lt;a href=&quot;#낮은-학습-비용&quot; class=&quot;headerlink&quot; title=&quot;낮은 학습 비용&quot;&gt;&lt;/a&gt;낮은 학습 비용&lt;/h3&gt;&lt;p&gt;Vue.js 가 제공하는 API는 매운 단순하다. UI를 구성하는 데는 HTML을 기반으로 하는 평범한 템플릿을 사용한다. HTML이나 자바스크립트에 이미 익숙하면 Vue.js 에 대해 특별히 더 배우지 않고서도 라이브러리를 사용할 수 있다. 기본적인 사용만 한다면 빌드 도구나 패키징, EC2015 이후 문법에 대한 지식이 없어도 바로 동작하는 코드를 작성할 수 있다. Vue.js 는 앞서 언급한 모던 웹 프런트 엔드 개발의 어려움을 잘 극복했다. HTML5 이후 고도화된 개발 스타일에 부응하면서도 개발 환경 구축이 쉬워서 개발을 바로 시작할 수 있으며 자바스크립트에 대한 사전지식과 라이브러리 고유의 문법을 학습하지 않아도 라이브러리를 사용할 수 있다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Vue-js-의-특징"><a href="#Vue-js-의-특징" class="headerlink" title="Vue.js 의 특징"></a>Vue.js 의 특징</h2><p><code>Vue.js</code>는 그 자체로는 뷰만을 다루는 단순한 라이브러리다. Vue.js 본체 뿐만 아니라 관련 라이브러리도 Vue.js 공식 프로젝트의 일부로서 개발 및 관리 된다. 이 때문에 몇가지 라이브러리를 조합하면 마치 종합적인 <strong>프레임워크</strong>처럼 사용 할 수 있다.</p><h3 id="낮은-학습-비용"><a href="#낮은-학습-비용" class="headerlink" title="낮은 학습 비용"></a>낮은 학습 비용</h3><p>Vue.js 가 제공하는 API는 매운 단순하다. UI를 구성하는 데는 HTML을 기반으로 하는 평범한 템플릿을 사용한다. HTML이나 자바스크립트에 이미 익숙하면 Vue.js 에 대해 특별히 더 배우지 않고서도 라이브러리를 사용할 수 있다. 기본적인 사용만 한다면 빌드 도구나 패키징, EC2015 이후 문법에 대한 지식이 없어도 바로 동작하는 코드를 작성할 수 있다. Vue.js 는 앞서 언급한 모던 웹 프런트 엔드 개발의 어려움을 잘 극복했다. HTML5 이후 고도화된 개발 스타일에 부응하면서도 개발 환경 구축이 쉬워서 개발을 바로 시작할 수 있으며 자바스크립트에 대한 사전지식과 라이브러리 고유의 문법을 학습하지 않아도 라이브러리를 사용할 수 있다.</p><a id="more"></a><h3 id="컴포넌트-지향을-통한-UI-구조화"><a href="#컴포넌트-지향을-통한-UI-구조화" class="headerlink" title="컴포넌트 지향을 통한 UI 구조화"></a>컴포넌트 지향을 통한 UI 구조화</h3><p>Vue.js 는 구조화해 <code>컴포넌트로 재사용</code>할 수 있다. UI 구성 요소를 컴포넌트로 만들면 시스템 전체를 컴포넌트의 집합 형태로 개발 할 수 있다. 개발에 컴포넌트를 적용하면 컴포넌트 분리에서 오는 유지보수성 개선 및 컴포넌트 재사용 등 여러 장점이 있다.</p><h3 id="리액티브-데이터-바인딩"><a href="#리액티브-데이터-바인딩" class="headerlink" title="리액티브 데이터 바인딩"></a>리액티브 데이터 바인딩</h3><p>Vue.js 는 DOM요소와 <strong>리액티브 데이터 바인딩</strong>을 통해 자바스크립트 데이터를 연결해 준다. <code>리액티브 데이터 바인딩</code>이란 HTML 템플릿 안에서 대상 DOM 요소에 바인딩 을 지정해 Vue.js 가 해당 데이터의 변화를 감지할 때마다 바인딩된 DOM 요소에 표시되는 내용도 함께 업데이트하는 것을 말한다. 값은 자바스크립트에서 DOM요소로 일방적으로 전달된다. 이것을 <strong>단방향 바인딩</strong>이라고 한다. 자바스크립트쪽에서 위치한 데이터 값이 변경되면 변경된 값이 웹 페이지에도 자동으로 반영되는 기능이다. input 요소등 사용자의 입력을 받는 DOM요소는 요소에서 받아온 데이터와 자바스크립트 데이터를 서로동기화하는 바인딩을 지정한다. 이런 경우 자바스크립트의 데이터 값이 변경될때마다 DOM요소의 표시 내용이 수정되며, 사용자의 입력이 감지될때마다 자바스크립트 데이터가 수정된다. 이런 방법으로 자바스크립트 데이터와 DOM요소 데이터의 동기화 상태를 유지한다. 이 방법은 자바스크립트와 DOM요소가 서로 최신 데이터를 주고받으므로 양방향 바인딩이라고 한다. 바인딩을 이용함으로써 귀찮은 표시 내용 업데이트 처리와 DOM 요소와 자바스크립트 간 데이터 동기화 상태 유지로부터 해당됐으며 데이터 중심 웹 애플리케이션 설계 및 구현이 가능해졌다.</p><h2 id="Vue-js의-설계사상"><a href="#Vue-js의-설계사상" class="headerlink" title="Vue.js의 설계사상"></a>Vue.js의 설계사상</h2><p>Vue.js는 사용성 면에서도 뛰어난 라이브러리지만, 성능적인 측면을 비롯해 다른 장점도 많은 라이브러리다. 그러나 이와 비슷한 장점이 많은 라이브러리도 있다. Vue.js 가 이런 다른 라이브러리와 분명이 차별화 되는 점이 있다. 바로 밑바탕이 되는 설계사상이다. Vue.js의 설계 밑 바탕에는 <code>프로그래시브 프레임워크(Progressive framework)</code> 라는 아이디어가 깔려있다.<br>‘프레임워크는 어떤 경우든지 규모와 상관없이 단계적으로 유연하게 사용할 수 있어야 한다.’ 라고 Vue.js를 만든 에반유가 처음 주창했다.</p><h3 id="프레임워크의-복잡성"><a href="#프레임워크의-복잡성" class="headerlink" title="프레임워크의 복잡성"></a>프레임워크의 복잡성</h3><p>웹 프런트 엔트 분야에는 React와 Angular 등 라이브러리와 프레임워크가 여러 가지 있다. 프레임워크는 애플리케이션 개발의 복잡성을 해소해주는 도구다. 그러나 애플리케이션과 마찬가지로 프레임워크에도 프레임워크 자체의 복잡성이 있다. 프레임워크라는 도구를 사용하려면 도구 자체의 복잡성에서 오는 비용과 애플리케이션 개발의 복잡성에서 오는 비용이 균형을 이루도록 적합한 프레임워크를 선택하는 것이 중요하다.</p><h3 id="요구-사항의-변화를-수용할수-있는-프레임워크"><a href="#요구-사항의-변화를-수용할수-있는-프레임워크" class="headerlink" title="요구 사항의 변화를 수용할수 있는 프레임워크"></a>요구 사항의 변화를 수용할수 있는 프레임워크</h3><p>사이트 및 애플리케이션의 요규사항은 끊임없이 변화한다. 프레임워크도 이렇게 변화하는 요구사항에 맞춰 가치를 제공하려면 그만큼 유연하지 않으면 안 된다. 애플리케이션이 최초 완성되고 나면 변화하는 요구사항에 대응하기 위해 애플리케이션의 규모가 지족해서 커지게 마련이다. 대부분 애플리케이션 개발을 지원하는 라이브러리나 도구를 추가로 도입해 새로운 비즈니스 요구사항을 만족시키게 된다. 그러나 이렇게 새로운 요소를 덧붙이는 방법은 생각대로 되지 않는 경우가 많다. 웹 프런트엔드 생태계는 최근 끊임없이 변화하고 있기 때문에 애플리케이션에 도입한 프레임워크나 개발 환경이 얼마 지나지 않아 시대에 뒤떨어지게 되고 다시 어떤 프레임워크로 갈아타야 하는지조차 알 수 없는 상황에 직면하게 된다. 이런 상황에 대처하려면 요구 사항 변과에 단계적으로 대응해야 한다. 이러한 아이디어를 반영한 것이 바로 프로그래시브 프레임워크다. 프로그래시브 프레임워크는 무제를 해결할 수 있는 적합한 라이브러리를 적시에 도입해 문제를 해결한다. Vue.js는 <strong>뷰 계층에 초점을 맞춘 라이브러리</strong>다. Vue.js 프로젝트가 제공하는 부가적인 라이브러리와 개발환경 도구를 사용하면 프로그래시브 프레임워크가 된다.</p><h2 id="프로그레시브-프레임워크가-제공하는-단계적-영역"><a href="#프로그레시브-프레임워크가-제공하는-단계적-영역" class="headerlink" title="프로그레시브 프레임워크가 제공하는 단계적 영역"></a>프로그레시브 프레임워크가 제공하는 단계적 영역</h2><h3 id="선언적-렌더링"><a href="#선언적-렌더링" class="headerlink" title="선언적 렌더링"></a>선언적 렌더링</h3><p>이 영역은 선언적 DOM 렌더링과 관련된 영역이다. HTML 템플릿에 렌더링 대상을 선언적으로 기술해 데이터가 변경될 때마다 DOM을 반응적으로 렌더링하고 사용자 입력 데이터를 동기화 할 수 있다,<br>Vue.js 본체가 제공하는 기능이다.</p><h3 id="컴포넌트-시스템"><a href="#컴포넌트-시스템" class="headerlink" title="컴포넌트 시스템"></a>컴포넌트 시스템</h3><p>UI를 모듈화해 재사용할수 있게 해주는 영역 이 영역 역시 UI 를 컴포넌트로 만들어주는 Vue.js 본체가 제공하는 기능이다.</p><h3 id="클라이언트-사이드-라우팅"><a href="#클라이언트-사이드-라우팅" class="headerlink" title="클라이언트 사이드 라우팅"></a>클라이언트 사이드 라우팅</h3><p>단일 페이지 애플리케이션이 동작하기 위해 필요한 영역이다. 라우팅이란 간단히 말해 애플리케이션의 URL 설계, 지시와 같은 것이다. Vue.js의 공식 라우팅 라이브러리인 Vue Router를 사용하면 기존에 개발한 컴포넌트로 당일 페이지 애플리케이션을 만들 수 있다.</p><h3 id="대규모-상태관리"><a href="#대규모-상태관리" class="headerlink" title="대규모 상태관리"></a>대규모 상태관리</h3><p>컴포넌트 간에 상태를 고유하는 방법을 필요로 하는 영역이다. Vue.js의 공식 데이터플로 아키텍처를 따라 만든 상태관리 라이브러리인 VUEX 를 사용하면 이 영역의 문제를 해결할 수 있다, 기존 컴포넌트를 확장하는 형태로 상태를 중앙에서 관리 할 수 있다.</p><h3 id="빌드시스템"><a href="#빌드시스템" class="headerlink" title="빌드시스템"></a>빌드시스템</h3><p>웹 애플리케이션을 구성하는 컴포넌트 관리, 운영환경배포, 프로젝트 구성등과 관련된 영역이다. Vue.js의 공식 개발지원 도구를 이용해 이 영역의 문제를 해결할 수 있다, 프로젝트의 환경구축, 구성관리에 수고를 들이는 대신 개발에 집중할 수 있다. (Vue Cli)</p><h3 id="클라이언트-서버데이터-퍼시스턴스"><a href="#클라이언트-서버데이터-퍼시스턴스" class="headerlink" title="클라이언트-서버데이터 퍼시스턴스"></a>클라이언트-서버데이터 퍼시스턴스</h3><p>웹애프리케이션의 복잡한 데이터는 클라이언트 사이드와 서버사이트 양쪽 모두에서 퍼시스턴스 데이터로 유지돼야 한다. 이 책을 쓰는 시점에는 이러한 분야의 문제를 해결해 주는 Vue.js공식 라이브러리가 아직 없으며 서드파티 라이브러리 사용자들이 직접 작성한 라이브러리를 사용해 구현한다.</p><h2 id="Vue-js의-기반-기술"><a href="#Vue-js의-기반-기술" class="headerlink" title="Vue.js의 기반 기술"></a>Vue.js의 기반 기술</h2><h3 id="컴포넌트-시스템-1"><a href="#컴포넌트-시스템-1" class="headerlink" title="컴포넌트 시스템"></a>컴포넌트 시스템</h3><p>Vue.js는 컴포넌트를 쉽게 다루기 위한 라이브러리다. 컴포넌트 시스템에서 특기할 만한 기능은 단일 파일 컴포넌트다. Vue.js는 단일 파일에 HTML과 유사한 방식으로 컴포넌트를 작성할 수 있다. 이 파일은 .vue라는 독자적인 확장자를 사용한다. Vue.js 컴포넌트는 기존 웹 표준을 구성하는 기술과 유사한 형태로 정의되기 때문에 학습비용이 매우 낮은것이 특정이다. 파일하나에 컴포넌트의 모든 요소를 함께 담을 수 있다는 점은 큰 장점이다. 컴포넌트의 요점은 언어의 역할과는 별도로 기능이나 관심사를 기준으로 코드를 분리하는 것이기 때문이다. 하나의 관심사만을 같은 GUI 컴포넌트를 분리하려고 할때 HTML/CSS/JavaScript 3가지 요소를 하나의 파일로 합쳐 컴포넌트로 분리 할 수 있으므로 이해하기 쉽다.</p><h3 id="리액티브-시스템"><a href="#리액티브-시스템" class="headerlink" title="리액티브 시스템"></a>리액티브 시스템</h3><p>Vue.js의 리액티브 시스템은 옵저버 패턴을 기반으로 구현 좀더 쉽게 셜명하면 상태의 변화를 Vue.js가 감지해 자동으로 그 변화를 DOM에 반영하는 구조라고 할 수 있다. DOM 을 더욱 정교하고 잦은 비도로 조작해야 하는 애플리케이션에서는 데이터 바인딩이 매우 유용하다. 라이브러리에 이러한 기능이 없다면 값의 변화에 따라 변화해야 하는 곳을 직접 변경하거나 갑의 변경에 따른 사이드 이펙트를 완전히 파악하지 못하고 임시변통으로 틀어막게 되기 쉽다. 뒤에 설명할 계산 프로퍼티는 이러한 리액티브 시스템 덕을 가장 크게보는 사례다. 계산 프로퍼티란 값의 변화를 탐지해 자동으로 업데이트 되는 프로퍼티를 말한다. Vue.js 템플릿에서 빼놓을 수 없는 기능이다. 리액티브 시트템은 리액티브 프로퍼티와 와처가 한 쌍을 이뤄 구현된다.</p><h3 id="리액티브-시스템의-내부"><a href="#리액티브-시스템의-내부" class="headerlink" title="리액티브 시스템의 내부"></a>리액티브 시스템의 내부</h3><p>계산프로퍼티에서는 와처 내부의 게터가 계산 프로터티로 정의하는 함수 역할을 한다. 계산프로퍼티를 처음 참조하면 와처내부에 잇는 게터를 거쳐 리액티브 프ㄹ퍼티의 계산 결과가 와처에 캐싱되며 이와 함께 리액티브 프로퍼티의 의존관계 추적도 완료된다. 그 다음 이 계산 프로퍼티가 다시 참조될 때는 캐싱된 값을 반환해 계산 비용을 절약할 수 있다, 이후에 계산 프로퍼티에서 이 값이 의존하는 리액티브 프로퍼티의 일부가 대입 등의 이유로 변경되면 후크 처리를 통해 와처에 이 변경이 통지되면 내부 게터가 이 통지를 전달받아 프로퍼티 값을 다시 계산해 그 결과가 와처에 새로 캐싱된다. 반면 컴포넌트 렌더링에서는 와처 내부의 게터가 컴포넌트를 렌더링하는 함수 역할을 한다. 모든 컴포넌트가 와처를 갖고 있기 때문에 컴포넌트의 모든 데이터를 래액티브 프로퍼티로 모니터링 한다. 컴포넌트 렌더링은 모니터링 대상 중 어떤 리액티브 프로퍼티가 값이 변경됐다는 통지를 보내면 그때마다 와처의 게터가 실행돼 컴포넌트가 렌더링되는 구조다.</p><h3 id="렌더링시스템"><a href="#렌더링시스템" class="headerlink" title="렌더링시스템"></a>렌더링시스템</h3><p>Vue.js는 가장 DOM을 이용해 DOM을 고속으로 렌더링한다. 가상 DOM은 DOM을 간편하고 빠르게 제어하기 위한 기술이다. 더 편리하고 빠르게 다룰 수 있는 DOM 구조의 대체물을 만든 다음 이 대체물을 조작하고 그 결과를 실제 DOM에 반영한다. 다른라이브러리와 다른 점은 템플릿이 HTML과 유사해 개발이 쉽고 최적화가 잘 돼 있어 빠른 렌더링이 가능하다는 점이다.</p><h2 id="Vue-js의-생태계"><a href="#Vue-js의-생태계" class="headerlink" title="Vue.js의 생태계"></a>Vue.js의 생태계</h2><p>Vue.js는 뷰 계층에 초점을 맞춘 라이브러리이므로 엄밀히 말해 프레임워크는 아니다. 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능처럼 UI외적인 기능을 이용하는 웹애플리케이션을 개발하려면 추가 라이브러리가 필요하다. 웹애플리케이션 테스트 및 빌드, 개발 환경역시 직접 구축하지 않으면 안 된다.</p><ul><li>Vue Router : 단일 페이지 애플리케이션을 구현하기 위한 라우팅 기능을 제공하는 플러그인</li><li>Vuex : 대규모 웹 애플리케이션을 구축하기 위한 상태 관리 플러그인</li><li>Vue Loader : 컴포넌트의 고급 기능을 이용하기 위한 webpack 용 로더 라이브러리</li><li>Vue CLI : 웹 애플리케이션을 구축하기 위한 템플릿 프로젝트 생성 및 프로토타입을 추가 설정없이 빌드하기 위한 명령해</li><li>Vue DevToolls : Vue.js 애플리케이션을 브라우저의 개발자 도구로 디버깅할 수 있게 해주는 도구</li><li>Nuxt.js : 단일 페이지 애플리케이션과 서버 사이드 렌더링을 지원하는 Vue.js 애플리케이션을 개발하기 위한 프레임워크</li><li>Weex : Vue.js 문법을 사용해 IOS 및 안드로이드 애플리케이션을 개발할 수 있는 프레임워크</li><li>Onsen UI : 모바일 웹 애플리케이션을 개발하기 위한 프레임워크</li></ul><p>커뮤니티에서 추천 플러그인, 라이브러리, 도구 등의 정보를 얻을 수 있다.</p><ul><li>Awesome Vue : Vue.js와 관련된 오픈 소스 프로젝트나 Vue.js가 사용된 웹 사이트 및 애플리케이션 정보를 공유하는 사이트</li><li>Vue Curated : Vue.js 코어 팀에서 엄선한 플러그인, 라이브러리, 프레임워크 등을 검색 할수 있는 공식 사이트</li></ul><h2 id="Vue-js-첫걸음"><a href="#Vue-js-첫걸음" class="headerlink" title="Vue.js 첫걸음"></a>Vue.js 첫걸음</h2><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">DOCTYPE</span> <span class="hljs-attr">html</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue.js 시작하기<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">“https://unpkg.comvue@2.5.17”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">“app”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-javascript">  <span class="hljs-keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="hljs-xml">    template: ‘<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>’,</span></span><br><span class="line">    data : &#123; msg: ‘hello world!’ &#125;</span><br><span class="line">  &#125;).$mount(‘app’)</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Vue.js 참조문서 - 공식사이트 참고(<a href="https://vuejs.org" rel="external nofollow noopener noreferrer" target="_blank">https://vuejs.org</a>)</li><li>Vue.js 사용자 커뮤니티</li><li>Vue.js 포럼 : Vue.js 를 사용하다가 발생하는 트러블이나 질문 사항을 논의하는 사이트</li><li>Vue Land : Vue.js 사용자와 코어 팀 멤버 및 컨트리뷰터가 채팅을 커뮤니케이션 하는 커뮤니티</li><li>Vue.js 밋업 : 한국 Vue.js 사용자들이 Vue.js 지식과 정보를 공유하는 밋업 이벤트</li></ul>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/11/08/Vue-study-1.1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1. 프로그레시브 프레임워크 Vue.js - part 1</title>
      <link>https://mishka.kr/2019/11/08/Vue-study-1/</link>
      <guid>https://mishka.kr/2019/11/08/Vue-study-1/</guid>
      <pubDate>Fri, 08 Nov 2019 08:48:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;Vue.js 철저입문&lt;/strong&gt; 책을 읽으면서 간단하게 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;Vue.js는 &lt;strong&gt;뷰 레이어에 특화&lt;/strong&gt;된 라이브러리이다. &lt;strong&gt;MVVM패턴&lt;/strong&gt;의 영향을 받은 설계를 채택하고 있어서 대규모 애플리케이션 개발에도 사용할 수 있습니다. 이러한 특징은 애플리케이션의 규모와 상관없이 어떠한 경우에도 단계적으로 유연한 적용이 가능해지는 &lt;code&gt;프로그래시브 프레임워크&lt;/code&gt;라는 Vue.js의 설계사상에서 기인한다고 한다. 이 설계사상으로 인해 프로젝트 초기에는 최소한의 학습비용만으로 시험 적용이 가능하며 대규모 시스템에서는 단계적으로 필요한 기능및 라이브러리를 조합해 덧붙여 가는 독특한 스타일의 개발이 가능하다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>Vue.js 철저입문</strong> 책을 읽으면서 간단하게 정리해 보고자 한다.</p><p>Vue.js는 <strong>뷰 레이어에 특화</strong>된 라이브러리이다. <strong>MVVM패턴</strong>의 영향을 받은 설계를 채택하고 있어서 대규모 애플리케이션 개발에도 사용할 수 있습니다. 이러한 특징은 애플리케이션의 규모와 상관없이 어떠한 경우에도 단계적으로 유연한 적용이 가능해지는 <code>프로그래시브 프레임워크</code>라는 Vue.js의 설계사상에서 기인한다고 한다. 이 설계사상으로 인해 프로젝트 초기에는 최소한의 학습비용만으로 시험 적용이 가능하며 대규모 시스템에서는 단계적으로 필요한 기능및 라이브러리를 조합해 덧붙여 가는 독특한 스타일의 개발이 가능하다.</p><a id="more"></a><h2 id="Vue-js의-역사"><a href="#Vue-js의-역사" class="headerlink" title="Vue.js의 역사"></a>Vue.js의 역사</h2><p>Vue.js는 2013년 <code>에반유(Evan You)</code>가 시작한 개인 프로젝트로 출발</p><blockquote><ul><li>2014년 2월 <strong>V0.8</strong>이 정식발표</li><li>2015년 5월에 PHP웹 애플리케이션 프레임워크인 <strong>라라벨</strong>에 표준 탑재된 것을 계기로 라라벨 커뮤니티에서 화제</li><li>2015년 10월 <strong>V1.0</strong>이 출시</li><li>2016년 10월 1일 <strong>V2.0</strong>이 출시</li></ul></blockquote><h2 id="복잡해진-모던-웹-프론트엔드-개발"><a href="#복잡해진-모던-웹-프론트엔드-개발" class="headerlink" title="복잡해진 모던 웹 프론트엔드 개발"></a>복잡해진 모던 웹 프론트엔드 개발</h2><p>모던 웹 프로트엔드 개발은 크게 고도화 되고 <code>단일 페이지 애플리케이션(SPA)</code>을 중심으로 프런트엔드 에서 복잡한 처리를 맡는 경우가 늘었으며 애플리케이션 데이터플로 설계, 라우팅, 유효성 체크 등 기존에는 백 엔드에서 맡았던 역할을 프런트 엔드가 맡게 됐다. 자바스크립트 역시 최근 몇년 사이 용도가 급격히 늘어났다. 이와 함께 업무와 관련된 개념과 도구가 함께 복잡해지는 경향을 보였다.</p><h2 id="웹-탄생과-웹-기반-시스템의-발전"><a href="#웹-탄생과-웹-기반-시스템의-발전" class="headerlink" title="웹 탄생과 웹 기반 시스템의 발전"></a>웹 탄생과 웹 기반 시스템의 발전</h2><p>웹(World Wide Web)은 지금부터 20년도 더 전인 <strong>1991년</strong>에 인터넷상에 처음 등장. 탄생 초기에는 문서 열람만을 목적으로 했으므로 당연히 지금 사용하는 SNS나 스프레드시트 같은 인터렉티브한 콘텐츠 는 구현이 불가능 했다. 1990년 후반부터 CSS와 자바스크립트가 웹 브라우저에 탑재됐다. 당시의 자바스크립트는 매우 빈약해 CSS와 함께 문서를 꾸미는 용도에 주로 사용 됐다. 비록 제약은 많았지만. 이들의 등장으로 웹페이지를 GUI 애플리케이션처럼 꾸밀 수 있게 됐다.</p><ul><li>CGI(Common Gateway Interface)로 대표되는 웹에서 사용되는 서버 사이드 프로그래밍 기술이 등장</li><li>웹 브라우저를 프리젠테이션 계층으로 삼는 웹기반 3계층 아키텍처 시스템이 등장</li><li>루비 온 레이즈로 대표되는 MVC기반 웹애플리케이션 프레임워크도 등장</li></ul><p>당시 프런트엔드가 담당했던 기능은 css등을 이용한 시작적효과와 자바스크립트를 이용한 알림창, 입력을 받는 기능 정도가 고작이었다.</p><h2 id="Ajax의-등장"><a href="#Ajax의-등장" class="headerlink" title="Ajax의 등장"></a>Ajax의 등장</h2><p>프런트엔드의 기능은 보여주는 것에만 한정된다는 것이 상식이었던 적이 있다. 그러나 2005년에 구글이 지도 서비스 구글맵스를 출시하면서 이러한 상식이 뒤집어졌다. 같은 페이지 안에서 콘텐츠를 빠르고 인터랙티브하게 변화시키는 경쾌한 사용자 경험이 <strong>Ajax</strong>를 통해 가능해졌다. Ajax 의 등장 이후 클라이언트 사이드에서는 Ajax및 이를 이용한 DOM을 정교하게 조작하는 기능이 필요해졌다.</p><ul><li>필요에 따라 등장한 <strong>jQuery</strong>등이 인기를 얻었다.</li><li>서버사이드 분야는 웹서버가 HTML 렌더링을 넘어 <strong>RESTful 기반</strong> 웹API 를 제공하게 됐다.</li><li>2000년대 말에는 <strong>HTML5</strong>와 <strong>ECMAScript</strong>를 중심으로 웹이 다시 크게 진화</li><li><strong>Node.js</strong>가 등장하면서 웹프런트엔드 개발이 한층 복잡해졌다.</li></ul><h2 id="HTML5의-등장"><a href="#HTML5의-등장" class="headerlink" title="HTML5의 등장"></a>HTML5의 등장</h2><p>HTML5는 2014년에 권고안이 나온 표준규격이다.<br>그중 중요한 것은 <code>Histrory API</code> 인데 덕분에 페이지이동을 웹브라우저대신 자바스크립트로 핸들링할 수 있게 됐다. 이를 통해 화면이동없이 URL과 히스토리를 관리하며 전환할 수 있는 단일 페이지 애플리케이션을 만들수 있게 됐다. 이러한 변화에 따라 프리젠테이션 레이어의 프로그램이 서버사이드 에서 클라이언트 사이드로 옮겨오게 된다. 기존에는 HTML렌더링을 서버에서 수행했지만, 웹 API로 데이터를 받아올수 있게 되면서 클라이언트에서도 HTML 렌더링이 가능해졌기 때문이다. 이런 방식이 화면이동이 적기 때문에 더 뛰어난 사용자 경험을 제공할 수 있다.</p><h2 id="Node-js-와-자바스크립트-생태계의-진화"><a href="#Node-js-와-자바스크립트-생태계의-진화" class="headerlink" title="Node.js 와 자바스크립트 생태계의 진화"></a>Node.js 와 자바스크립트 생태계의 진화</h2><p>2009년 에는 <strong>Node.js</strong> 가 등장</p><ul><li>첫번째 변화는 자바스크립트 실행환경이 브라우저를 벗어난 것이다. Node.js 는 프런트엔드 개발과 테스트에 매우 유용한 환경이다.</li><li>두번째 변화는 패키지 관리자이자 패키지 리포지토리인 <strong>npm</strong>의 보급이다.</li></ul><p>이에 따라 모듈(패키지)을 사용할수 있게 됐고 개발된 산출물을 다시 모듈화해 npm을 통해 배포하는 문화가 정착했다.</p><h2 id="ES2015-와-프로그래밍-언어로서의-진화"><a href="#ES2015-와-프로그래밍-언어로서의-진화" class="headerlink" title="ES2015 와 프로그래밍 언어로서의 진화"></a>ES2015 와 프로그래밍 언어로서의 진화</h2><p>웹 프런트엔드 개발이 고도화되던 와중에 문제가 된것이 자바스크립트의 빈약한 언어 기능이었다. 그래서 대대적인 규격 업데이트가 필요 했고 이에 <code>ES2015(ES6)</code> 가 등장했다.<br>ES2015 는 자바스크립트 역사상 가장 큰 규모의 업데이트였다. 문법이 확장되고 <code>const</code>나 <code>let</code>등이 널리 쓰이게 되는 등 작성스타일에도 대대적인 변화가 있었다. 표준규격이 제안 됐다고 해서 곧바로 모든 브라우저에 구현이 적용되지는 않는다. 그러나 새로운 규격에는 기존의 불만을 해소할수 잇는 매력적인 것들이 많았고 그래서 이러한 규격을 브라우저에 구현해 사용하려는 움직임이 있었다.<br><strong>Babel</strong> 은 이러한 수요에 대응해 자바스크립트를 자바스크립트로 번역하는 컴파일러다. 차세대 문법을 따른 자바스크립트 코드를 아직 해당 규격이 구현되지 않은 브라우저에서 사용할 수 있는 자바스크립트 코드로 변화하는 것이다.</p><h2 id="React등-프런트엔드-라이브러리의-출현"><a href="#React등-프런트엔드-라이브러리의-출현" class="headerlink" title="React등 프런트엔드 라이브러리의 출현"></a>React등 프런트엔드 라이브러리의 출현</h2><p>애플리케이션 데이터플로를 프런트엔드로 가져오는 등 설계 단계부터 개발 난이도를 상승시키는 것이 많았다. DOM을 웹 API와 연동시키는 것도 생각 없이 할수 있는 일이 아니다.<br>애플리케이션을 구조화 할수 없는 jQury등을 사용해서는 구현하기가 어렵다 그러므로 MVC와 같은 애플리케이션구조를 지원하는 프레임워크가 필요해졌다. 그에따라 <strong>Backbone.js</strong>, <strong>AngularJS</strong>등 새로운 웹 애플리케이션 프레임워크 및 라이브러리가 속속 나타났다. 이런 상황에서 나타난 것이 페이스북이 개발한 <strong>React</strong>와 <strong>Flux</strong> 다.<br><code>React</code>는 뷰 라이브러리이고, <code>Flux</code>는 애플리케이션 아키텍처다. React 중심의 개발 스타일은 <strong>가상 DOM</strong>을 이용해 DOM 조작을 빠르게 수행했고, Flux 는 혼란스러워지기 쉬운 아케텍처에 방향을 제시해 큰 인기를 모았다.</p><h2 id="현재-당면과제와-Vue-js"><a href="#현재-당면과제와-Vue-js" class="headerlink" title="현재 당면과제와 Vue.js"></a>현재 당면과제와 Vue.js</h2><p>모던 프런트 엔드 개발은 현재에 이르기까지 다음과 같은 변화와 새로운 문제점을 낳았다.</p><ul><li>HTML5 이후 웹이 애플리케이션 플랫폼으로 기능하게 되면서 API가 고도화 됨</li><li>Node.js 생태계의 발전과 개발 환경 구축의 난이도 증가</li><li>ES2015 이후 문법이 보강되면서 학습할 내용이 증가</li><li>React 이후 프런트 엔드 개발이 프레임워크화되면서 그에 따른 학습비용증가</li></ul><p>정리하다보니 모던 프론트엔드 개발의 역사와 같이 나와있어서 생각보다 정리해야될 내용이 많았다.<br>그래서 2파트로 나누어서 정리하기로 했다.</p>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/11/08/Vue-study-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Github SSH key 생성 및 적용하기</title>
      <link>https://mishka.kr/2019/10/18/ssh-setting/</link>
      <guid>https://mishka.kr/2019/10/18/ssh-setting/</guid>
      <pubDate>Fri, 18 Oct 2019 06:56:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;많은 Git 서버들은 SSH 공개키로 인증을 합니다. 또한 Github 연결시마다 계정정보를 입력해야 하는 번거로운을 제거해 준다. 이번에 입사한 회사에서도 서버에서 SSH를 사용해서 인증하는 시스템을 가지고 있어서 이 기회에 세팅을하면서 적용방법을 정리해 보았다.&lt;/p&gt;
&lt;h2 id=&quot;SSH-공개키-생성&quot;&gt;&lt;a href=&quot;#SSH-공개키-생성&quot; class=&quot;headerlink&quot; title=&quot;SSH 공개키 생성&quot;&gt;&lt;/a&gt;SSH 공개키 생성&lt;/h2&gt;&lt;p&gt;일단 공개키를 사용하려면 공개키를 만들어야 한다. 그 전에 공개키가 있는지 확인이 필요하다. 기본적으로 사용자의 SSH키들은 사용자의 &lt;code&gt;~/.ssh&lt;/code&gt; 디텍토리에 저장한다. 디텍토리의 파일을 살펴서 공개키가 있는지 확인 할 수 있다. &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>많은 Git 서버들은 SSH 공개키로 인증을 합니다. 또한 Github 연결시마다 계정정보를 입력해야 하는 번거로운을 제거해 준다. 이번에 입사한 회사에서도 서버에서 SSH를 사용해서 인증하는 시스템을 가지고 있어서 이 기회에 세팅을하면서 적용방법을 정리해 보았다.</p><h2 id="SSH-공개키-생성"><a href="#SSH-공개키-생성" class="headerlink" title="SSH 공개키 생성"></a>SSH 공개키 생성</h2><p>일단 공개키를 사용하려면 공개키를 만들어야 한다. 그 전에 공개키가 있는지 확인이 필요하다. 기본적으로 사용자의 SSH키들은 사용자의 <code>~/.ssh</code> 디텍토리에 저장한다. 디텍토리의 파일을 살펴서 공개키가 있는지 확인 할 수 있다. </p><a id="more"></a><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">cd</span> ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>보통 <code>id_dsa</code>나 <code>id_rsa</code>라고 되어 있다. 그 중 <code>.pub</code> 파일이 <strong>공개키</strong>이고 다른 파일은 <strong>개인키</strong> 입니다.<br>이 파일이 없거나 .ssh 디텍토리가 없으면 <code>ssh-keygen</code> 프로그램으로 키를 생성하여 준다.</p><h3 id="터미널-실행하여-다음-명령어를-실행"><a href="#터미널-실행하여-다음-명령어를-실행" class="headerlink" title="터미널 실행하여 다음 명령어를 실행"></a>터미널 실행하여 다음 명령어를 실행</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>적은 이메일을 레이블로 사용해서 새 SSH 키를 작성한다는 메세지가 출력됩니다.(아래와 같은 메세지가 나온다면 성공입니다.)</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Generating public/private rsa key pair.</span><br></pre></td></tr></table></figure><h3 id="SSH-Key-저장위치-설정"><a href="#SSH-Key-저장위치-설정" class="headerlink" title="SSH Key 저장위치 설정"></a>SSH Key 저장위치 설정</h3><p>“키를 저정할 파일을 입력하십시오” 라는 프로프트가 표시되면 Enter를 누르십시오.(기본위치로 지정)</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Enter a file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><h3 id="SSH-Key-비밀번호-설정"><a href="#SSH-Key-비밀번호-설정" class="headerlink" title="SSH Key 비밀번호 설정"></a>SSH Key 비밀번호 설정</h3><p>비밀번호 없이 설정할경우 엔터 두번을 눌러주면된다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): [Type a passphrase]</span><br><span class="line">&gt; Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><h2 id="SSH-Key-등록"><a href="#SSH-Key-등록" class="headerlink" title="SSH Key 등록"></a>SSH Key 등록</h2><p>생성한 SSH Key를 등록해 봅시다</p><h3 id="터미널을-실행하여-아래-명령어를-실행하여-백그라운드에서-ssh-agent를-시작"><a href="#터미널을-실행하여-아래-명령어를-실행하여-백그라운드에서-ssh-agent를-시작" class="headerlink" title="터미널을 실행하여 아래 명령어를 실행하여 백그라운드에서 ssh-agent를 시작"></a>터미널을 실행하여 아래 명령어를 실행하여 백그라운드에서 ssh-agent를 시작</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">eval</span> <span class="hljs-string">"<span class="hljs-variable">$(ssh-agent -s)</span>"</span></span><br><span class="line">&gt; Agent pid 59566</span><br></pre></td></tr></table></figure><h3 id="ssh의-config-파일에-아래-text를-입력"><a href="#ssh의-config-파일에-아래-text를-입력" class="headerlink" title="ssh의 config 파일에 아래 text를 입력"></a>ssh의 config 파일에 아래 text를 입력</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.ssh/config</span><br></pre></td></tr></table></figure><blockquote><p>Host * AddKeysToAgent yes<br> UseKeychain yes<br> IdentityFile ~/.ssh/id_rsa</p></blockquote><h3 id="아래-명령어를-입력하여-SSH-Key-값을-ssh-agent에-추가"><a href="#아래-명령어를-입력하여-SSH-Key-값을-ssh-agent에-추가" class="headerlink" title="아래 명령어를 입력하여 SSH Key 값을 ssh-agent에 추가"></a>아래 명령어를 입력하여 SSH Key 값을 ssh-agent에 추가</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><h2 id="SSH-Key를-Github-계정에-추가"><a href="#SSH-Key를-Github-계정에-추가" class="headerlink" title="SSH Key를 Github 계정에 추가"></a>SSH Key를 Github 계정에 추가</h2><p>Github 로그인후 우측상단 메뉴에서 <code>Setting</code>을 클릭<br><img src="/img/github-setting.png" width="200px"></p><p>좌측의 <strong>Personal settings</strong> 메뉴 중에 <code>SSH and GPG keys</code> 클릭<br><img src="/img/personal-setting.png" width="200px"></p><p><code>New SSH Key</code>를 눌러서 Title과 Key를 입력후 <code>Add SSH Key</code> 버튼을 눌러준다.</p><p>Key 에는 아래명령어를 사용해서 .pub 의 공개키를 입력해 준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><blockquote><p><strong>id_rsa.pub 예시</strong><br>ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU<br>GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3<br>Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA<br>t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En<br>mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx<br>NrRFi9wrf+M7Q== <a href="mailto:schacon@agadorlaptop.local" rel="external nofollow noopener noreferrer" target="_blank">schacon@agadorlaptop.local</a></p></blockquote><p>Github SSH key 생성 및 적용하기를 해보았다. Github 연결시 계정정보를 입력해야 하는 번거로움에서 해방돠었다.</p>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/10/18/ssh-setting/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mac os에 zsh 세팅하기</title>
      <link>https://mishka.kr/2019/09/27/zsh-setting/</link>
      <guid>https://mishka.kr/2019/09/27/zsh-setting/</guid>
      <pubDate>Fri, 27 Sep 2019 00:58:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번에 직장을 옮기면서 맥북 유저로 돌아왔다. 퍼블리싱작업을 할때는 별로 신경쓰지 않았던 작업환경들이 개발을 하게되고 맥북을 가지면서 조금더 편한 것들을 찾게 되었다. 그중에 하나로 &lt;code&gt;zsh&lt;/code&gt;을 적용해 보았다.&lt;/p&gt;
&lt;h2 id=&quot;ZSH-란&quot;&gt;&lt;a href=&quot;#ZSH-란&quot; class=&quot;headerlink&quot; title=&quot;ZSH 란?&quot;&gt;&lt;/a&gt;ZSH 란?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Z 셸(Z shell, zsh)&lt;/strong&gt;은 상호작용 로그인 셸이자 셸 스크립트를 위한 강력한 명령 줄 &lt;strong&gt;인터프리터&lt;/strong&gt;로 사용할 수 있는 유닉스 셸이다.&lt;br&gt;&lt;strong&gt;Zsh&lt;/strong&gt;는 bash, ksh, tcsh의 일부 기능을 포함하여 수많은 개선 사항이 갖추어진 &lt;strong&gt;확장형 본 셸&lt;/strong&gt;이다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/Z_%EC%85%B8&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;위키백과&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번에 직장을 옮기면서 맥북 유저로 돌아왔다. 퍼블리싱작업을 할때는 별로 신경쓰지 않았던 작업환경들이 개발을 하게되고 맥북을 가지면서 조금더 편한 것들을 찾게 되었다. 그중에 하나로 <code>zsh</code>을 적용해 보았다.</p><h2 id="ZSH-란"><a href="#ZSH-란" class="headerlink" title="ZSH 란?"></a>ZSH 란?</h2><blockquote><p><strong>Z 셸(Z shell, zsh)</strong>은 상호작용 로그인 셸이자 셸 스크립트를 위한 강력한 명령 줄 <strong>인터프리터</strong>로 사용할 수 있는 유닉스 셸이다.<br><strong>Zsh</strong>는 bash, ksh, tcsh의 일부 기능을 포함하여 수많은 개선 사항이 갖추어진 <strong>확장형 본 셸</strong>이다. <a href="https://ko.wikipedia.org/wiki/Z_%EC%85%B8" rel="external nofollow noopener noreferrer" target="_blank">위키백과</a></p></blockquote><a id="more"></a><h2 id="ZSH-기능-살펴보기"><a href="#ZSH-기능-살펴보기" class="headerlink" title="ZSH 기능 살펴보기"></a>ZSH 기능 살펴보기</h2><ul><li>경로 자동 추론</li><li>타이핑 교정</li><li>명령어 추천</li><li>다양한 플러그인</li><li>이쁜 디자인이 핵심이다 ㅋㅋㅋ</li></ul><p>개발속도를 올려줄 수 있는 간편한 기능들이 많이 있다. </p><h2 id="ZSH-설치"><a href="#ZSH-설치" class="headerlink" title="ZSH 설치"></a>ZSH 설치</h2><p>본격적으로 ZSH를 설치 해보자<br>먼저 macOS 용 패키지 관리자인 <code>Homebrew</code>를 설치한다.<br>설치방법은 <a href="https://brew.sh/index_ko" rel="external nofollow noopener noreferrer" target="_blank">Homebrew 사이트</a>에 자세히 나와있으니 이번 포스팅에서는 생략한다.</p><p>먼저 아래 명령으로 zsh 가 설치되어있나 확인작업을 해준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zsh --version</span><br><span class="line">zsh 5.7.1</span><br></pre></td></tr></table></figure><p>설치되어 있지 않다면 아래의 명령으로 설치를 해준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh</span><br></pre></td></tr></table></figure><p>설치가 끝났다면 기본 쉘을 chsh을 사용하여 변경해준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s `<span class="hljs-built_in">which</span> zsh`</span><br></pre></td></tr></table></figure><h2 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h2><p><a href="https://ohmyz.sh/" rel="external nofollow noopener noreferrer" target="_blank">Oh My Zsh</a>는 ZSH 구성 관리를 위한 오픈 소스 커뮤니티 중심 프레임 워크 입니다. 여기에는 수천가지의 유용한 기능, 도우미, 플러그인, 테마 및 몇가지 소리가 제공됩니다. </p><figure class="highlight bash hljs"><figcaption><span>curl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh -c <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash hljs"><figcaption><span>wget</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="hljs-string">"<span class="hljs-variable">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure><p>ZSH 설치가 완료되었다. 이렇게만 설치하고 사용하여도 상관없지만 이왕 설치한 김에 몇가지 편리한 기능들을 추가로 세팅해보기로 했다.</p><h2 id="iTerm2-설치"><a href="#iTerm2-설치" class="headerlink" title="iTerm2 설치"></a>iTerm2 설치</h2><p><a href="https://www.iterm2.com/" rel="external nofollow noopener noreferrer" target="_blank">iTerm2</a>는 터미널의 부족한 기능들을 보안해주는 <code>터미널 에뮬레이터</code>이다. iTerm2에서 제공하는 많은 기능들 중에 유용한 기능들은 아래와 같다.</p><blockquote><ul><li>자동완성 기능 (Cmd + ;)</li><li>터미널 분할 창 기능 (Split Panes)</li><li>터미널 내에서 찾기 기능</li><li>마우스 없이 복사와 붙여넣기</li><li>더 많은 기능 살펴보기 : <a href="https://www.iterm2.com/features.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.iterm2.com/features.html</a></li></ul></blockquote><p>iTerm2 설치는 <a href="https://www.iterm2.com/" rel="external nofollow noopener noreferrer" target="_blank">iTerm2홈페이지</a>에서 다운로드 받은 후에 프로그램을 어플리케이션으로 옮겨주기만 하면된다.</p><h2 id="iTerm2-테마설치-선택"><a href="#iTerm2-테마설치-선택" class="headerlink" title="iTerm2 테마설치(선택)"></a>iTerm2 테마설치(선택)</h2><p><a href="https://github.com/mbadolato/iTerm2-Color-Schemes#installation-instructions" rel="external nofollow noopener noreferrer" target="_blank">iTerm Color Schemes</a>에 접속하여 컬러 스킨을 다운로드 받는다.<br>다운을 받으면 iTerm2를 실행하여 <code>cmd + ,</code>를 눌러서 환경설정 창을 띄워준다. Profile &gt; colors 메뉴에 들어가서 <code>Color Presets</code>를 눌러서 하단의 imports를 누른다. 다운로드 받은 폴더 schemes의 테마 중 원하는 테마를 선택한다.(취향존중)</p><h2 id="ZSH-테마-설치"><a href="#ZSH-테마-설치" class="headerlink" title="ZSH 테마 설치"></a>ZSH 테마 설치</h2><p>많은 테마들 중에 필자는 <a href="https://github.com/denysdovhan/spaceship-prompt" rel="external nofollow noopener noreferrer" target="_blank"><strong>Spaceship ZSH</strong></a> 테마를 설치해 보았다.</p><p>아래 명령어를 사용해서 설치를 진행한다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 복사</span></span><br><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/denysdovhan/spaceship-prompt.git <span class="hljs-string">"<span class="hljs-variable">$ZSH_CUSTOM</span>/themes/spaceship-prompt"</span></span><br><span class="line"><span class="hljs-comment"># 심볼릭링크(심볼릭 링크는 원본파일을 가리키도록 링크만 시켜둔 것 - 윈도우의 바로가기)</span></span><br><span class="line">ln -s <span class="hljs-string">"<span class="hljs-variable">$ZSH_CUSTOM</span>/themes/spaceship-prompt/spaceship.zsh-theme"</span> <span class="hljs-string">"<span class="hljs-variable">$ZSH_CUSTOM</span>/themes/spaceship.zsh-theme"</span></span><br></pre></td></tr></table></figure><p><strong>.zshrc</strong> 파일에서 <strong>ZSH_THEME</strong> 내용을 변경해준다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br><span class="line">또는 open ~/.zshrc</span><br></pre></td></tr></table></figure><p>해당 내용을 실행</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>이렇게 테마 적용시 폰트가 깨져서 원하던 모습을 볼수 없을 경우 폰트 설치를 진행하여 준다.</p><h2 id="Powerline-fonts-설치"><a href="#Powerline-fonts-설치" class="headerlink" title="Powerline fonts 설치"></a>Powerline fonts 설치</h2><p>자세한 설치 방법은 <a href="https://github.com/powerline/fonts" rel="external nofollow noopener noreferrer" target="_blank">Powerline fonts</a>을 참고 하기 바라며 간단한 설치 방법을 공유 합니다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 복사</span></span><br><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/powerline/fonts.git --depth=1</span><br><span class="line"><span class="hljs-comment"># 설치</span></span><br><span class="line"><span class="hljs-built_in">cd</span> fonts</span><br><span class="line">./install.sh</span><br><span class="line"><span class="hljs-comment"># 지우기</span></span><br><span class="line"><span class="hljs-built_in">cd</span> ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure><p>설치가 완료되면 아까와 같이 iTerm2 에서 설정을 <code>cmd + ,</code>를 눌러 환경설정에서 Profiles &gt; Text 에서 Powerline폰트를 선택주면된다.<br><strong>ZSH</strong>로 터미널과 조금 더 친해져 보자~!!</p>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/09/27/zsh-setting/#disqus_thread</comments>
    </item>
    
    <item>
      <title>지난 1년6개월의 회고</title>
      <link>https://mishka.kr/2019/08/29/Retrospective-20190829/</link>
      <guid>https://mishka.kr/2019/08/29/Retrospective-20190829/</guid>
      <pubDate>Thu, 29 Aug 2019 02:44:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번에 정들었던 &lt;strong&gt;&lt;code&gt;(주)라이프스타일프로젝트(이하 LSP)&lt;/code&gt;&lt;/strong&gt; 를 떠나면서 그동안의 회사생활 및 1년6개월 동안의 생활을 회고해보고 달라진 점들을 정리해본다. 사실 지금 글을 쓰고있는 &lt;code&gt;오늘(8월29일)&lt;/code&gt;이 마지막 출근날이다.&lt;/p&gt;
&lt;h2 id=&quot;뜻밖의-연락&quot;&gt;&lt;a href=&quot;#뜻밖의-연락&quot; class=&quot;headerlink&quot; title=&quot;뜻밖의 연락&quot;&gt;&lt;/a&gt;뜻밖의 연락&lt;/h2&gt;&lt;p&gt;현재 다니고있고 곧 퇴사(8월31일부)하게 되는 LSP와의 인연은 &lt;code&gt;2018년 2월&lt;/code&gt;에 시작됐다.&lt;br&gt;그 당시 이직을 준비하고 있는 상태였던 필자는 취업사이트에 이력서를 올려놓고 여러군데에 면접을 보고 있는 상황이었다.&lt;br&gt;그러던중 지금의 회사 인사팀에서 먼저 필자의 이력서를 보고 연락이 왔다. 그당시 회사명은 &lt;code&gt;(주)유앤김파트너스&lt;/code&gt; 였다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번에 정들었던 <strong><code>(주)라이프스타일프로젝트(이하 LSP)</code></strong> 를 떠나면서 그동안의 회사생활 및 1년6개월 동안의 생활을 회고해보고 달라진 점들을 정리해본다. 사실 지금 글을 쓰고있는 <code>오늘(8월29일)</code>이 마지막 출근날이다.</p><h2 id="뜻밖의-연락"><a href="#뜻밖의-연락" class="headerlink" title="뜻밖의 연락"></a>뜻밖의 연락</h2><p>현재 다니고있고 곧 퇴사(8월31일부)하게 되는 LSP와의 인연은 <code>2018년 2월</code>에 시작됐다.<br>그 당시 이직을 준비하고 있는 상태였던 필자는 취업사이트에 이력서를 올려놓고 여러군데에 면접을 보고 있는 상황이었다.<br>그러던중 지금의 회사 인사팀에서 먼저 필자의 이력서를 보고 연락이 왔다. 그당시 회사명은 <code>(주)유앤김파트너스</code> 였다.</p><a id="more"></a><p>그때까지만 해도 이력서를 넣지 않은 곳에서 직접적으로 연락이 온적은 없어서 있단 신기했고 또 그 당시 회사 주력브랜드였던 <code>미프(미남프로젝트)</code>의 제품을 우연히 정글의 법칙에서 김병만이 사용하는 것을 본 후라 그런지 더욱 신기했었다.</p><p>그렇게 면접제의를 받고 면접을 보게 되엇는데 1:3의 면접이었다. 면접관으로는 지금 같이 일하고 있는 팀장님, 인사담당자, 부사장님 이렇게 세분이 들어오셨었다. 몇가지 기술적인 질문이 있었으나 크게 어려운 질문은 없었고 상당히 즐거운 분위기에서 면접은 마무리되었다. 기억나는게 한가지 있는데 면접 마지막에 언제 연락을 줄 수 있냐는 필자의 질문에 회사측에서 필자가 첫번째 면접자라고 시간이 조금 걸릴것 같다고 했는데 그 대답을 듣고 필자가 호기롭게 <code>&quot;첫번째가 가장좋은거 아시죠??&quot;</code>하며 너스레를 떨었던 것이 기억이 난다. ㅎㅎㅎ 지금 생각해도 참….. 그 덕분인지는 모르겠지만 면접 다음날 바로 연락이 왔는데 다른 사람을 추가면접보지 않고 바로 필자를 합격자로 정했다는 연락이었다. 연봉제안도 필자가 제시했던 금액보다 좋은 조건을 제시해주어서 여러가지 망설임이 있었지만 입사를 결정하게 되었다.</p><h2 id="두근두근-첫-출근"><a href="#두근두근-첫-출근" class="headerlink" title="두근두근 첫 출근"></a>두근두근 첫 출근</h2><p>입사는 설이 지나고였다. 명절을 보내고 새로운 마음으로 회사에 첫 출근을 하였다. 부서는 <code>크리에이티브팀</code>이었고, 필자를 제외한 모든 부서원들은 디자이너들이었다. 필자의 업무는 기존에 계시던 분이 인수인계를 해주셨는데, 회사가 원래는 판교에서 지금의 역삼역근터로 이사를 오면서 거리도 멀어지고 건강도 안좋아지셔서 어쩔수 없이 퇴사를 하게 되었다고 하셨다.</p><p>그렇게 인수인계 받은 기존의 사이트는 <code>카페24 쇼핑몰 솔루션</code>을 통해 작업이 되어있었고 대부분이 이미지로 코딩이 되어있는 상태였다. 기존에 계시던분이 원래 디자이너 출신이어서 간단하게 코딩이 이루어져 있었다. 추후에 대대적인 리뉴얼이 이루어졌다.<br>그때까지만 해도 필자는 카페25 쇼핑몰 솔루션은 로그인만 해서 보았던게 전부였고 그 전에 하드코딩을 했었어서 카페25를 통한 코딩에 막연한 두려움을 약간을 가지고 있었으나 기존에 하던것에서 약간의 환경의 변화만 있었을 뿐 어려움 없이 적응 할 수 있었다.<br>또한 인수인계를 해주고 떠나시는 분을 제외하고는 회사에서 코딩 및 개방을 할 수 있는 사람이 한 사람도 없어서 막막하기도 하였다.</p><h2 id="하면된다"><a href="#하면된다" class="headerlink" title="하면된다."></a>하면된다.</h2><p>짧은 인수인계 기간이 끝나고 본격적으로 홀로 업무가 시작되었다.<br>그때 급한 업무를 처음으로 처리했던 기억이 나는데 기존에 계시던 분도 처음하는 일이었도 필자도 처음 듣는 업무여서 약간 당황했덨던 기억이난다. 업무내용은 그 때 당시 미프 모바일 사이트를 패키징하여 어플출시를 앞두고 있었는데 그 어플 출시를 위해서 애플 개발자 등록을 해야하고 결재를 해야되는데 그 단계에서 애플과 메일을 주고받고 전화를 받고 거기에서 받은 인증번호를 다시 입력하고 하는 등의 복잡한 프로세스가 있었는데 전에 계신던 분도 몇번 시도를 하다가 중간에 문제가 생겨서 해결을 못하시고 퇴사를 하시면서 필자에게 넘어왔던 업무였다. 중간에 무엇을 잘못했는지 중간 프로세스에서 막혀있는 상태였고 그렇게 상당한 시간이 흘러서 앱스토어 어플 출시 자체가 기약없이 미뤄지고 있는 상황이었다. 필자도 처음 겪는 업무여서 현재의 상황과 구글링 그리고 앱스토어의 문의를 통해 예상보다 빠르고 쉽게 앱스토어 어플 출시를 이루어낼 수 있었다. 오랜기간 멈춰져있던 업무를 필자가 잘 마무리 해서 입사한 후에 업무에 적응하는데 큰 도움이 되었던 사건이었다.</p><h2 id="일을-하면서"><a href="#일을-하면서" class="headerlink" title="일을 하면서"></a>일을 하면서</h2><p>1년6개월 동안 LSP를 다니면서 많은 것들을 배우고 성장하는 시간이었다. 회사의 기초가 화장품제조 및 판매이다보니 쇼핑몰 사이트의 개발과 운영에 대해 많은 것들을 배우게 되었고 쇼핑몰의 기초가 되는 카페24 쇼핑몰 솔루션에 대한 깊은 이해를 가질수 있었다. 그와 더불어 기존에 다니넌 에이전시와는 다르게 여유시간들을 갖게되어 아무래도 별도의 클라이언트가 있는것이 아니라 자사의 제품들만 다루기 때문에 일정과 같은 부분에서 회사 내부에 사정에 맞게 조율이 가능한 부분이 있었다. 많은 커뮤니티활동과 더불어 학원에도 다닐수 있는 기회가 있었고 스터디에도 참여해서 많은 것들을 배우는 시간을 가질 수 있었다.</p><p>필자는 크리에이티브팀에 소속되어있었다. 암묵적으로 <code>디자인팀</code>으로 불리운다 그 이유는 앞에서 잠깐 언급했듯이 필자를 제외한 모든 팀원이 디자이너로 구성되어있기 때문이었다. 필자도 퍼블려서로 전향하기 이전에는 무대디자인을 하였기에 디자이너들과의 소통 및 협업에는 큰 문제가 없었다. 그리고 화장품회사의 특성(?)상 남자직원들보다는 여자직원들의 비중이 더 높았었는데, 이전 무대일을 할때에도 디자인 관련 부서에서 일했기에 여자직원들이 더 많은 환경이었다보니 자연스레 섞여서 생활을 했었고 그러다보니 커뮤니케이션 같은 부분에서는 전혀 어려움이 없었으나 코딩 및 개발 업무를 알고 있는 사람은 전혀 없어서 어떤한 문제가 생겼을 때 혼자서 해쳐나가야하는 어려움은 늘 존재했었고 같이 문제에 대해 고민해 줄 사람의 필요가 느껴졌었다. 당시 회사 사정상 여러 개발자를 두는것은 무리가 있었고 그러다 보니 배움과 공유에 대한 갈증이 생겼고 자연스럽게 커뮤니티활동과 스터디로 그 갈증을 푸는 계기가 되었다.</p><h2 id="공부-스터디"><a href="#공부-스터디" class="headerlink" title="공부, 스터디"></a>공부, 스터디</h2><p>처음부터 스터디를 시작한 것은 아니었다. 스터디에 대한 정보도 없었고 그러한 것들이 활발히 진행되고 있는 것도 모르는 상황이었다. 그래서 처음에는 익숙한 컴퓨터학원을 통해 부족하다고 생각했던 개발에 대한 부분들의 수업을 듣기 시작했다. 그렇게 몇가지 수업들을 들었으나 만족할 만한 실력향상은 나타나지 않았던것 같다. 그러던중 우연히 <code>&#39;하코사&#39;</code>라는 커뮤니티를 접하게 되었고 스터디들이 활발히 진행되고 있는 것을 알게 되었다. 필자와 같은 고민을 하는 분들이 많이 있었으며 자신의 어려움을 질문하고 답을 얻어가고 함께 공부하는 커뮤니티였다. 그렇게 여러가지 정보를 얻어가던 중에 한 <code>살롱</code>에 참여하게 되었고 그곳에서 들은 이야기들은 지금까지 내가 알고 있던 내용들과는 많이 다른 내용들이었다. ‘프론트엔드개발자가 되어야지’, ‘지금 하고 있는 업무에서 추가적인 것들을 배우면서 커리어를 쌓으면 할 수 있는 걸 거야’ 와 같은 막연한 계획들이 있었는데 그 계획들을 처음부터 다시 생각하게 되는 살롱이었다. </p><blockquote><p>살롱 : 18세기 중반 프랑스에서 지성인과 예술가가 모여 토론을 펼치고 지식을 나누던 사교 모임</p></blockquote><p>살롱에 참여하기 전까지는 프론트엔드 개발자로 전향을 하려면 지금 하던 퍼블리셔 업무에서 추가적으로 약간의 자바스크립트를 배우고 동적인 UI개발을 더 익히면 되겠지 라는 수준이었는데 참여하고 난 후에는 생각이 완전히 바뀌었다. 우선 퍼블리셔와 프론트엔드개발자는 겹치는 부분도 물론 있었지만 근본적으로 다른 직군에 속해 있는 것이라서 추구하는 방향도 다르고 그렇기에 공부해야 하는 방향 자체도 다르다는 것이었다. 대략적으로 퍼블리셔거 보여지는 뷰단에서 UI적인 개발을 주로 한다면 프로트엔드개발자는 프로든단에서 DATA를 다루어 보여지는 뷰단을 선계해 가는 느낌이다. 그렇다보니 접근하는 방식에서부터 차이가 있고 생각하는 방법도 다르게 해야 올바르게 개발자로 거듭날 수 있다는 생각이 들었다. </p><h2 id="책-집필스터디에-참여"><a href="#책-집필스터디에-참여" class="headerlink" title="책 집필스터디에 참여"></a>책 집필스터디에 참여</h2><p>그렇게 살롱다녀와서 거기서 알게된 인연으로 정말 좋은 기회인 책집필을 위한 스터디에 참여하는 기회가 찾아왔다.<br><code>Vue.js</code>에 관한 책을 집할 하면서 그 내용들을 가지고 구현해 보고 스터디였는데 피자는 당시 Vue.js는 당연히 처음접하였고 프레임워크언어자체가 대한 개념 및 개발을 처음 시작하는 단계였다. 그래서인지 스터디에서 배우는 하나하나가 너무나 값진 경험이었다. 처음 배우는 내용들이다보니 질문도 많았고 이것저것 안되는 것들도 그리고 모르는 것들도 많았는데 집필하시는 분들에게는 이부분이 오히려 도움이 많이 되었다고 하셨다. 서로에게 여러가지를 주고 받을수 있는 윈윈이었으니 잘 마무리 되었다. ㅎㅎㅎ 스터디가 끝나고 간단한 메모어플과 게시판어플을 구현해볼수 있었다. 현재는 책은 무시히 출판되었고 필자는 간단하게나마 추천사로 책 한부분에 남을수 있어서 좋았다. 궁금해 하실 분들을 위해 책제목을 남겨본다. 책 제목은 <code>&quot;커피한잔 마시며 끝내는 Vue.js&quot;</code> 이다.</p><p>그렇게 Vue.js 스터디를 끝나마치고 더 배워야 한다는 생각에 git스터디, javajscript스터디에 참여하게 되었고 그러다보니 필자에게 맞는 새로운 스터디를 기획해서 스터디를 진행하게 되었다. 현재는 JS ES6를 중점적으로 스터디를 하고 잇으며 8월 31일에 마지막 스터디 모임을 앞두고 있는 상황이다. 이번 스터디에 함께한 스터디원분들 중 많은 분들이 다음 스터디로 함께 했으면 좋겠다는 의사를 밝혀주셔서 현재는 함께 기획하고 있는 중에 있다.</p><p>이렇게 회사 생활을 하면서 커뮤니티와 많은 스터디들을 통해서 부족한 것들을 채우고 발전해나가는 시간들을 가실 수 있었던 것에 대해서는 긍적적으로 생각한다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지난 1년 6개월 동안 LSP에 지내면서 함께한 모든 분들에게 감사의 인사를 전하고 싶다.<br>비록 더 많은 시간들을 함께 하지는 못하지만 어디에서든지 각자의 몫을 하며 빛나고 있기를 소망한다.</p>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/08/29/Retrospective-20190829/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 16. Math</title>
      <link>https://mishka.kr/2019/08/17/Learning-JavaScript-chapter16/</link>
      <guid>https://mishka.kr/2019/08/17/Learning-JavaScript-chapter16/</guid>
      <pubDate>Fri, 16 Aug 2019 15:20:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;Math 객체는 애플리케이션을 개발하면서 자주 사용하게 될 수학 함수를 담고 있습니다.(전문적인 숫자 분석이 필요하다면 별도의 라이브러리를 찾아야 한다.)&lt;br&gt;자바스크립트의 숫자는 모두 &lt;strong&gt;IEEE 755 64비트 부동소수점 숫자&lt;/strong&gt;이다.&lt;/p&gt;
&lt;h2 id=&quot;숫자-형식&quot;&gt;&lt;a href=&quot;#숫자-형식&quot; class=&quot;headerlink&quot; title=&quot;숫자 형식&quot;&gt;&lt;/a&gt;숫자 형식&lt;/h2&gt;&lt;p&gt;자바스크립트는 다양한 숫자 형식을 지원하지는 못한다. 10진수 형식, 고정 소수점 형식, 지수 형식이 몇가지 있는 정도이다.&lt;br&gt;숫자를 2진수, 8진수, 16진수로 나타낼 수도 있다.&lt;/p&gt;
&lt;p&gt;자바스크립트의 숫자 형식 메서드는 모두 숫자가 아니라 &lt;strong&gt;문자열을 반환&lt;/strong&gt;한다. 해당 형식에 필요한 각종 기호를 온전히 표현하려면 반드시 문자열이어야 하기 때문이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Math 객체는 애플리케이션을 개발하면서 자주 사용하게 될 수학 함수를 담고 있습니다.(전문적인 숫자 분석이 필요하다면 별도의 라이브러리를 찾아야 한다.)<br>자바스크립트의 숫자는 모두 <strong>IEEE 755 64비트 부동소수점 숫자</strong>이다.</p><h2 id="숫자-형식"><a href="#숫자-형식" class="headerlink" title="숫자 형식"></a>숫자 형식</h2><p>자바스크립트는 다양한 숫자 형식을 지원하지는 못한다. 10진수 형식, 고정 소수점 형식, 지수 형식이 몇가지 있는 정도이다.<br>숫자를 2진수, 8진수, 16진수로 나타낼 수도 있다.</p><p>자바스크립트의 숫자 형식 메서드는 모두 숫자가 아니라 <strong>문자열을 반환</strong>한다. 해당 형식에 필요한 각종 기호를 온전히 표현하려면 반드시 문자열이어야 하기 때문이다.</p><a id="more"></a><h3 id="고정-소수점"><a href="#고정-소수점" class="headerlink" title="고정 소수점"></a>고정 소수점</h3><p>소수점 뒤 자리수를 지정하는 형식을 원한다면 <code>toFixed()</code>를 사용</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-number">19.51</span>;</span><br><span class="line">x.toFixed(<span class="hljs-number">3</span>)   <span class="hljs-comment">// "19.510"</span></span><br><span class="line">x.toFixed(<span class="hljs-number">2</span>)   <span class="hljs-comment">// "19.51"</span></span><br><span class="line">x.toFixed(<span class="hljs-number">0</span>)   <span class="hljs-comment">// "20"</span></span><br></pre></td></tr></table></figure><p>숫자는 버림이 아니라 반올림으로 나타난다.</p><h3 id="지수-표기법"><a href="#지수-표기법" class="headerlink" title="지수 표기법"></a>지수 표기법</h3><p>지수 표기법이 필요할 때는 <code>toExponential()</code>을 사용<br>toFixed()와 마찬가지로 반올림한 결과가 출력. 매개변수로 넘긴 정밀도에 따라 소수점 쥐의 숫자가 몇 개 나타날지 정해진다.</p><h3 id="고정-전체-자리수"><a href="#고정-전체-자리수" class="headerlink" title="고정 전체 자리수"></a>고정 전체 자리수</h3><p>소수점이 어디 나타나는 관계없이 숫자 몇 개로 표현하느냐가 중요하다면 <code>toPrecision()</code>을 사용<br>출력 결과는 반올림된 숫자이며 전체 자리수는 매개변수로 넘긴 자릿수와 일치</p><h3 id="다른-진수"><a href="#다른-진수" class="headerlink" title="다른 진수"></a>다른 진수</h3><p>2진수나 8진수, 16 진수 표현을 원한다면 <code>toString()</code>에 기수를 매개변수로 쓰면 된다.</p><h3 id="고급-숫자-형식"><a href="#고급-숫자-형식" class="headerlink" title="고급 숫자 형식"></a>고급 숫자 형식</h3><p>다양한 형식으로 숫자를 표시해야 한다면 한계에 부딪힌다.</p><blockquote><p>수천자리의 아주 큰 숫자<br>괄호를 쓰는 등, 음수 표현을 다르게 해야하는 경우<br>공학 표기법<br>milli-, micro-, kilo-, mega- 등의 SI 접두사가 필요한 경우</p></blockquote><p>위와같은 경우 Numeral.js를 사용하는 것을 권한다.</p><h2 id="상수"><a href="#상수" class="headerlink" title="상수"></a>상수</h2><p>Math 객체에는 몇 가지 중요한 상수가 프로퍼티로 내장돼 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.E    <span class="hljs-comment">//자연로그의 밑수</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.PI   <span class="hljs-comment">//원주율</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Math</span>.SQRT1_2    <span class="hljs-comment">//1/2의 제곱근</span></span><br><span class="line"></span><br><span class="line">etc</span><br></pre></td></tr></table></figure><h2 id="대수-함수"><a href="#대수-함수" class="headerlink" title="대수 함수"></a>대수 함수</h2><h3 id="거듭제곱"><a href="#거듭제곱" class="headerlink" title="거듭제곱"></a>거듭제곱</h3><p>제곱 관련 기본 함수는 <code>Math.pow</code>이며 제곱근, 세제곱근,e의 거듭제곱 등 자주 쓰이는 연산에는 간편 함수가 있습니다.</p><h2 id="로그-함수"><a href="#로그-함수" class="headerlink" title="로그 함수"></a>로그 함수</h2><p>자연로그 함수는 <code>Math.log</code></p><h2 id="기타-함수"><a href="#기타-함수" class="headerlink" title="기타 함수"></a>기타 함수</h2><h2 id="의사-난수-생성"><a href="#의사-난수-생성" class="headerlink" title="의사 난수 생성"></a>의사 난수 생성</h2><p>자바스크립트에서 의사 난수를 생성할 때는 <code>Math.random()</code>을 사용합니다. 이 함수는 0이상 1 미만의 숫자를 반환합니다.</p><h2 id="삼각함수-쌍곡선함수"><a href="#삼각함수-쌍곡선함수" class="headerlink" title="삼각함수, 쌍곡선함수"></a>삼각함수, 쌍곡선함수</h2>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/08/17/Learning-JavaScript-chapter16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 15. 날짜와 시간</title>
      <link>https://mishka.kr/2019/08/16/Learning-JavaScript-chapter15/</link>
      <guid>https://mishka.kr/2019/08/16/Learning-JavaScript-chapter15/</guid>
      <pubDate>Fri, 16 Aug 2019 14:41:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;자바스크립트의 Date객체는 원래 넷스케이프 프로그래머 캔스미스가 만들었는데, 사실 자바의 java.util.Date을 가져온 것이다. 세계는 타임존으로 나뉘어 있습니다. 타임존은 모두 &lt;strong&gt;UTC(Coordinated Universal Time)&lt;/strong&gt;를 기준으로 한 시차로 나뉩니다.&lt;br&gt;UTC는 때때로 그리니치 표준시, 즉 &lt;strong&gt;GMT(Greenwich Mean Time)&lt;/strong&gt;라고 불리기도 합니다.&lt;/p&gt;
&lt;p&gt;자바스크립트에서 Date 인스턴스는 모두 유닉스 시간 원점으로 부터 몇 밀리초가 지났는지 나타내는 숫자입니다.&lt;br&gt;자바스크립트는 보통 이 숫자를 사람이 읽기 편한 그리고리력 날짜로 변환합니다. 숫자형 표현이 필요하면 &lt;code&gt;valueOf()&lt;/code&gt; 메서드를 쓰면됩니다.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; d = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.lod(d);              &lt;span class=&quot;hljs-comment&quot;&gt;//타임존이 들어간 그레고리력 날짜&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(d.valueOf());    &lt;span class=&quot;hljs-comment&quot;&gt;//유닉스 타임스탬프&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>자바스크립트의 Date객체는 원래 넷스케이프 프로그래머 캔스미스가 만들었는데, 사실 자바의 java.util.Date을 가져온 것이다. 세계는 타임존으로 나뉘어 있습니다. 타임존은 모두 <strong>UTC(Coordinated Universal Time)</strong>를 기준으로 한 시차로 나뉩니다.<br>UTC는 때때로 그리니치 표준시, 즉 <strong>GMT(Greenwich Mean Time)</strong>라고 불리기도 합니다.</p><p>자바스크립트에서 Date 인스턴스는 모두 유닉스 시간 원점으로 부터 몇 밀리초가 지났는지 나타내는 숫자입니다.<br>자바스크립트는 보통 이 숫자를 사람이 읽기 편한 그리고리력 날짜로 변환합니다. 숫자형 표현이 필요하면 <code>valueOf()</code> 메서드를 쓰면됩니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br><span class="line"><span class="hljs-built_in">console</span>.lod(d);              <span class="hljs-comment">//타임존이 들어간 그레고리력 날짜</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(d.valueOf());    <span class="hljs-comment">//유닉스 타임스탬프</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Date-객체-만들기"><a href="#Date-객체-만들기" class="headerlink" title="Date 객체 만들기"></a>Date 객체 만들기</h2><p>Date 객체는 네 가지 방법으로 만들 수 있습니다.</p><blockquote><p>매개변수 없이 호출하면 현재 날짜에 해당하는 Date 객체를 반환<br>문자열을 제공하면 자바스크립트는 그 문자열을 해석해서 그에 맞는 날짜를 반환<br>숫자를 넣으면 유닉스 타임스탬프로 해석<br>타임스탬프로 입력하는 방법</p></blockquote><h2 id="Moment-js"><a href="#Moment-js" class="headerlink" title="Moment.js"></a>Moment.js</h2><p>Moment.js에는 타임존을 지원하는 버전과 지원하지 않는 버전 두 가지가 있습니다.</p><p>CDN을 통한 사용</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.4.0/moment-timezone.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>노드를 사용할 때는 npm install –save moment-timezone 명령으로 Moment.js를 설치하고 require 명령으로 스크립트를 불러올 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> moment = reqire(<span class="hljs-string">'moment-timezone'</span>);</span><br></pre></td></tr></table></figure><h2 id="날짜-형식"><a href="#날짜-형식" class="headerlink" title="날짜 형식"></a>날짜 형식</h2><p>Moment.js 의 format 메서드를 써서 날짜를 원하는 형식으로 만들 수 있습니다.<br>자세한 사항은 Moment.js 온라인 문서를 참고 합시다.</p><h2 id="날짜-구성-요소"><a href="#날짜-구성-요소" class="headerlink" title="날짜 구성 요소"></a>날짜 구성 요소</h2><p>Date 인스턴스의 각 구성 요소에 접근 할 때는 다음 메서드를 사용합니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.UTC(<span class="hljs-number">1815</span>, <span class="hljs-number">9</span> ,<span class="hljs-number">10</span>));</span><br><span class="line"></span><br><span class="line">d.getFullYear()</span><br><span class="line">d.getMonth()</span><br><span class="line">d.getDate()</span><br><span class="line">d.getDay()</span><br><span class="line">d.getHours()</span><br><span class="line">d.getMinutes()</span><br><span class="line">d.getSeconds()</span><br><span class="line">d.getMilliseconds()</span><br></pre></td></tr></table></figure><h2 id="날짜-비교"><a href="#날짜-비교" class="headerlink" title="날짜 비교"></a>날짜 비교</h2><p>날짜 A와 날짜 B 중 너느쪽이 더 앞인가 하는 단순 날짜 비교는 자바스크립트에 내장된 비교 연산자를 통해 할 수 있다.<br>Date 인스턴스는 날짜를 숫자로 저장 하므로, 숫자에 쓸 수 있는 비교 연산자를 그대로 쓰면 된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1996</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2009</span>, <span class="hljs-number">4</span>, <span class="hljs-number">27</span>);</span><br><span class="line">d1 &gt; d2  <span class="hljs-comment">// false</span></span><br><span class="line">d1 &lt; d2  <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="날짜-연산"><a href="#날짜-연산" class="headerlink" title="날짜 연산"></a>날짜 연산</h2><p>날짜는 숫자이므로 날짜에서 날짜를 빼면 몇 밀리초가 지났는지 알 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> msDiff = d2 -d1;</span><br></pre></td></tr></table></figure><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><blockquote><p>자바스크립트의 날자는 1970년 1월 1일 UTC로부터 몇 밀리초가 지났는지 나타내는 숫자입니다.<br>날짜를 생성할 때는 타임존이 유의 하여야 한다.<br>날짜 형식을 자유롭게 바꿀 수 있어야 한다면 Moment.js를 사용하면 된다.</p></blockquote>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/08/16/Learning-JavaScript-chapter15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 14. 비동기적 프로그래밍</title>
      <link>https://mishka.kr/2019/08/03/Learning-JavaScript-chapter14/</link>
      <guid>https://mishka.kr/2019/08/03/Learning-JavaScript-chapter14/</guid>
      <pubDate>Fri, 02 Aug 2019 15:28:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;사용자의 행동은 전적으로 &lt;strong&gt;비동기적&lt;/strong&gt;이다. 사용자가 언제 클릭할지, 터치할지, 또는 타이핑 할지 프로그래머는 전혀 알수 없기 때문이다. 하지만 비동기적 실행이 사용자입력 하나 때문에 필요한 것은 아니다.&lt;/p&gt;
&lt;p&gt;자바스크립트 애플리케이션은 &lt;code&gt;단일 스레드&lt;/code&gt;에서 동작한다.&lt;br&gt;즉 자바스크립트는 한 번에 한가지 일만 할 수 있다. 이러한 자바스크립트의 본질 때문에 비동기적 프로그램밍이 필요하다.&lt;/p&gt;
&lt;p&gt;자바스크립트에는 매우 일찍부터 비동기적 실행 메커니즘이 존재 했지만, 자바스크립트의 인기가 높아지고 소프트웨어가 복잡해짐에 따라 비동기적 프로그래밍에 필요한 장치들이 추가 되었다.&lt;/p&gt;
&lt;p&gt;자바스크립트의 비동기적 프로그래밍에는 뚜렷이 구분되는 &lt;code&gt;세가지 패러다임&lt;/code&gt;이 있습니다.&lt;br&gt;처음에는 &lt;strong&gt;콜백&lt;/strong&gt; 그 뒤로 &lt;strong&gt;프라미스&lt;/strong&gt; 마지막은 &lt;strong&gt;제너레이터&lt;/strong&gt; 입니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>사용자의 행동은 전적으로 <strong>비동기적</strong>이다. 사용자가 언제 클릭할지, 터치할지, 또는 타이핑 할지 프로그래머는 전혀 알수 없기 때문이다. 하지만 비동기적 실행이 사용자입력 하나 때문에 필요한 것은 아니다.</p><p>자바스크립트 애플리케이션은 <code>단일 스레드</code>에서 동작한다.<br>즉 자바스크립트는 한 번에 한가지 일만 할 수 있다. 이러한 자바스크립트의 본질 때문에 비동기적 프로그램밍이 필요하다.</p><p>자바스크립트에는 매우 일찍부터 비동기적 실행 메커니즘이 존재 했지만, 자바스크립트의 인기가 높아지고 소프트웨어가 복잡해짐에 따라 비동기적 프로그래밍에 필요한 장치들이 추가 되었다.</p><p>자바스크립트의 비동기적 프로그래밍에는 뚜렷이 구분되는 <code>세가지 패러다임</code>이 있습니다.<br>처음에는 <strong>콜백</strong> 그 뒤로 <strong>프라미스</strong> 마지막은 <strong>제너레이터</strong> 입니다.</p><a id="more"></a><p>제너레이터 자체는 비동기적 프로그래밍을 전혀 지원하지 않는다.<br>제너레이터를 비동기적으로 사용하려면 프라미스나 특수한 콜백과 함께 사용해야 한다.</p><p>사용자 입력 외에, 비동기적 테크닉을 사용해야 하는 경우는 크게 세가지가 있다.</p><blockquote><p>Ajax 호출을 비롯한 네트워크 요청<br>파일을 읽고 쓰는 등의 파일시스템 작업<br>의도적으로 시간 지연을 사용하는 기능(알람 등)</p></blockquote><h2 id="비유"><a href="#비유" class="headerlink" title="비유"></a>비유</h2><p>어떤 음식점은 당신이 줄을 서서 기다리지 않도록, 당신의 전화번호를 받아서 자리가 나면 전화를 해줍니다. 이런 음심적은 <strong>콜백</strong>과 비슷하다. 자리가 나면 당신이 알 수 있도록 하는 수단을 당신이 음식점 주인에게 넘겨준다. 음식점은 다른 손님을 대접하면 되고 당신은 다른 일을 하면된다. 어느쪽도 서로를 기다리지 않는다.</p><p>다른 음식점은 자리가 났을 때 진동하는 호출기를 당신에게 넘겨준다. 이런 음식점은 <strong>프라미스</strong>와 비슷하다.<br>자리가 나면 당신이 알수 있도록 하는 수단을 음식점에서 당신에게 넘겨준다.</p><h2 id="콜백"><a href="#콜백" class="headerlink" title="콜백"></a>콜백</h2><p>콜백은 자바스크립트에서 <code>가장 오래된 비동기적 메커니즘</code>이다. 콜백은 간단히 말해 나중에 호출할 함수이다.<br>콜백 함수 자체에는 특별할 것이 전혀 없다. 콜백 함수도 <strong>일반적인 자바스크립트 함수일 뿐이다.</strong><br>콜백함수는 일반적으로 다른 함수에 넘기거나 객체의 프로퍼티로 사용한다. 드물게는 배열에 넣어서 쓸 때도 있다.<br>항상 그런건 아니지만 콜백은 보통 익명 함수로 사용한다.</p><p>비동기적 실행의 가장 큰 목적이자 중요한 요점은 어떤 것도 차단하지 않는다는 것이다.<br>자바스크립트는 싱글 스레드를 사용하기 때문에 우리가 컴퓨터에 60초동안 대기한 후 코드를 실행하라고 지시한다면 그 실행이 동기적으로 이루어 진다면 프로그램이 멈추고 사용자 입력을 받아들이지도 않고 화면도 업데이트 하지 않을것이다.<br>비동기적 테크닉은 프로그램이 이런 식으로 멈추는 일을 막아준다.</p><h2 id="오류-우선-콜백"><a href="#오류-우선-콜백" class="headerlink" title="오류 우선 콜백"></a>오류 우선 콜백</h2><p>콜백을 사용하면 예외 처리가 어려워지므로 콜백과 관련된 에러를 처리할 방법의 표준이 필요했다.<br>이에 따라 나타난 패턴이 콜백의 첫 번째 매개변수에 에러 객체를 쓰자는 것이었다.<br>에러가 null이나 undefined이면 에러가 없는 것입니다.<br>오류 우선 콜백을 다룰 때 가장 먼저 생각할 것은 에러 매개변수를 체크하고 그에 맞게 반응하는 겁니다.</p><p>노드에는 파일 콘텐츠를 읽는다고 할 때 오류 우선 콜백을 사용한다면 다음과 같다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> fname = <span class="hljs-string">'may_or_may_nor_exist.txt'</span>;</span><br><span class="line"></span><br><span class="line">fs.readFile(fname, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`error reading file $(fname): <span class="hljs-subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`$(fname) contents: $(data)`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>콜백에서 가장 먼저 하는 일은 err이 참 같은 값인지 확인 하는 것이다.<br>err이 참 같은 값이라면 파일을 읽는 데 문제가 있다는 뜻이므로 콘솔에 오류를 보고하고 즉시 빠져나온다.<br>오류 우선 콜백을 사용할 때는 에러 객체를 체크해야 하고, 빠져 나와야 한다는 사실을 기억해야 한다.<br>콜백을 사용하는 함수는 대개 콜백이 성공적이라고 가정하고 만들어 진다. 그런데 콜백이 실패 했으니 빠져나가지 않으면 오류를 예약하는 것이나 다름 없다.<br>물론, 콜백을 만들 때 실패하는 경우도 염두에 두고 만들었다면 에러를 기록 하기만 하고 계속 진행해도 된다.<br>프라미스를 사용하지 않으면 오류우선 콜백은 노드 개발의 표준이나 다름 없다.</p><h2 id="콜백-헬"><a href="#콜백-헬" class="headerlink" title="콜백 헬"></a>콜백 헬</h2><p>콜백을 사용해 비동기적으로 실행할 수 있긴 하지만 <code>현실적인 단점</code>이 있다. 한 번에 여러가지를 기다려야 한다면 콜백을 관리하기가 상당히 어려워진다. 중괄호에 둘러싸여 끝없이 중청된 삼각형의 코드 블록들을 프로그래머들은 <code>콜백 헬</code>이라고 부른다. 가장 골치 아픈것은 에러 처리이다.</p><p>비동기적 코드가 늘어나면 늘어날수록 버그가 없고 관리하기 쉬운 코드를 작성하기는 매우 어렵다 그래서 <strong>프라미스</strong>가 등장했다.</p><h2 id="프라미스"><a href="#프라미스" class="headerlink" title="프라미스"></a>프라미스</h2><p>프라미스는 콜백의 단점을 해결하려는 시도 속에서 만들어졌다.<br>프라미스가 <strong>콜백을 대체하는 것은 아니다.</strong> 사실 프라미스에서도 콜백을 사용한다.<br>프라미스는 콜백을 예측 가능한 패턴으로 사용 할수 있게 하며, 프라미스 없이 콜백만 사용했을 때 나타날수 있는 엉뚱한 현상이나 찾기 힘든 버그를 상당수 해결한다.</p><p>프라미스의 기본 개념은 프라미스 기반 함수를 호출하면 그 함수는 <code>Promise 인스턴스를 반환</code>한다.<br>프라미스는 <strong>성공(resolve)</strong>하거나 <strong>실패(reject)</strong>하거나 단 두가지 뿐이다.<br>프라미스는 성공 혹은 실패 둘 중 하나만 일어난다고 확신할 수 있다.<br>성공한 프라미스가 나중에 실패하는 일 같은건 절대 없다. 또한 성공이든 실패든 단 한번만 일어난다.<br>프라미스가 성공하거나 실패하면 그 프라미스를 <code>결정</code> 됐다고 한다.</p><p>프라미스는 객체이므로 어디든 전달할 수 있다는 점도 콜백에 비해 간편한 장점이다.<br>비동기적 처리를 여기서 하지 않고 다른 함수에서 처리하게 하고 싶다면 프라미스를 넘기기만 하면 된다.</p><h2 id="프라미스-만들기"><a href="#프라미스-만들기" class="headerlink" title="프라미스 만들기"></a>프라미스 만들기</h2><p>프라미스는 쉽게 만들 수 있다.<br>resolve와 reject 콜백이 있는 함수로 새 Promise 인스턴스를 만들기만 하면 된다.</p><h2 id="프라미스-사용"><a href="#프라미스-사용" class="headerlink" title="프라미스 사용"></a>프라미스 사용</h2><p>프라미스는 비동기적 작업이 성공 또는 실패하도록 확정하는 매우 안전하고 잘 정의된 매커니즘을 제공하지만 현재는 진행 상황을 전혀 알려주지 않는다. 즉 프라미스는 완료되거나 파기 될뿐 <strong>‘50% 진행됐다’</strong> 라는 개념은 아예 없다.<br><code>Q</code> 같은 프라미스 라이브러리에는 진행 상황을 보고하는 기능이 있고 나중에 언젠가는 도입될 수도 있지만 지금 당장은 없다.</p><h2 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트"></a>이벤트</h2><p>이벤트는 자바스크립트에서 자주 사용된다. 이벤트의 개념은 간단하다.<br>이벤트가 일어나면 이벤트 발생을 담당하는 객체에서 이벤트가 일어났음을 알린다,<br>필요한 이벤트는 모두 주시 할수 있다.(콜백을 통해서)</p><h2 id="프라미스-체인"><a href="#프라미스-체인" class="headerlink" title="프라미스 체인"></a>프라미스 체인</h2><p>프라미스에는 체인으로 연결 할수 있다는 장점이 있다. 즉, <strong>프라미스가 완료되면 다른 프라미스를 반환하는 함수를 즉시 호출</strong> 할수 있다. 프라미스 체인을 사용하면 모든 단계에서 에러를 캐치할 필요는 없다. 체인 어디에서든 에러가 생기면 체인 전체가 멈추고 catch핸들러가 동작한다.</p><h2 id="결정되지-않는-프라미스-방지하기"><a href="#결정되지-않는-프라미스-방지하기" class="headerlink" title="결정되지 않는 프라미스 방지하기"></a>결정되지 않는 프라미스 방지하기</h2><p>프라미스는 비동기적 코드를 단순화하고 콜백이 두 번 이상 실행되는 문제를 방지한다.<br>하지만 resolve나 reject를 호출하는 걸 잊어서 프라미스가 결정되지 않는 문제까지 자동으로 해결하지는 못한다.<br>에러가 일어나지 않으므로 찾기 매우 어렵다. 복잡한 시스템에서 결정되지 않은 프라미스는 그냥 잊혀질 수 있다.</p><p>결정되지 않는 프라미스를 방지하는 한 가지 방법은 타임아웃을 거는 것이다.<br>출분한 시간이 지났는데도 프라미스가 결정되지 않으며 자동으로 실패하게 만들 수 있다.</p><figure class="highlight javascript hljs"><figcaption><span>프라미스에 타임아웃을 거는 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTimeout</span>(<span class="hljs-params">fn, timeout</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(timeout === <span class="hljs-literal">undefined</span>) timeout = <span class="hljs-number">1000</span>; <span class="hljs-comment">//타임아웃 기본값 </span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">const</span> tid = setTimeout(reject, timeout,</span><br><span class="line">                <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"promise timed out"</span>));</span><br><span class="line">            fn(...args)</span><br><span class="line">                .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;</span><br><span class="line">                    clearTimeout(tid);</span><br><span class="line">                    resolve(...args);</span><br><span class="line">                &#125;)</span><br><span class="line">                .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;</span><br><span class="line">                    clearTimeout(tid);</span><br><span class="line">                    reject(...args)</span><br><span class="line">                &#125;);    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프라미스를 반환하는 함수를 호출하는 프라미스를 반환하는 함수를 반환하는 함수 ??<br>프라미스에 타임아웃을 걸기 위해서는 함수를 반환하는 함수가 필요하다.</p><h2 id="제너레이터"><a href="#제너레이터" class="headerlink" title="제너레이터"></a>제너레이터</h2><p>제너레이터는 원래 동기적인 성격을 가졌지만 프라미스와 결합하면 비동기 코드를 효율적으로 관리 할 수 있다.<br>비동기 코드에서 가장 어려운 부분은 동기적인 코드에 비해 <strong>만들기가 어렵다</strong>는 점이다.</p><p>프로그램에서 어떤 부분을 동시에 실행할 수 있고 또 어떤 부분은 동시에 실행 할수 없는지 판단하는 것이 중요하다.</p><h2 id="제너레이터-실행기와-예외처리"><a href="#제너레이터-실행기와-예외처리" class="headerlink" title="제너레이터 실행기와 예외처리"></a>제너레이터 실행기와 예외처리</h2><p><code>제너레이터 실행기</code>를 쓰면 try/catch를 써서 예외 처리를 할수 있다는 것도 중요한 장점이다.<br>콜백이나 프라미스를 사용하면 예외 처리가 쉽지 않다. 콜백에서 일으킨 예외는 그 콜백 밖에서 캐치할 수 없다.<br>제너레이터 실행기는 <strong>비동기적으로 실행</strong>하면서도 동기적인 동작 방식을 유지하므로 <strong>try/catch문</strong>과 함께 쓸수 있다.</p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><blockquote><p>자바스크립트의 비동기적 실행은 콜백을 통해 이루어진다.<br>프라미스를 콜백 대신 사용할수 잇는건 아니다. 프라미스 역시 콜백을 사용한다.<br>프라미스는 콜백이 여러번 호출되는 문제를 해결했다.<br>콜백을 여러번 호출해야 한다면 이벤트와 결합하는 방법을 생각 할수 있다.(프라미스도 함께 쓸 수 있다.)<br>프라미스는 반드시 결정된다는 보장은 없다. 프라미스의 타임아웃을 걸어 이문제를 해결 할수 있다.<br>프라미스는 체인으로 연결할 수 있다.<br>프라미스와 제너레이터 실행기를 결합하면 비동기적 실행의 장점을 그대로 유지하면서도 동기적인 사고방식으로 문제를 해결할 수 있다,<br>제너레이터를 써서 동기적인 사고방식으로 문제를 해결할 때는 프로그래의 어느 부분을 동시에 실행 할수 있는지 잘 살펴야 한다. 동시에 실행 할수 있는 부분은 Promise.all을 써서 실행해라<br>제너레이터 실행기를 직점 만드는 고생을 하지말고 co나 Koa를 써라<br>노드 스타일 콜백을 프라미스로 바꾸는 고생도 필요없다  Q를 써라<br>제너레이터 실행기를 쓰면 예외 처리도 익숙한 방식으로 할 수 있다.</p></blockquote>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/08/03/Learning-JavaScript-chapter14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 13. 함수와 추상적 사고</title>
      <link>https://mishka.kr/2019/08/03/Learning-JavaScript-chapter13/</link>
      <guid>https://mishka.kr/2019/08/03/Learning-JavaScript-chapter13/</guid>
      <pubDate>Fri, 02 Aug 2019 15:20:45 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;서브루틴으로서의-함수&quot;&gt;&lt;a href=&quot;#서브루틴으로서의-함수&quot; class=&quot;headerlink&quot; title=&quot;서브루틴으로서의 함수&quot;&gt;&lt;/a&gt;서브루틴으로서의 함수&lt;/h2&gt;&lt;p&gt;서브루틴은 아주 오랜 된 개념이며 복잡한 코드를 간단하게 만드는 기초적인 수단입니다.&lt;br&gt;서브루틴은 프로시저, 루틴, 서브프로그램, 매크로 등 다양한 이름으로 불립니다. 이들은 모두 매우 단순하고 &lt;strong&gt;범용적인 호출 할수 있는 한 단위&lt;/strong&gt;를 일컫는 말이다.&lt;/p&gt;
&lt;h2 id=&quot;함수로서의-함수&quot;&gt;&lt;a href=&quot;#함수로서의-함수&quot; class=&quot;headerlink&quot; title=&quot;함수로서의 함수&quot;&gt;&lt;/a&gt;함수로서의 함수&lt;/h2&gt;&lt;p&gt;순수함수 - 순수함수에서는 입력이 같으면 결과도 반드시 같다.&lt;br&gt;순수함수에는 부수효과가 없어야 한다.&lt;br&gt;함수도 객체다. 자바스크립트 함수는 Function 객체의 인스턴스이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="서브루틴으로서의-함수"><a href="#서브루틴으로서의-함수" class="headerlink" title="서브루틴으로서의 함수"></a>서브루틴으로서의 함수</h2><p>서브루틴은 아주 오랜 된 개념이며 복잡한 코드를 간단하게 만드는 기초적인 수단입니다.<br>서브루틴은 프로시저, 루틴, 서브프로그램, 매크로 등 다양한 이름으로 불립니다. 이들은 모두 매우 단순하고 <strong>범용적인 호출 할수 있는 한 단위</strong>를 일컫는 말이다.</p><h2 id="함수로서의-함수"><a href="#함수로서의-함수" class="headerlink" title="함수로서의 함수"></a>함수로서의 함수</h2><p>순수함수 - 순수함수에서는 입력이 같으면 결과도 반드시 같다.<br>순수함수에는 부수효과가 없어야 한다.<br>함수도 객체다. 자바스크립트 함수는 Function 객체의 인스턴스이다.</p><a id="more"></a><h2 id="변수로서의-함수"><a href="#변수로서의-함수" class="headerlink" title="변수로서의 함수"></a>변수로서의 함수</h2><blockquote><p>함수를 가리키는 변수를 만들어 별명을 정할 수 있다,<br>배열에 함수를 넣을 수 있습니다. 물론 다른 타입의 데이터와 섞일 수 있습니다.<br>함수를 객체의 프로퍼티로 사용할 수 있습니다.<br>함수를 함수에 전달 할 수 잇습니다.<br>함수가 함수를 반환 할 수 있습니다.<br>함수를 매개변수로 받는 함수를 반환하는 것도 물론 가능합니다.</p></blockquote><h2 id="배열-안의-함수"><a href="#배열-안의-함수" class="headerlink" title="배열 안의 함수"></a>배열 안의 함수</h2><p>배열을 사용하면 작업 단계를 언제든 쉽게 바꿀 수 있다는 장점이 있다.<br>어떤 작업을 빼야 한다면 배열에서 제거하기만 하면되고, 추가할 작업이 있다면 배열에 추가하기만 하면 된다.</p><h2 id="함수의-함수-전달"><a href="#함수의-함수-전달" class="headerlink" title="함수의 함수 전달"></a>함수의 함수 전달</h2><p>함수에 함수를 전달하는 다른 용도는 <code>비동기적 프로그래밍</code>입니다. 이런 용도로 전달하는 함수를 보통 <code>콜백</code>이라 부르며 약자로 cb를 쓸때가 많습니다. 콜백 함수는 <strong>자신을 감싼 함수가 실행을 마쳤을때 호출</strong>됩니다.<br>함수에 함수를 전달하는 대표적인 사례가 콜백이긴 하지만 그게 전부는 아니다.<br>함수는 동작이고, 함수를 받은 함수는 그 동작을 활용할 수 있다.</p><h2 id="함수를-반환하는-함수"><a href="#함수를-반환하는-함수" class="headerlink" title="함수를 반환하는 함수"></a>함수를 반환하는 함수</h2><p>매개변수 여러개를 받는 함수를 매개변수 하나만 받는 함수로 바꾸는 것을 <code>커링</code> 이라고 부른다.<br>커링이라는 이름은 이 패턴을 만든 미국의 수학자 하스켈 커리의 이름을 딴것이다.</p><h2 id="재귀"><a href="#재귀" class="headerlink" title="재귀"></a>재귀</h2><p>재귀 역시 널리 쓰이며 함수를 활용하는 중요한 패턴입니다, <code>재귀</code>란 <strong>자기 자신을 호출하는 함수</strong> 입니다.<br>같은 일을 반복하면서 그 대상이 점차 줄어드는 상황에서 재귀를 유용하게 활용 할 수 있습니다.<br>재귀 함수에는 <strong>종료조건</strong>이 있어야 합니다. 종료 조건이 없다면 자바스크립트 인터프리터에서 스택이 너무 깊다고 판단할 때까지 재귀 호출을 계속하다가 프로그램이 멈춥니다.</p><h2 id="함수형프로그래밍"><a href="#함수형프로그래밍" class="headerlink" title="함수형프로그래밍"></a>함수형프로그래밍</h2><p>어떤 방법이 ‘더 좋은’ 방법인가? 이 질문에 정확한 답은 없다. 여러가지 상황에 맞추어 사용하면된다.</p>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/08/03/Learning-JavaScript-chapter13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>러닝 자바스크립트 스터디 자료 - CHAPTER 12. 이터레이터와 제너레이터</title>
      <link>https://mishka.kr/2019/08/03/Learning-JavaScript-chapter12/</link>
      <guid>https://mishka.kr/2019/08/03/Learning-JavaScript-chapter12/</guid>
      <pubDate>Fri, 02 Aug 2019 15:07:02 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;이터레이터&quot;&gt;&lt;a href=&quot;#이터레이터&quot; class=&quot;headerlink&quot; title=&quot;이터레이터&quot;&gt;&lt;/a&gt;이터레이터&lt;/h2&gt;&lt;p&gt;이터레이터는 ‘지금 어디있는지’ 파악할 수 있도록 돕는다는 면에서 일종의 &lt;strong&gt;책갈피&lt;/strong&gt;와 비슷한 개념이다. 배열은 이터러블 객체의 좋은 예이다. 책에 여러 페이지가 있는 것처럼 배열에는 여러 요소가 들어 있으므로 책에 책갈피를 끼울수 있듯 &lt;code&gt;배열에는 이터레이터&lt;/code&gt;를 사용 할 수 있다.&lt;/p&gt;
&lt;p&gt;next메서드는 더이상 진행 할것이 없으면 undefined가 되지만 next는 계속 호출 할 수 있습니다.&lt;br&gt;물론 그렇다고 결과가 바뀌는건 아니다.&lt;/p&gt;
&lt;p&gt;이터레이터는 &lt;code&gt;모두 독립적&lt;/code&gt;입니다. 즉 새 이터레이터를 만들 때마다 처음에서 시작합니다.&lt;br&gt;그리고 각각 다른 요소를 가리키는 이터레이터 여러 개를 동시에 사용할 수도 있습니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="이터레이터"><a href="#이터레이터" class="headerlink" title="이터레이터"></a>이터레이터</h2><p>이터레이터는 ‘지금 어디있는지’ 파악할 수 있도록 돕는다는 면에서 일종의 <strong>책갈피</strong>와 비슷한 개념이다. 배열은 이터러블 객체의 좋은 예이다. 책에 여러 페이지가 있는 것처럼 배열에는 여러 요소가 들어 있으므로 책에 책갈피를 끼울수 있듯 <code>배열에는 이터레이터</code>를 사용 할 수 있다.</p><p>next메서드는 더이상 진행 할것이 없으면 undefined가 되지만 next는 계속 호출 할 수 있습니다.<br>물론 그렇다고 결과가 바뀌는건 아니다.</p><p>이터레이터는 <code>모두 독립적</code>입니다. 즉 새 이터레이터를 만들 때마다 처음에서 시작합니다.<br>그리고 각각 다른 요소를 가리키는 이터레이터 여러 개를 동시에 사용할 수도 있습니다.</p><a id="more"></a><h2 id="이터레이션-프로토콜"><a href="#이터레이션-프로토콜" class="headerlink" title="이터레이션 프로토콜"></a>이터레이션 프로토콜</h2><p>이터레이터는 그 자체로 크게 쓸모가 있다기보다는 더 쓸모 있는 동작이 가능해지도록 한다는데 의미가 있다.<br>이터레이터 프로토콜은 모든 객체를 이터러블 객체로 바꿀 수 있습니다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line">    add(message)&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.messages.push(&#123; message, <span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">Date</span>.now() &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="hljs-built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span>.this.messages.valus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이터레이션 프로토콜은 클래스에 심볼 메서드 Symbol.iterator가 있고 이 메서드가 이터레이터처럼 동작하는 객체, 즉 value와 done프로퍼티가 있는 개체를 반환하는 next메서드를 가진 객체를 반환한다면 그 클래스의 <code>인스턴스는 이터러블 객체</code>라는 뜻입니다.</p><h2 id="제너레이터"><a href="#제너레이터" class="headerlink" title="제너레이터"></a>제너레이터</h2><p>제너레이터란 이터레이터를 사용해 <code>자신의 실행을 제어하는 함수</code>입니다. 일반적인 함수는 매개변수를 받고 값을 반환하지만 호출자는 매개변수 외에는 함수의 실행을 제어할 방법이 전혀 없습니다.<br>함수를 호출하면 그 함수가 종료될 때까지 제어권을 완전히 넘기는 겁니다. 하지만 제너레이터에서는 그렇지 않다.</p><h3 id="제너레이터의-도입된-새로운-개념"><a href="#제너레이터의-도입된-새로운-개념" class="headerlink" title="제너레이터의 도입된 새로운 개념"></a>제너레이터의 도입된 새로운 개념</h3><blockquote><p>제너레이터는 언제든 호출자에게 제어권을 넘길 수 있습니다.<br>제너레이터는 호출한 즉시 실행되지는 않습니다. 대신 이터레이터를 반환하고, 이터레이터의 next 메서드를 호출함에 따라 실행됩니다.</p></blockquote><p>이 두가지 예외를 제외하면 일반적인 함수와 같습니다.</p><p>제너레이터를 만들때는 function키워드 뒤에 <strong>애스터리스크(*)</strong>를 붙입니다.<br>제너레이터에서는 return 외에 <em>yield 키워드</em>를 쓸 수 있습니다.</p><h2 id="yield-표현식과-양방향통신"><a href="#yield-표현식과-양방향통신" class="headerlink" title="yield 표현식과 양방향통신"></a>yield 표현식과 양방향통신</h2><p>통신은 yield 표현식을 통해 이뤄진다.<br>표현식은 값으로 평가되고 yield는 표현식이므로 반드시 어떤 값으로 평가 됩니다.<br>yield표현식의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수 입니다. </p><p>제너레이터를 시행했을 때 일어나는 일을 묘사한것 책 참고</p><h2 id="제너레이터와-return"><a href="#제너레이터와-return" class="headerlink" title="제너레이터와 return"></a>제너레이터와 return</h2><p>yield문은 설령 제너레이터의 마지만 문이더라도 제너레이터를 끝내지 않습니다.<br>제너레이터에서 return문은 사용하면 그 위치와 관계없이 done은 true가 되고, value 프로퍼티는 return이 반환하는 값이 됩니다.</p><blockquote><p>제너레이터에서 중요한 값을 return으로 반환하려 하지 마십시오.<br>제너레이터가 반환하는 값을 사용하려 할 때는 yield를 써야 하고 return은 제너레이터를 중간에 종료하는 목적으로만 사용해야 합니다.</p></blockquote><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>이터레이터는 배열이나 객체처럼 여러 가지 값을 제공할 수 잇는 컬렉션의 동작 방식을 <code>표준화</code>했습니다.<br>이터레이터로 할 수 있는 일은 <code>ES6 이전에도 모두 할 수 있었으므로</code> 어떤 기능이 추가된 것은 아니다.<br>중요하면서도 자주 사용하는 패턴을 표준화했다는데 의미가 있다.</p><p>제너레이터를 사용하면 함수를 훨씬 더 유연하고 효율적으로 사용 할 수 있다.<br>제너레이터는 모든 연산을 지연시켰다가 필요할 때만 수행하게 만들 수 있다.</p>]]></content:encoded>
      
      <comments>https://mishka.kr/2019/08/03/Learning-JavaScript-chapter12/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
